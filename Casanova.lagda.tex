\documentclass{report}

\usepackage{newunicodechar}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
% The coloring distracts the author.
\usepackage[bw]{agda}

% What is a good place for this crap?
\newunicodechar{⊤}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{ℕ}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{₁}{\ensuremath{\mathnormal{_1}}}
\newunicodechar{₂}{\ensuremath{\mathnormal{_2}}}
\newunicodechar{≅}{\ensuremath{\mathnormal{\cong}}}

\title{Casanova Fly: A Formally-Verified Computer Algebra System}

\begin{document}
\maketitle{}

\begin{abstract}
The author presents a formally-verified computer algebra system.
\end{abstract}

\chapter{Prerequisites for Understanding}
The author recommends that anyone who tries to understand Casanova Fly is familiar with the following modules:

\begin{code}
open import Function
open import Data.Fin using (Fin)
open import Data.Nat
open import Data.Sum
open import Level
open import Data.String
open import Relation.Binary.PropositionalEquality hiding ([_])
open import Data.Vec
open import Data.Maybe
open import Relation.Nullary
open import Relation.Binary
open import Data.Bool
open import Data.Rational
  as ℚ
  using (ℚ
        )
open import Data.Product
open import Data.List.Relation.Unary.Any using (any?)
open import Data.Fin as Fin using (Fin)

import Data.List as List
import Data.Nat.Coprimality as Coprimality
import Data.Integer
\end{code}

\chapter{Useful Abbreviations and Associated Functions}
A value of type \AgdaFunction{Exceptional} \AgdaBound{A} can be a success-indicating value of \AgdaBound{A} or a \AgdaPostulate{String} which describes some sort of failure.

\begin{code}
Exceptional : {a : Level} -> Set a -> Set a
Exceptional A = String ⊎ A
\end{code}

If no values are exceptional, then the output contains the combination of both non-exceptional values.  Otherwise, the output contains the first exceptional value.

\begin{code}
condenseExceptions : {a : Level} ->
                     {A : Set a} ->
                     Exceptional A ->
                     Exceptional A ->
                     Exceptional (A × A)
condenseExceptions (inj₂ x) (inj₂ y) = inj₂ (x , y)
condenseExceptions (inj₁ e) _ = inj₁ e
condenseExceptions _ (inj₁ e) = inj₁ e
\end{code}

\chapter{The Computer Algebra System Types}

\section{The Type of Mostly-Unverified Computer Algebra Systems}
Fundamentally, a computer algebra system for an expression type \(\epsilon\) can be thought of as being a combination of the following:

\begin{itemize}
  \item a single-step evaluation function which is capable of describing failures,
  \item a proof of decidable structural equality of \(\epsilon\) values,
  \item a function which determines certain algebraic equality on non-bogus \(\epsion\) values,
  \item a function which converts natural number values into \(\epsilon\) values,
  \item a proof which indicates that for any two natural numbers \(n_1\) and \(n_2\), if \(n_1 \neq n_2\), then the representation of \(n_1\) is not equal to the representation of \(n_2\),
  \item a function which performs the maximum number of evaluation steps on the input, and
  \item a function which displays all evaluation steps which are used on a given input.
\end{itemize}

\AgdaDatatype{CAS} is the type of such computer algebra systems.

\subsection{The Single-Step Evaluation Function}
If such a step is possible, then the single-step evaluation function, which is represented in \AgdaDatatype{CAS} records as some \AgdaField{exceptionallyEvaluate} field, performs a single evaluation step on the input.  If no such step is possible, but the input is not bogus, then the output just contains the input.  If the input is bogus, then the output contains a description of the bogusness.

For the purposes of this document, an ``evaluation step'' is the application of a basic operation, e.g., addition or commuting the arguments of a function.  More formally, one can say that an evaluation step is the application of an operation which cannot be further simplified or decomposed into simpler operations.

\subsection{The Proof of Structural Equality}
This one, which is represented via the \AgdaField{structuralEquality} field, should be simple enough for anyone who is familiar with \AgdaFunction{DecidableEquality}.

\subsection{The Algebraic Equality Function}
The algebriac equality function is a function \(f\) such that \(\left(f x y\right)\) is \AgdaInductiveConstructor{inj₂} \AgdaInductiveConstructor{true} if and only if the CAS can certainly determine that \(x\) is algebraically equal to \(y\).  \AgdaInductiveConstructor{inj₁} values contain descriptions of errors.  The output is \AgdaInductiveConstructor{inj₂} \AgdaInductiveConstructor{false} if and only if the CAS \emph{cannot} certainly determine that the arguments are algebraically equal.  This function is represented through \AgdaField{definitelyEquals}.

\subsection{The Natural-to-ε Function}
The author thinks that any computer algebra system which is worthy of being given the time of day can represent natural numbers --- after all, the time of day can be represented \emph{as} a natural number!  Anyway, \AgdaField{fromℕ} indicates that a mapping from the natural numbers to the expression type of the given computer algebra system exists.

\subsection{The Natural Number Proofs}
In addition to the basic mapping, proofs of the following attributes should exist:

\begin{itemize}
  \item Any two natural numbers differ only if the CAS's representations of the numbers differ.
\end{itemize}

\subsection{The Tracing Maximum Evaluation Function}
A compliant CAS also has a function which performs the maximum number of non-repeating simplification steps on the input, returning a list all steps which were taken to get the output, regardless of whether or not the output is an exception.  In \AgdaDatatype{CAS} records, this function is represented through \AgdaField{traceEvaluate}.

\subsection{The Non-Tracing Maximum Evaluation Function}
A compliant CAS also has a function which performs the maximum number of non-repeating simplification steps on the input but just returns the resulting exception or expression.  In \AgdaDatatype{CAS} records, this function is represented through \AgdaField{rEvaluate}.

\subsection{The Definition Proper}

\begin{code}
record CAS {a : Level} (ε : Set a) : Set a where
  field
    exceptionallyEvaluate : ε -> Exceptional ε
    structuralEquality : DecidableEquality ε
    definitelyEquals : ε -> ε -> Exceptional Bool
    fromℕ : ℕ -> ε
    different-if-nats-are-different :
      {n1 n2 : ℕ} -> n1 ≢ n2 -> fromℕ n1 ≢ fromℕ n2
    structural-equality-implies-definite-equality :
      (e1 e2 : ε) ->
      e1 ≡ e2 ->
      inj₂ true ≡ definitelyEquals e1 e2

  traceEvaluate : ε -> List.List (Exceptional ε)
  traceEvaluate = nrp ∘ possibleEvaluationSteps ∘ inj₂
    where
    possibleEvaluationSteps : Exceptional ε -> List.List (Exceptional ε)
    possibleEvaluationSteps (inj₁ exc) = List.[ inj₁ exc ]
    possibleEvaluationSteps (inj₂ e) =
      inj₂ e List.∷ possibleEvaluationSteps (exceptionallyEvaluate e)
    nrp : List.List (Exceptional ε) -> List.List (Exceptional ε)
    nrp = nrpHelper List.[]
      where
      nrpHelper : List.List (Exceptional ε) ->
                  List.List (Exceptional ε) ->
                  List.List (Exceptional ε)
      nrpHelper x List.[] = x
      nrpHelper x (inj₁ y List.∷ ys) = x List.++ List.[ inj₁ y ]
      nrpHelper x (inj₂ y List.∷ ys) with any? (structuralEquality y) (inj2s x)
        where
        inj2s : {a b : Level} ->
                {A : Set a} ->
                {B : Set b} ->
                List.List (A ⊎ B) ->
                List.List B
        inj2s List.[] = List.[]
        inj2s (inj₁ x List.∷ xs) = inj2s xs
        inj2s (inj₂ x List.∷ xs) = x List.∷ inj2s xs
      ... | no unique = nrpHelper (x List.++ List.[ inj₂ y ]) ys
      ... | yes iveSeenEverythingBefore = x

  rEvaluate : ε -> Exceptional ε
  rEvaluate e = fromMaybe (inj₂ e) (List.last (traceEvaluate e))
\end{code}

\section{The Type of Verified Computer Algebra Systems}
For the purposes of this document, a verified computer algebra system is the combination of a \AgdaDatatype{CAS} computer algebra system \emph{and} some guarantees about the functions which are derived from the fields of the \AgdaDatatype{CAS} record.  The non-\AgdaDatatype{CAS} parts of the combination are as follows:

\begin{itemize}
 a proof which indicates that any non-bogus element \(e\) of type \AgdaBound{ε} is definitely equal to \(e\).
\end{itemize}

\subsection{The Reflexivity Field}

\subsection{The Definition Proper}

\begin{code}
record VCAS {a : Level} (ε : Set a) (Cas : CAS ε) : Set a where
  open CAS Cas
  field
    reflexivity : (e : ε) ->
                  Is-just (isInj₁ (rEvaluate e)) ->
                  inj₂ true ≡ definitelyEquals e e
\end{code}

\chapter{The Core Datatypes and Associated Functions}

\section{Type Declarations}

\subsection{\AgdaDatatype{F}'s Type and Summary}
Values of type \AgdaDatatype{F} represent functions.

\begin{code}
data F : Set
\end{code}

\subsection{\AgdaDatatype{ε}'s Type and Summary}
Values of \AgdaDatatype{ε} represent expressions.

\begin{code}
data ε : Set
\end{code}

\section{The Actual Definitions\ldots and Supporting Functions}

\subsection{Completing \AgdaDatatype{F}'s Definition}

\begin{code}
data F where
  -- | @Abs@ represents the absolute value function.
  Abs
   -- | @Negate@ represents the negation function.
   Negate
   -- | @Sum@ represents the sum function.
   Sum
   -- | @Difference@ represents the difference, i.e., subtraction, function.
   Difference
   -- | @Product@ represents the product, i.e., multiplication, function.
   Product
   -- | @Exponent@ represents the exponentiation function.
   Exponent : F
  -- | @Lambda names body@ represents a lambda function whose bound variables
  -- are listen in @names@ and whose body is @body@.  Alternatively, if @names@
  -- consists of values @n1@, @n2@, @n3@, and so on, one could say that
  -- @Lambda names body@ is equivalent to Agda's @\ n1 n2 n3 ... -> body2@, where
  -- @body2@ is an expansion of @body@.
  Lambda : List.List String -> ε -> F
\end{code}

\subsection{The Arity-Determining Function}
\AgdaFunction{arity} \AgdaBound{f} is the arity of the \AgdaBound{f} function.

\begin{code}
arity : F -> ℕ
arity Abs = 1
arity Negate = 1
arity Sum = 2
arity Difference = 2
arity Product = 2
arity Exponent = 2
arity (Lambda names body) = List.length names
\end{code}

\subsection{The Commutativity-Determining Function}
\AgdaFunction{isCommutative} \AgdaBound{f} \AgdaBound{a} is \AgdaInductiveConstructor{true} if and only if \AgdaBound{f} represents a commutative function.

\begin{code}
isCommutative : (f : F) -> arity f ≡ 2 -> Bool
isCommutative Sum refl = true
isCommutative Difference refl = false
isCommutative Product refl = true
isCommutative Exponent refl = false
isCommutative (Lambda names body) equality = false
\end{code}

\subsection{Completing \AgdaDatatype{ε}'s Definition}

\begin{code}
data ε where
  -- | @Infinity@ represents infinity.
  Infinity : ε
  -- | @Variable s@ represents a variable whose name is @n@.
  Variable : String -> ε
  -- | @NumberNat q@ represents @q@.
  NumberRat : ℚ -> ε
  -- | @Ap f e@ represents the result of applying @f@ to @e@.
  Ap : (f : F) -> Vec ε (arity f) -> ε
\end{code}

\section{Additional Functions}

\subsection{Decidable Structural Equality on \AgdaDatatype{F}}
This function is used to determine whether or not the input arguments are structurally equivalent.

\begin{code}
structuralEqualityOnF : DecidableEquality F
structuralEqualityOnF = {!!}
\end{code}

\subsection{Decidable Structural Equality on \AgdaDatatype{ε}}
This function is used to determine whether or not the input arguments are structurally equivalent.

\begin{code}
structuralEqualityOnε : DecidableEquality ε
structuralEqualityOnε = {!!}
\end{code}

\chapter{Computational Functions and Ilk}

\section{The Single-Step Evaluation Function}
\AgdaFunction{exceptionallyEvaluate} \AgdaBound{x} contains the result of performing a single evaluation step on \AgdaBound{x} \emph{or} a value which indicates that \AgdaBound{x} is in some way nonsensical.

\begin{code}
exceptionallyEvaluate : ε -> Exceptional ε
exceptionallyEvaluate = {!!}
\end{code}

\section{The Single-Step Evaluation Function which \emph{also} Supports Commutativity}
\AgdaFunction{commutativeEvaluate} \AgdaBound{e} performs a single evaluation step on the input expression but can also do some fancy stuff when applicable, e.g., switching the arguments of commutative functions.

\begin{code}
commutativeEvaluate : ε -> Exceptional ε
commutativeEvaluate = {!!}
\end{code}

\section{The Algebraic Equality Function}
If some sort of failure is encountered, then an appropriate exception is output.  Otherwise, \AgdaFunction{definitelyEquals} \AgdaBound{e} \AgdaBound{f} is \AgdaInductiveConstructor{inj₂} \AgdaInductiveConstructor{true} if and only if the function determines that \AgdaBound{e} is algebraically equal to \AgdaBound{f}.

\begin{code}
definitelyEquals : ε -> ε -> Exceptional Bool
definitelyEquals x y = Data.Sum.map₂ (\ exp -> List.or (checks x y))
                                     (condenseExceptions (e x) (e y))
  where
  e = exceptionallyEvaluate
  checks : ε -> ε -> List.List Bool
  checks a b = List.map (isYes ∘ uncurry structuralEqualityOnε)
                        (cartesianProduct (perms x) (perms y))
    where
    cartesianProduct : {a b : Level} ->
                       {A : Set a} ->
                       {B : Set b} ->
                       List.List A ->
                       List.List B ->
                       List.List (A × B)
    cartesianProduct x y =
      List.concat (List.map (\ x -> List.map (\ y -> x , y) y) x)
    perms : ε -> List.List ε
    perms (Ap f e) = perms' f (Data.Vec.toList e) {!!}
      where
      c : {a : Level} ->
          {A B : Set a} ->
          A ≡ B ->
          A -> B
      c refl t = t
      combine : (f : F) -> (e : List.List ε) -> arity f ≡ List.length e -> ε
      combine f e lengthMatch = Ap f (c (sym (cong (Vec ε) lengthMatch))
                                        (Data.Vec.fromList e))
      perms' : (f : F) -> (e : List.List ε) -> arity f ≡ List.length e -> List.List ε
      perms' f e@(e1 List.∷ e2 List.∷ List.[]) lengthMatches with isCommutative f lengthMatches
      ... | false = List.[ combine f e lengthMatches ]
      ... | true =
        f' (reverse (e1 ∷ [ e2 ])) List.∷ f' (e1 ∷ [ e2 ]) List.∷
        List.map (\ e2 -> f' (e1 ∷ [ e2 ])) (perms e2) List.++
        List.map (\ e1 -> f' (e1 ∷ [ e2 ])) (perms e1) List.++
        List.concat (List.map (\ (e1 , e2) -> f' (e1 ∷ [ e2 ]) List.∷
                                              List.[ f' (e2 ∷ [ e1 ]) ])
                              (List.zip (perms e1) (perms e2)))
        where
        f' = Ap f ∘ c (sym (cong (Vec ε) lengthMatches))
      perms' f e lengthMatches = List.[ combine f e lengthMatches ]
    perms o = List.[ o ]
\end{code}

\chapter{Proofs of Correctness}

\begin{code}
module DefinitelyEqualsProperties where
  reflexivity : (e : ε) -> inj₂ true ≡ definitelyEquals e e
  reflexivity = {!!}

module CommutativeEvaluationProperties where
  ce = commutativeEvaluate

  0^0-is-1 :
    inj₂ (NumberRat ℚ.1ℚ) ≡
      exceptionallyEvaluate (Ap Exponent (NumberRat ℚ.0ℚ ∷ [ NumberRat ℚ.0ℚ ]))
  0^0-is-1 = {!!}
\end{code}

\chapter{Wrapping up Everything}

\begin{code}
CasanovaFly-Base : CAS ε
CasanovaFly-Base = record
  { exceptionallyEvaluate = commutativeEvaluate
  ; structuralEquality = structuralEqualityOnε
  ; definitelyEquals = definitelyEquals
  ; fromℕ = \ n ->
      NumberRat (ℚ.mkℚ (Data.Integer.+ n)
                       0
                       (Coprimality.sym (Coprimality.1-coprimeTo n)))
  ; different-if-nats-are-different = {!!}
  ; structural-equality-implies-definite-equality = {!!}
  }

CasanovaFly-Verified : VCAS ε CasanovaFly-Base
CasanovaFly-Verified = record
  {reflexivity = {!!}
  }
\end{code}
\end{document}
