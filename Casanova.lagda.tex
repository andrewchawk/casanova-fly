\documentclass{report}

\usepackage{newunicodechar}
\usepackage{geometry}[margin=1.25in]
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
% The coloring distracts the author.
\usepackage[bw]{agda}
\usepackage{unicode-math}

% What is a good place for this crap?
\newunicodechar{⊤}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{⊥}{\ensuremath{\mathnormal{\bot}}}
\newunicodechar{ℕ}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{₁}{\ensuremath{\mathnormal{_1}}}
\newunicodechar{₂}{\ensuremath{\mathnormal{_2}}}
\newunicodechar{≅}{\ensuremath{\mathnormal{\cong}}}
\newunicodechar{ε}{\ensuremath{\mathnormal{\epsilon}}}
\newunicodechar{λ}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{ℚ}{\ensuremath{\mathnormal{\mathbb{Q}}}}
\newunicodechar{∷}{\ensuremath{\mathnormal{\Colon}}}
\newunicodechar{⊎}{\ensuremath{\mathnormal{\uplus}}}
\newunicodechar{≈}{\ensuremath{\mathnormal{\approx}}}
\newunicodechar{≉}{\ensuremath{\mathnormal{\napprox}}}
\newunicodechar{≡}{\ensuremath{\mathnormal{\equiv}}}
\newunicodechar{≢}{\ensuremath{\mathnormal{\nequiv}}}
\newunicodechar{⊔}{\ensuremath{\mathnormal{\sqcup}}}
\newunicodechar{≟}{\ensuremath{\mathnormal{\stackrel{?}{=}}}}
\newunicodechar{∘}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{∧}{\ensuremath{\mathnormal{\land}}}
\newunicodechar{∧}{\ensuremath{\mathnormal{\land}}}
\newunicodechar{⇒}{\ensuremath{\mathnormal{\Rightarrow}}}
\newunicodechar{⟨}{\ensuremath{\mathnormal{\langle}}}
\newunicodechar{⟩}{\ensuremath{\mathnormal{\rangle}}}
\newunicodechar{∎}{\ensuremath{\mathnormal{\blacksquare}}}
\newunicodechar{∈}{\ensuremath{\mathnormal{\in}}}
\newunicodechar{∉}{\ensuremath{\mathnormal{\notin}}}

\title{Casanova Fly: A Formally-Verified Computer Algebra System}

\begin{document}
\maketitle{}

\begin{abstract}
In writing this paper, the author tries to answer the following questions:

\begin{itemize}
  \item Formally, what constitutes a computer algebra system, i.e., what are the essential functions of a computer algebra system?
  \item Formally, what constitutes a formally-verified computer system?  In other words, what guarantees can be made about \emph{all} good computer algebra systems?
  \item What is an example of such a formally-verified computer algebra system?
\end{itemize}

In short, the answer to the last question is ``Casanova Fly, of course''.  The remaining questions are hairy and are best answered through the non-abbreviated version of this paper.
\end{abstract}

\chapter{Prerequisites for Understanding}
The author recommends that anyone who tries to understand Casanova Fly is familiar with the following modules:

\begin{code}
open import Function
open import Data.Fin using (Fin)
open import Data.Nat
open import Data.Sum
open import Level
open import Data.String hiding (_≈_)
open import Relation.Binary.PropositionalEquality renaming ([_] to ⟦_⟧)
open ≡-Reasoning
open import Data.Vec
open import Data.Maybe
open import Relation.Nullary
open import Relation.Binary
open import Data.Bool
open import Data.Rational
  as ℚ
  using (ℚ
        )
open import Data.Product
open import Data.List.Relation.Unary.Any as AnyList using (any?)
open import Data.Fin as Fin using (Fin)
open import Data.List.Relation.Unary.Unique.Propositional
  renaming
    ( Unique to UniqueList
    )
open import Relation.Nullary.Decidable
  using
    ( dec-yes
    )
open import Data.Empty.Polymorphic using (⊥)
open import Data.List.Membership.Propositional

import Data.List as List
import Data.Nat.Coprimality as Coprimality
import Data.Integer
import Data.Sum.Properties
import Data.List.Relation.Unary.All as AllList
import Data.List.Relation.Unary.All.Properties as AllListProp
import Data.List.Relation.Unary.AllPairs as AllPairsList
import Data.Maybe.Properties
import Data.Maybe.Relation.Unary.Any as AnyMaybe
import Data.Nat.Properties
import Data.Product.Properties as ProdProp
import Data.Vec.Properties as VecProp
import Data.Vec.Relation.Unary.Any as AnyVec
\end{code}

\chapter{Useful Abbreviations and Ilk}

\section{The Exception Type}
A value of type \AgdaFunction{Exceptional} \AgdaBound{A} can be a success-indicating value of \AgdaBound{A} or a \AgdaPostulate{String} which describes some sort of failure.

\begin{code}
Exceptional : {a : Level} -> Set a -> Set a
Exceptional A = String ⊎ A
\end{code}

\subsection{The Exception Condensation Function}
If no values are exceptional, then the output contains the combination of both non-exceptional values.  Otherwise, the output contains the first exceptional value.

\begin{code}
condenseExceptions : {a : Level} ->
                     {A : Set a} ->
                     Exceptional A ->
                     Exceptional A ->
                     Exceptional (A × A)
condenseExceptions (inj₂ x) (inj₂ y) = inj₂ (x , y)
condenseExceptions (inj₁ e) _ = inj₁ e
condenseExceptions _ (inj₁ e) = inj₁ e
\end{code}

\section{The \AgdaDatatype{Maybe}-Sequencing Function}
\AgdaFunction{sequenceMaybe} \AgdaSymbol(\AgdaInductiveConstructor{just} \AgdaSymbol(\AgdaInductiveConstructor{just} \AgdaBound{x}\AgdaSymbol)\AgdaSymbol) is \AgdaInductiveConstructor{just} \AgdaBound{x}.  For all other values \AgdaBound{x}, \AgdaFunction{sequenceMaybe} \AgdaBound{x} is \AgdaInductiveConstructor{nothing}.

\begin{code}
module SequenceMaybe where
  sequenceMaybe : {a : Level} ->
                  {A : Set a} ->
                  Maybe (Maybe A) ->
                  Maybe A
  sequenceMaybe (just (just x)) = just x
  sequenceMaybe x = nothing
\end{code}

\subsection{The Properties of the Function}

\begin{code}
  module Properties
    {a : Level}
    {A : Set a} where
\end{code}

\subsubsection{Sequencing the Head of a Singleton List}
\AgdaFunction{Properties.sm-of-head-of-singleton-list-is-element} is a proof which indicates that for any given list \AgdaBound{x}, if \AgdaBound{x} is a singleton list which contains a value \(v\), then \AgdaFunction{sequenceMaybe} \AgdaSymbol(\AgdaFunction{List.head} \AgdaBound{x}\AgdaSymbol) is equivalent to \(v\).

\begin{code}
    sm-of-head-of-singleton-list-is-element :
      (x : Maybe A) ->
      sequenceMaybe (List.head List.[ x ]) ≡ x
    sm-of-head-of-singleton-list-is-element nothing = refl
    sm-of-head-of-singleton-list-is-element (just x) = refl
\end{code}

\subsection{Exporting the Function}
The author recommends --- and facilitates --- using ``\AgdaFunction{sequenceMaybe}'' instead of ``\AgdaFunction{SequenceMaybe.sequenceMaybe}''; ``\AgdaFunction{SequenceMaybe.sequenceMaybe} is a bit long and, according to the author, is not the most readable name.

\begin{code}
sequenceMaybe = SequenceMaybe.sequenceMaybe
\end{code}

\section{The List Difference Function}
\AgdaFunction{listDiff} is the list difference function, which can be intuitively understood as being the result of substracting the second input list from the first input list.  More formally, one can say that \AgdaFunction{listDiff} \AgdaBound{x} \AgdaBound{y} is the list of all elements of \AgdaBound{x} which do not appear in \AgdaBound{y}.  Ordering is preserved.

\begin{code}
module listDiff
  {a : Level}
  {A : Set a}
  (DEQ : DecidableEquality A) where

  with-any : {x : A} ->
             {y : List.List A} ->
             Dec (x ∈ y) ->
             List.List A
  with-any (yes isAlreadyIn) = List.[]
  with-any {x} (no isDifferent) = List.[ x ]

  listDiff : List.List A -> List.List A -> List.List A
  listDiff List.[] y = List.[]
  listDiff (x List.∷ xs) y = with-any (any? (DEQ x) y) List.++ listDiff xs y
\end{code}

\subsection{The Properties of the List Difference Function}
This module contains a few proofs which indicates that \AgdaFunction{listDiff} is at least mildly functional.  For the sake of improving readability, the author has defined some module-specific variables and abbreviated functions.

\begin{code}
  module Properties where

    ld = listDiff
\end{code}

\subsubsection{The Absence Proof}
\AgdaFunction{every-element-of-second-list-is-absent} \AgdaBound{x} \AgdaBound{y} indicates that every element of \AgdaBound{y} is absent from \AgdaFunction{ld} \AgdaBound{x} \AgdaBound{y}.

\begin{code}
    every-element-of-second-list-is-absent :
      (x y : List.List A) ->
      (i : Fin (List.length y)) ->
      List.lookup y i ∉ ld x y
    every-element-of-second-list-is-absent = {!!}
\end{code}

\subsubsection{The Proof of Containment by the First List}
\AgdaFunction{output-is-subset-of-first-input} \AgdaBound{x} \AgdaBound{y} indicates that all elements of \AgdaFunction{ld} \AgdaBound{x} \AgdaBound{y} are also elements of \AgdaBound{x}.

\begin{code}
    output-is-subset-of-first-input :
      (x y : List.List A) ->
      AllList.All (_∈ x) (ld x y)
    output-is-subset-of-first-input = {!!}
\end{code}

\subsubsection{The Applicable Containment Proof}
\AgdaFunction{applicable-elements-are-contained} indicates that every element of \AgdaBound{x} which is not in \AgdaBound{y} is also an element of \AgdaFunction{ld} \AgdaBound{x} \AgdaBound{y}.

\begin{code}
    applicable-elements-are-contained :
      (x y : List.List A) ->
      (i : Fin (List.length x)) ->
      List.lookup x i ∉ y ->
      List.lookup x i ∈ ld x y
    applicable-elements-are-contained = {!!}
\end{code}

\subsection{Exporting the Function}
Despite not really being the worst offender in this paper, ``\AgdaFunction{listDiff.listDiff}'' is a bit repetitive and long; accordion, the author encourages instead using ``\AgdaFunction{listDiff}''.

\begin{code}
listDiff = listDiff.listDiff
\end{code}

\section{The First Repeat Position Function}
\AgdaFunction{firstRepeatPosition} is such that the following statements hold:

\begin{itemize}
  \item If \AgdaBound{x} contains no repeating elements, then \AgdaFunction{firstRepeatPosition} \AgdaBound{DEQ} \AgdaBound{x} is \AgdaInductiveConstructor{nothing}.
  \item If \AgdaBound{x} has repeating values, then \AgdaFunction{firstRepeatPosition} \AgdaBound{DEQ} \AgdaBound{x} contains the position of the first repeating value in \AgdaBound{x}.
\end{itemize}

\begin{code}
module firstRepeatPosition
  {a : Level}
  {A : Set a}
  (DEQ : DecidableEquality A) where

  firstRepeatPosition : (x : List.List A) -> Maybe (Fin (List.length x))
  firstRepeatPositionHelper : (x y : List.List A) -> Maybe (Fin (List.length y))

  firstRepeatPosition = firstRepeatPositionHelper List.[]

  firstRepeatPositionHelper x List.[] = nothing
  firstRepeatPositionHelper List.[] (y List.∷ ys) =
    Data.Maybe.map Fin.suc (firstRepeatPositionHelper List.[ y ] ys)
  firstRepeatPositionHelper (x List.∷ xs) (y List.∷ ys) =
    if isYes (any? (DEQ y) (x List.∷ xs))
      then just Fin.zero
      else Data.Maybe.map Fin.suc (firstRepeatPositionHelper (y List.∷ x List.∷ xs) ys)
\end{code}

\subsection{The Properties of the Function}
This module contains a few proofs which indicates that \AgdaFunction{firstRepeatPosition} really does work as described, after all.  For the sake of improving readability and preventing a repetitive strain injury, the author has also provided an abbreviation of the main function's name.

\begin{code}
  module Properties where

    pos = firstRepeatPosition
    posh = firstRepeatPositionHelper
\end{code}

\subsubsection{The Unique Prepending Proof}
\AgdaFunction{unique-element-prepend} indicates that if \AgdaBound{x} is not in \AgdaBound{xs}, then \AgdaFunction{pos} \AgdaSymbol(\AgdaBound{x} \AgdaOperator{\AgdaFunction{List.∷}} \AgdaBound{xs}\AgdaSymbol) contains the successor of \AgdaFunction{pos} \AgdaBound{xs} or is \AgdaInductiveConstructor{nothing}.

\begin{code}
    unique-element-prepend :
      (x : A) ->
      (xs : List.List A) ->
      AllList.All (_≢_ x) xs ->
      pos (x List.∷ xs) ≡ Data.Maybe.map Fin.suc (pos xs)
    unique-element-prepend x List.[] all = refl
    unique-element-prepend x xs@(x1 List.∷ xs1) alls@(a AllList.∷ as) = begin
      pos (x List.∷ xs)
        ≡⟨⟩
      mapSuc (posh List.[ x ] xs)
        ≡⟨⟩
      mapSuc
        (if isYes (any? (DEQ x1) List.[ x ])
            then just Fin.zero
            else mapSuc (posh (x1 List.∷ List.[ x ]) xs1))
        ≡⟨ cong (\ e -> mapSuc (if isYes e
                                   then just Fin.zero
                                   else mapSuc (posh (x1 List.∷ List.[ x ]) xs1)))
                x1-is-decidably-not-in-[x] ⟩
      mapSuc (mapSuc (posh (x1 List.∷ List.[ x ]) xs1))
        ≡⟨ cong mapSuc (sym (posh-moves-elements {x} {x1} {xs1} )) ⟩
      mapSuc (posh List.[ x ] xs)
        ≡⟨ cong mapSuc (sym (pos-is-posh {x} {xs} alls)) ⟩
      mapSuc (posh List.[] xs) ∎
      where
      mapSuc : {n : ℕ} -> Maybe (Fin n) -> Maybe (Fin (ℕ.suc n))
      mapSuc = Data.Maybe.map Fin.suc
      posh-moves-elements :
        {x y : A} ->
        {xs : List.List A} ->
        _≡_ (posh List.[ x ] (y List.∷ xs))
            (Data.Maybe.map Fin.suc (posh (y List.∷ List.[ x ]) xs))
      posh-moves-elements = {!!}
      pos-is-posh :
        {x : A} ->
        {xs : List.List A} ->
        AllList.All (_≢_ x) xs ->
        pos xs ≡ posh List.[ x ] xs
      pos-is-posh = {!!}
      x1-is-decidably-not-in-[x] :
        _≡_ (any? (DEQ x1) List.[ x ])
            (no (AllListProp.All¬⇒¬Any ((_∘ sym) a AllList.∷ AllList.[])))
      x1-is-decidably-not-in-[x] = {!!}
\end{code}

\subsubsection{The Proof of Nothingness's Implication of Uniqueness}
\AgdaFunction{pos-is-nothing-only-if-list-is-unique} indicates that \AgdaFunction{pos} \AgdaBound{xs} is \AgdaInductiveConstructor{nothing} only if \AgdaBound{xs} is a unique list.

\begin{code}
    pos-is-nothing-only-if-list-is-unique :
      (x : List.List A) ->
      pos x ≡ nothing ->
      UniqueList x
    pos-is-nothing-only-if-list-is-unique = {!!}
\end{code}

\subsubsection{The Prepended Nonunique List Proof}
\AgdaFunction{nonunique-prepend} indicates that the result of prepending a value to a non-unique list is \emph{also} a non-unique list.

\begin{code}
    nonunique-prepend :
      (x : A) ->
      (xs : List.List A) ->
      Is-just (pos xs) ->
      Is-just (pos (x List.∷ xs))
    nonunique-prepend x (y List.∷ ys) nonUniqueness with any? (DEQ x) (y List.∷ ys)
    ... | no xIsUniqueInYYs = justness-implies-justness index equality
      where
      index : Fin (List.length (x List.∷ y List.∷ ys))
      index = Fin.suc (to-witness nonUniqueness)
      justness-implies-justness :
        {a : Level} ->
        {A : Set a} ->
        {x : Maybe A} ->
        (y : A) ->
        x ≡ just y ->
        Is-just x
      justness-implies-justness y refl = AnyMaybe.just _
      self-is-just-to-witness :
        {a : Level} ->
        {A : Set a} ->
        {x : Maybe A} ->
        (isJust : Is-just x) ->
        x ≡ just (to-witness isJust)
      self-is-just-to-witness {x = just x} (AnyMaybe.just isJust) = refl
      equality : pos (x List.∷ y List.∷ ys) ≡ just index
      equality = begin
        pos (x List.∷ y List.∷ ys)
          ≡⟨ unique-element-prepend x (y List.∷ ys)
                                    (AllListProp.¬Any⇒All¬ _ xIsUniqueInYYs) ⟩
        Data.Maybe.map Fin.suc (pos (y List.∷ ys))
          ≡⟨ cong (Data.Maybe.map Fin.suc) (self-is-just-to-witness nonUniqueness) ⟩
        Data.Maybe.map Fin.suc (just (to-witness nonUniqueness))
          ≡⟨⟩
        just index ∎
    ... | yes xAppears = {!!}
\end{code}

\subsubsection{The Proof of Recursive Nothingness}
\AgdaFunction{pos-is-nothing-only-if-removal-is-nothing} indicates that \AgdaFunction{pos} \AgdaSymbol(\AgdaBound{x} \AgdaOperator{\AgdaFunction{∷}} \AgdaBound{xs}\AgdaSymbol) is \AgdaBound{nothing} only if \AgdaBound{xs} is unique.  Equivalently, one can say that the function proves that the result of appending an element \(x\) to a list \(xs\) is a unique list only if \(xs\) is a unique list.

\begin{code}
    pos-is-nothing-only-if-removal-is-nothing :
      {x : A} ->
      {xs : List.List A} ->
      pos (x List.∷ xs) ≡ nothing ->
      pos xs ≡ nothing
    pos-is-nothing-only-if-removal-is-nothing {x} {List.[]} always = refl
    pos-is-nothing-only-if-removal-is-nothing {x} {y List.∷ ys} isNothing with NOTHINGNESS
      where
      NOTHINGNESS : Dec (pos (y List.∷ ys) ≡ nothing)
      NOTHINGNESS = Data.Maybe.Properties.≡-dec Fin._≟_ _ _
    ... | yes alreadyDone = alreadyDone
    ... | no bogus = contradiction isNothing (just-is-not-nothing isJust)
      where
      module _
        {a : Level}
        {A : Set a} where

        nonnothing-is-just : {x : Maybe A} -> x ≢ nothing -> Is-just x
        nonnothing-is-just {x = just x} notNothing = AnyMaybe.just _
        nonnothing-is-just {x = nothing} notNothing = contradiction refl notNothing

        just-is-not-nothing : {x : Maybe A} -> Is-just x -> x ≢ nothing
        just-is-not-nothing {x = just x} j ()

      isJust = nonunique-prepend x (y List.∷ ys) (nonnothing-is-just bogus)
\end{code}

\subsubsection{The Proof of Being Nothing}
\AgdaFunction{pos-of-unique-list-is-length} indicates that \AgdaFunction{firstRepeatPosition} \AgdaBound{x} is \AgdaInductiveConstructor{nothing} if all elements of \AgdaBound{x} are unique.

\begin{code}
    pos-of-unique-list-is-nothing :
      (x : List.List A) ->
      UniqueList x ->
      pos x ≡ nothing
    pos-of-unique-list-is-nothing List.[] u = refl
    pos-of-unique-list-is-nothing (x List.∷ xs) (u AllPairsList.∷ us) =
      unique-prepend-nothing u (pos-of-unique-list-is-nothing xs us)
      where
      unique-prepend-nothing :
        {x : A} ->
        {xs : List.List A} ->
        AllList.All (_≢_ x) xs ->
        pos xs ≡ nothing ->
        pos (x List.∷ xs) ≡ nothing
      unique-prepend-nothing AllList.[] refl = refl
      unique-prepend-nothing {x} xs@{x1 List.∷ xs1} alls eq with any? (DEQ x) xs
      ... | yes nonsense = contradiction nonsense (AllListProp.All¬⇒¬Any alls)
      ... | no obviously = begin
        pos (x List.∷ xs)
          ≡⟨ unique-element-prepend x xs alls ⟩
        Data.Maybe.map Fin.suc (pos xs)
          ≡⟨ cong (Data.Maybe.map Fin.suc) pos-xs-is-nothing ⟩
        nothing ∎
        where
        x1-is-not-in-xs1 : AllList.All (_≢_ x1) xs1
        x1-is-not-in-xs1 with pos-is-nothing-only-if-list-is-unique xs eq
        ... | (u AllPairsList.∷ us) = u
        pos-xs-is-nothing : pos xs ≡ nothing
        pos-xs-is-nothing =
          unique-prepend-nothing {x1} {xs1}
                                 x1-is-not-in-xs1
                                 (pos-is-nothing-only-if-removal-is-nothing {x1} {xs1} eq)
\end{code}

\subsubsection{The Proof of Equalling the Position of the First Repeating Value}
\AgdaFunction{pos-is-position-of-first-repeat} indicates that \AgdaFunction{firstRepeatPosition} \AgdaBound{x} contains the position of the first repeating value in \AgdaBound{x} if \AgdaBound{x} has such a value.

\begin{code}
    pos-is-position-of-first-repeat :
      (x : List.List A) ->
      (i : Fin (List.length x)) ->
      UniqueList (List.take (Fin.toℕ i) x) ->
      List.lookup x i ∈ List.take (Fin.toℕ i) x ->
      pos x ≡ just i
    pos-is-position-of-first-repeat = {!!}
\end{code}

\subsection{The Proof of the Noncontainment of Zero}
\AgdaFunction{pos-is-never-zero} indicates that for no \AgdaBound{x}, \AgdaFunction{pos} \AgdaBound{x} contains a zero value.

\begin{code}
    pos-is-never-zero :
      (x : List.List A) ->
      Data.Maybe.map Fin.toℕ (pos x) ≢ just 0
    pos-is-never-zero List.[] ()
    pos-is-never-zero (x List.∷ List.[]) ()
    pos-is-never-zero (x List.∷ xs) = {!!}
\end{code}

\subsection{Exporting the Function}
``\AgdaFunction{firstRepeatPosition.firstRepeatPosition}'' is a bit long; as such, the author has elected to permit using the relatively short --- but still mildly verbose --- ``\AgdaFunction{firstRepeatPosition}''.  Praise be.

\begin{code}
firstRepeatPosition = firstRepeatPosition.firstRepeatPosition
\end{code}

\section{The Non-Repeating Subsequence Function}
\AgdaFunction{nonRepeatingPortion} \AgdaBound{DEQ} \AgdaBound{x} is the longest initial non-repeating subsequence within \AgdaBound{x}.  Equivalently, one can say that \AgdaFunction{nonRepeatingPortion} \AgdaBound{DEQ} \AgdaBound{x} is equivalent to \AgdaFunction{List.take} \AgdaBound{n} \AgdaBound{x}, where \AgdaBound{n} is such that \AgdaFunction{List.take} \AgdaBound{n} \AgdaBound{x} contains no two identical values.

\begin{code}
nonRepeatingPortion : {a : Level} ->
                      {A : Set a} ->
                      DecidableEquality A ->
                      List.List A ->
                      List.List A
nonRepeatingPortion DEQ x = List.take nonRepeatLength x
  where nonRepeatLength = maybe Fin.toℕ (List.length x) (firstRepeatPosition DEQ x)
\end{code}

\subsection{Properties of the Function}
This module contains a few proofs which indicates that \AgdaFunction{notRepeatingPortion} really \emph{is} as described.  For the sake of improving readability, the author has defined some module-specific variables and abbreviated functions.

\begin{code}
module nonRepeatingPortion-Properties
  {a : Level}
  {A : Set a}
  (DEQ : DecidableEquality A) where

  private
    nrp : List.List A -> List.List A
    nrp = nonRepeatingPortion DEQ
\end{code}

\subsubsection{The Proof of Being the Result of Taking}
\AgdaFunction{is-first-n-elements} \AgdaBound{x} indicates that \AgdaFunction{nrp} \AgdaBound{x} is really just the list of the first \(n\) elements of \AgdaBound{x}, where \(n\) is \AgdaFunction{List.length} \AgdaSymbol(\AgdaFunction{nrp} \AgdaBound{x}\AgdaSymbol).

\begin{code}
  is-first-n-elements :
    (x : List.List A) ->
    nrp x ≡ List.take (List.length (nrp x)) x
  is-first-n-elements = {!!}
\end{code}

\subsubsection{The Proof of Non-Repetition}
\AgdaFunction{contains-no-repeats} \AgdaBound{x} indicates that any two elements of \AgdaFunction{nrp} \AgdaBound{x} which are indexed by \AgdaBound{i} and \AgdaBound{j}, respectively, are equal only if \AgdaBound{i} is equal to \AgdaBound{j}.  Equivalently, one can say that \AgdaFunction{contains-no-repeats} \AgdaBound{x} indicates that \AgdaFunction{nrp} \AgdaBound{x} is actually a unique list, i.e., \emph{contains no repeats} of values.

\begin{code}
  contains-no-repeats :
    (x : List.List A) ->
    (i1 i2 : Fin (List.length (nrp x))) ->
    List.lookup (nrp x) i1 ≡ List.lookup (nrp x) i2 ->
    i1 ≡ i2
  contains-no-repeats List.[] ()
  contains-no-repeats (x List.∷ xs) i1 i2 equality with i1 Data.Fin.≟ i2
  ... | yes alreadyEqual = alreadyEqual
  ... | no shouldNotBe = {!!}
\end{code}

\subsubsection{The Proof which Indicates that the Value Really is the Longest Unique Sublist}
\AgdaFunction{is-really-the-longest} \AgdaBound{x} indicates that any value which immediately follows \AgdaFunction{nrp} \AgdaBound{x}'s last element of \AgdaBound{x} is already contained within \AgdaBound{nrp} \AgdaBound{x}.

\begin{code}
  is-really-the-longest :
    (x : List.List A) ->
    (i : Fin (List.length x)) ->
    Fin.toℕ i ≡ 1 + List.length (nrp x) ->
    AnyList.Any (\ i2 -> i2 ≡ List.lookup x i) (nrp x)
  is-really-the-longest = {!!}
\end{code}

\subsubsection{The Proof of Emptiness}
\AgdaFunction{only-empty-if-input-is-empty} indicates that for all lists \AgdaBound{x}, \AgdaFunction{nrp} \AgdaBound{x} is empty only if \AgdaBound{x} is empty.

\begin{code}
  only-empty-if-input-is-empty :
    (x : List.List A) ->
    List.length (nrp x) ≡ 0 ->
    List.length x ≡ 0
  only-empty-if-input-is-empty List.[] refl = refl
  only-empty-if-input-is-empty (x List.∷ xs) empty = contradiction empty {!!}
\end{code}

\subsubsection{The \emph{Other} Emptiness Proof}
\AgdaFunction{empty-inputs-beget-empty-outputs} indicates that the result of applying \AgdaFunction{nrp} to an empty list is just an empty list.

\begin{code}
  empty-inputs-beget-empty-outputs :
    (x : List.List A) ->
    List.length x ≡ 0 ->
    List.length (nrp x) ≡ 0
  empty-inputs-beget-empty-outputs List.[] refl = refl
\end{code}

\begin{code}
  nrp-of-concatenated-lists :
    (x y : List.List A) ->
    nrp (x List.++ y) ≡ {!!}
  nrp-of-concatenated-lists = {!!}
\end{code}

\subsubsection{The Appending Proof}
\AgdaFunction{new-values-are-appended} indicates that if \AgdaBound{x} does not appear in \AgdaBound{xs}, then \AgdaFunction{nrp} \AgdaSymbol(\AgdaBound{xs} \AgdaOperator{\AgdaFunction{List.++}} \AgdaOperator{\AgdaFunction{List.[}} \AgdaBound{x} \AgdaOperator{\AgdaFunction{]}} is structurally identical to \AgdaFunction{nrp} \AgdaBound{xs} \AgdaOperator{\AgdaFunction{List.++}} \AgdaOperator{\AgdaFunction{List.[}} \AgdaBound{x} \AgdaOperator{\AgdaFunction{]}}.  More intuitively, one can say that new values which are appended to the input of \AgdaFunction{nrp} are \emph{also} appended to the output of \AgdaFunction{nrp}.

\begin{code}
  new-values-are-appended :
    (x : A) ->
    (xs : List.List A) ->
    x ∉ xs ->
    nrp (xs List.++ List.[ x ]) ≡ nrp xs List.++ List.[ x ]
  new-values-are-appended x List.[] notElement = refl
  new-values-are-appended x (xs1 List.∷ xs) notElement = {!!}
\end{code}

\chapter{The Computer Algebra System Types}

\section{The Type of Mostly-Unverified Computer Algebra Systems}
Fundamentally, a computer algebra system for an expression type \(\epsilon\) can be thought of as being a combination of the following:

\begin{itemize}
  \item an algebraic equality type,
  \item an algebraic \emph{in}equality type,
  \item a single-step evaluation function which is capable of describing failures,
  \item a proof of decidable structural equality of \(\epsilon\) values,
  \item a function which determines certain algebraic equality on non-bogus \(\epsilon\) values,
  \item a function which converts natural number values into \(\epsilon\) values,
  \item a function which converts the name of a variable into an \(\epsilon\) variable value,
  \item a function which converts the two input expressions into a representation of the sum of the input expressions,
  \item a function which converts the two input expressions into a representation of the quotient of the input expressions,
  \item a function which converts the two input expressions \(a\) and \(b\) into \(a^b\),
  \item a limit function,
  \item a function which converts the input into the additive inverse of the input,
  \item a lambda expression function,
  \item a variable-is-used type,
  \item a proof which indicates that for any two natural numbers \(n_1\) and \(n_2\), if \(n_1 \neq n_2\), then the representation of \(n_1\) is not equal to the representation of \(n_2\),
  \item a proof which indicates that variables of different names are not equivalent,
  \item a function which performs the maximum number of evaluation steps on the input,
  \item a function which displays all evaluation steps which are used on a given input, and
  \item some other functions which are really only terribly useful for verification.
\end{itemize}

\AgdaDatatype{CAS} is the type of such computer algebra systems.

\subsection{The Algebraic Equality Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}≈\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is shown to be algebraically equal to \AgdaBound{y}.

\subsection{The Algebraic \emph{In}equality Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}≉\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is algebraically \emph{un}equal to \AgdaBound{y}, i.e., no \AgdaBound{i} exists such that \AgdaBound{x} is shown to be algebraically equal to \AgdaBound{y} within \AgdaBound{i} iterations.

\subsection{The Single-Step Evaluation Function}
If such a step is possible, then the single-step evaluation function, which is represented in \AgdaDatatype{CAS} records as some \AgdaField{exceptionallyEvaluate} field, performs a single evaluation step on the input.  If no such step is possible, but the input is not bogus, then the output just contains the input.  If the input is bogus, then the output contains a description of the bogusness.

For the purposes of this document, an ``evaluation step'' is the application of a basic operation, e.g., addition or commuting the arguments of a function.  More formally, one can say that an evaluation step is the application of an operation which cannot be further simplified or decomposed into simpler operations.

\subsection{The Proof of Structural Equality}
This one, which is represented via the \AgdaField{structuralEquality} field, should be simple enough for anyone who is familiar with \AgdaFunction{DecidableEquality}.

\subsection{The Semi-Decidable Algebraic Equality Function}
\AgdaField{CAS.definitelyEquals} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is some value \AgdaInductiveConstructor{inj₂} \AgdaSymbol(\AgdaInductiveConstructor{just} \AgdaBound{equality}\AgdaSymbol) if and only if the \AgdaField{CAS.definitelyEquals} function finds an appropriate value.  The \AgdaField{CAS.definitelyEquals} value is \AgdaInductiveConstructor{inj₂} \AgdaInductiveConstructor{nothing} if and only if the function cannot discover an appropriate proof of equality.  The function encounters an exceptional situation if and only if the \AgdaField{CAS.definitelyEquals} is \AgdaInductiveConstructor{inj₁} \AgdaBound{e}, where \AgdaBound{e} is a description of the exception.

\subsection{The Natural-to-ε Function}
The author thinks that any computer algebra system which is worthy of being given the time of day can represent natural numbers --- after all, the time of day can be represented \emph{as} a natural number!  Anyway, \AgdaField{fromℕ} indicates that a mapping from the natural numbers to the expression type of the given computer algebra system exists.

\subsection{The Variable Function}
Does a computer algebra system which lacks support for variables even qualify as being a computer algebra system?  The author is doubtful.  Anyway, \AgdaField{CAS.variableNamed} \AgdaBound{c} \AgdaBound{name} is \AgdaBound{c}'s representation of the variable whose name is \AgdaBound{name}.

\subsection{The Sum Function}
Any half-decent CAS is capable of representing the unevaluated sum of two expressions.  Accordingly, \AgdaField{sumRepresentation} values are unevaluated sum functions.  More formally, \AgdaField{CAS.sumRepresentation} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated sum of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Sum Function}
Any half-decent CAS can represent the difference of two given expressions, too.  Accordingly, \AgdaField{differenceRepresentation} values are unevaluated differences.  More formally, \AgdaField{CAS.differenceRepresentation} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated difference of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Product Function}
A decent CAS can represent the unevaluated product of two expressions.  Accordingly, \AgdaField{productRepresentation} values represent unevaluated products.  More formally, one can say that \AgdaField{CAS.productRepresentation} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated product of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Quotient Function}
Any \emph{good} CAS can \emph{also} represent the unevaluated quotient of two expressions.  Accordingly, \AgdaField{quotientRepresentation} values are unevaluated quotient functions.  More formally, \AgdaField{CAS.quotientRepresentation} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated quotient of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Exponent Function}
The author is tired of the boilerplate nonsense.  \AgdaField{CAS.quotientRepresentation} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of \AgdaBound{x} to the power of \AgdaBound{y}.

\subsection{The Additive Inverse Function}
\AgdaField{CAS.negationRepresentation} \AgdaBound{c} \AgdaBound{x} is the additive inverse of \AgdaBound{x}.

\subsection{The Simple Limit Function}
\AgdaField{CAS.simpleLimitRepresentation} \AgdaBound{c} \AgdaBound{x} \AgdaBound{c} \AgdaBound{e} is \AgdaBound{c}'s representation of \(\lim_{\AgdaBound{c} \rightarrow \AgdaBound{x}} \textrm{E}\), where ``\(\textrm{E}\)'' denotes the expanded version of the \AgdaBound{e} expression.  % The "E" is a stand-in for capital epsilon.

\subsection{The Variable Containment Type}
The variable whose name is \AgdaBound{name} is free in \AgdaBound{e} with regard to \AgdaBound{c} if and only if a value of type \AgdaFunction{CAS.IsNameOfVariableIn} \AgdaBound{c} \AgdaBound{name} \AgdaBound{e}.

\subsection{The Lambda Expression Function}
\AgdaField{CAS.lambdaRepresentation} \AgdaBound{c} \AgdaBound{name} \AgdaBound{expression} \AgdaBound{value} represents the application to \AgdaBound{value} of the lambda expression whose bound variable's name is \AgdaBound{name} and whose expression is \AgdaBound{expression}.  Equivalently, one can say that \AgdaField{CAS.lambdaRepresentation} \AgdaBound{c} \AgdaBound{name} \AgdaBound{M} \AgdaBound{value} is equivalent to \(\left(\lambda\ \AgdaBound{name} \rightarrow \AgdaBound{M}\right)\ \AgdaBound{value}\).

\subsection{The Natural Number Proofs}
In addition to the basic mapping, proofs of the following attributes should exist:

\begin{itemize}
  \item Any two natural numbers differ only if the CAS's representations of the numbers differ.
\end{itemize}

\subsection{The Proof which Indicates that Values of Different Names are Decidedly Not Equivalent}
Operations on variables are only sensible if confusing variables is forbidden, i.e., variables of different names are represented differently.  Accordingly, \AgdaField{CAS.differently-named-variables-are-different} \AgdaBound{c} indicates that within \AgdaBound{c}, given any two variables \(x\) and \(y\), if the name of \(x\) differs from the name of \(y\), then \AgdaBound{c}'s representations of \(x\) and \(y\) differ.

\subsection{The Tracing Recursive Evaluation Function}
A compliant CAS also has a function which performs the specified number of non-repeating simplification steps on the input, returning a list all steps which were taken to get the output, regardless of whether or not the output is an exception.  In \AgdaDatatype{CAS} records, this function is represented through \AgdaField{traceEvaluate}.

\subsection{The Non-Tracing Maximum Evaluation Function}
A compliant CAS also has a function which performs the specified number of non-repeating simplification steps on the input but just returns the resulting exception or expression.  In \AgdaDatatype{CAS} records, this function is represented through \AgdaField{rEvaluate}.

\subsection{The Iteration Equality Function}
A value of type \AgdaField{CAS.equal-at-iteration} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e1} \AgdaBound{e2} exists if and only if \AgdaField{CAS.definitelyEquals} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e1} \AgdaBound{e2} indicates that \AgdaBound{e1} is algebraically equal to \AgdaBound{e2}.  This function mostly exists to eliminate repetition.

\subsection{The Generic Iteration Equality Function}
A value of type \AgdaField{CAS.equal-at-some-iteration} \AgdaBound{c} \AgdaBound{e1} \AgdaBound{e2} exists if and only if \AgdaField{CAS.definitelyEquals} \AgdaBound{c} can determine that \AgdaBound{e1} is algebraically equal to \AgdaBound{e2} at some iteration.  Again, this function is really just good for reducing nasty redundancy.

\subsection{The Equality Step Function}
\AgdaField{CAS.equality-at-n-implies-equality-at-n+1} proves that two expressions are definitely equal at a given iteration only if these same expressions are also definitely equal at the following iteration.

\subsection{The Iteration Bogosity Function}
A value of type \AgdaField{CAS.bogus-at-iteration} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e} exists if and only if \AgdaField{CAS.rEvaluate} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e} is an \AgdaInductiveConstructor{inj₂} value.

\subsection{The Generic Iteration Bogosity Function}
A value of type \AgdaField{CAS.bogus-at-some-iteration} \AgdaBound{c} \AgdaBound{e} exists if and only if \AgdaField{CAS.rEvaluate} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e} is an \AgdaInductiveConstructor{inj₂} value for some \AgdaBound{iterations}.

\subsection{The Bogosity Step Function}
\AgdaField{CAS.bogosity-at-n-implies-bogosity-at-n+1} proves that a given expression is bogus at some iteration only if the same expression is bogus at the following iteration.

\subsection{The Non-Bogus Type}
This type, in addition to not being bogus, is used to indicate that the relevant expression is not bogus.  More formally, a value of type \AgdaField{CAS.IsNotBogus} \AgdaBound{c} \AgdaBound{e} exists if and only if \AgdaBound{e} is bogus with regard to \AgdaField{CAS.rEvaluate} \AgdaBound{c} at no iteration, i.e., \AgdaField{CAS.rEvaluate} \AgdaBound{c} \AgdaBound{n} \AgdaBound{e} is non-bogus for all \AgdaBound{n}.

\subsection{The Definition Proper}

\begin{code}
record CAS {a : Level} (ε : Set a) : Set (Level.suc Level.zero Level.⊔ a) where
  field
    exceptionallyEvaluate : ε -> Exceptional ε
    structuralEquality : DecidableEquality ε
    fromℕ : ℕ -> ε
    variableNamed : String -> ε
    sumRepresentation
     differenceRepresentation
     productRepresentation
     quotientRepresentation
     exponentRepresentation : ε -> ε -> ε
    negationRepresentation : ε -> ε
    limitRepresentation : String -> ε -> ε -> ε
    IsNameOfVariableIn : String -> ε -> Set
    lambdaRepresentation : String -> ε -> ε -> ε
    different-if-nats-are-different :
      {n1 n2 : ℕ} -> n1 ≢ n2 -> fromℕ n1 ≢ fromℕ n2
    differently-named-variables-are-different :
      (name1 name2 : String) ->
      name1 ≢ name2 ->
      variableNamed name1 ≢ variableNamed name2

  rEvaluate : ℕ -> ε -> Exceptional ε
  rEvaluate 0 e = inj₂ e
  rEvaluate (ℕ.suc n) e = [_,_] inj₁ exceptionallyEvaluate (rEvaluate n e)

  traceEvaluate : ℕ -> ε -> List.List (Exceptional ε)
  traceEvaluate n e =
    nonRepeatingPortion decFun (List.map (flip rEvaluate e) (List.upTo (ℕ.suc n)))
      where decFun = Data.Sum.Properties.≡-dec Data.String._≟_ structuralEquality

  module EqualityVerificationParts where
    inj2s : List.List (Exceptional ε) -> List.List ε
    inj2s (inj₂ e List.∷ es) = e List.∷ inj2s es
    inj2s (inj₁ e List.∷ es) = inj2s es
    inj2s List.[] = List.[]

    evaluationPairs : ℕ -> ε -> ε -> List.List (ε × ε)
    evaluationPairs i x y = (List.cartesianProduct on inj2s) (trace x) (trace y)
      where
      trace = traceEvaluate i

    module ProofsOfCorrectness
      (i : ℕ)
      (e1 e2 : ε) where

      evp = evaluationPairs i e1 e2

      length-of-pairlist-is-suc : Σ ℕ (\ n -> ℕ.suc n ≡ List.length evp)
      length-of-pairlist-is-suc = {!!}

      first-pair-index = Data.Fin.cast (proj₂ length-of-pairlist-is-suc) Fin.zero

      inputs-are-first-evaluation-pair :
        (e1 , e2) ≡ List.lookup evp first-pair-index
      inputs-are-first-evaluation-pair = {!!}

  open EqualityVerificationParts

  module InternalEqualityFunctions where
    _≡₂_ : Exceptional ε -> Exceptional ε -> Set a
    (inj₂ x) ≡₂ (inj₂ y) = x ≡ y
    x ≡₂ y = ⊥

    _≟₂_ : (x y : Exceptional ε) -> Dec (x ≡₂ y)
    (inj₂ x) ≟₂ (inj₂ y) = structuralEquality x y
    (inj₁ x) ≟₂ (inj₂ y) = no (λ ())
    (inj₁ x) ≟₂ (inj₁ y) = no (λ ())
    (inj₂ x) ≟₂ (inj₁ y) = no (λ ())

  open InternalEqualityFunctions

  _≈_ : ε -> ε -> Set a
  _≈_ x y = Σ (ℕ × ℕ) (λ (nx , ny) -> rEvaluate nx x ≡₂ rEvaluate ny y)

  _≉_ : ε -> ε -> Set a
  x ≉ y = (iterations : ℕ) -> ¬ _≈_ x y

  module DefinitelyEqualsInternal where
    checkEqualityAtIteration :
      (ix iy : ℕ) ->
      (x y : ε) ->
      Maybe (x ≈ y)
    checkEqualityAtIteration ix iy x y =
      Data.Maybe.map ((ix , iy) ,_) (decToMaybe (rEvaluate ix x ≟₂ rEvaluate iy y))

    firstInj1 : List.List (Exceptional ε) -> Maybe String
    firstInj1 List.[] = nothing
    firstInj1 (inj₂ e List.∷ es) = firstInj1 es
    firstInj1 (inj₁ e List.∷ es) = just e

    with-justness : {iterations : ℕ} ->
                    {x y : ε} ->
                    Maybe String ->
                    Exceptional (Maybe (x ≈ y))
    with-justness (just e) = inj₁ e
    with-justness {iters} {x} {y} nothing =
      inj₂ (sequenceMaybe (List.head (List.map check iterList)))
      where
      check = λ (nx , ny) -> checkEqualityAtIteration nx ny x y
      iterList = (λ l -> List.cartesianProduct l l) (List.upTo (ℕ.suc iters))

  definitelyEquals : (iterations : ℕ) ->
                     (x y : ε) ->
                     Exceptional (Maybe (x ≈ y))
  definitelyEquals iterations x y =
    with-justness {iterations} {x} {y} (firstInj1 (trace x List.++ trace y))
    where
    open DefinitelyEqualsInternal
    trace = traceEvaluate iterations

  equal-at-iteration : ℕ -> (e1 e2 : ε) -> Set a
  equal-at-iteration iterations e1 e2 =
    Σ (e1 ≈ e2)
      (\ i -> inj₂ (just i) ≡ definitelyEquals iterations e1 e2)

  equal-at-some-iteration : (e1 e2 : ε) -> Set a
  equal-at-some-iteration e1 e2 = Σ ℕ (\ n -> equal-at-iteration n e1 e2)

  equality-at-n-implies-equality-at-n+1 :
    (iterations : ℕ) ->
    (e1 e2 : ε) ->
    equal-at-iteration iterations e1 e2 ->
    equal-at-iteration (iterations + 1) e1 e2
  equality-at-n-implies-equality-at-n+1 = {!!}

  bogus-at-iteration : ℕ -> ε -> Set a
  bogus-at-iteration n e = Σ String (\ ex -> inj₁ ex ≡ rEvaluate n e)

  bogus-at-some-iteration : ε -> Set a
  bogus-at-some-iteration = Σ ℕ ∘ flip bogus-at-iteration

  bogosity-at-n-implies-bogosity-at-n+1 :
    (iterations : ℕ) ->
    (e : ε) ->
    bogus-at-iteration iterations e ->
    bogus-at-iteration (iterations + 1) e
  bogosity-at-n-implies-bogosity-at-n+1 iter e (exc , bogosity) =
    exc , trans bogosity (sym eEquality)
    where
    eEquality : rEvaluate (iter + 1) e ≡ rEvaluate iter e
    eEquality = begin
      rEvaluate (iter + 1) e
        ≡⟨ cong (flip rEvaluate e) (Data.Nat.Properties.+-comm iter 1) ⟩
      [_,_]′ inj₁ exceptionallyEvaluate (rEvaluate iter e)
        ≡⟨ cong ([_,_] inj₁ exceptionallyEvaluate) (sym bogosity) ⟩
      inj₁ exc
        ≡⟨ bogosity ⟩
      rEvaluate iter e ∎

  IsNotBogus : ε -> Set a
  IsNotBogus e = (n : ℕ) -> Is-just (isInj₂ (rEvaluate n e))
\end{code}

\section{The Type of Verified Computer Algebra Systems}
For the purposes of this document, a verified computer algebra system is the combination of a \AgdaRecord{CAS} computer algebra system \(c\) \emph{and} some guarantees about \(c\).  The non-\AgdaRecord{CAS} parts of the combination are as follows:

\begin{itemize}
 \item a proof which indicates that the algebraic equality relation is an equaivalence relation,
 \item a proof which indicates that two values are structurally equivalent only if these same values are also algebraically equal,
 \item a proof which indicates that variables of different names are not definitely equal,
 \item a proof which indicates that two variables which have the same name are algebraically equal,
 \item a proof which indicates that for any two integers \(n_1\) and \(n_2\), the sum of the representation of \(n_1\) and \(n_2\) is the representation of \(n_1 + n_2\),
 \item a proof which indicates that the product of any non-bogus element \(e\) of type \AgdaBound{ε} and one is \(e\),
 \item a proof of commutativity of addition,
 \item a proof of commutativity of multiplication,
 \item a proof of the inverse relationship between multiplication and division,
 \item a proof which indicates that \(\lim_{x \rightarrow n} e\) is algebraically equal to \(n\) if \(x\) is not referenced in \(e\),
 \item a proof of the algebraic equality between \(\left(\lambda\ x \rightarrow x\right)\ e\) and \(e\), and
 \item a proof which indicates that \(\left(\lambda\ x \rightarrow y\right)\ e\) is algebraically equal to \(y\) if \(x\) is not referenced in \(y\).
\end{itemize}

\subsection{The Proof of the Equivalence Nature of the Algebraic Equality Relation}
A good CAS represents the complex numbers, whose equality relation is an equivalence relation.  Accordingly, a verified CAS's algebraic equality relation should be an equivalence relation.  \AgdaField{equality-is-equivance} values indicate that the algebraic equality relations actually are equivalence relations.

\subsection{The Structural-Equivalence-to-Algebraic-Equality Function}
Also, in a good CAS, two expressions \(e_1\) and \(e_2\) are represented in the same way only if \(e_1\) is algebraically equal to \(e_2\).  This fact is represented through the use of \AgdaField{structural-equality-implies-definite-equality}.

\subsection{The Proof which Indicates that Values of Different Names are Not ``Definitely Equal''}
Any two given variables are not necessarily equal.  Accordingly, \AgdaField{VCAS.differently-named-variables-are-not-definitely-equal} \AgdaBound{c} indicates that within the \AgdaBound{c} CAS, given any two \AgdaBound{c} variables \(x\) and \(y\), if the name of \(x\) differs from the name of \(y\), then \(x\) is not definitely equal to \(y\).

\subsection{The Proof which Indicates that Variables of Identical Names are Algebraically Equal}
Also, options on variables are only sensible if for all variables \(x\) and \(y\), if the name of \(x\) is also the name of \(y\), then \(x\) is algebraically equal to \(y\).  Accordingly, \AgdaField{VCAS.identically-named-variables-are-equal} \AgdaBound{c} indicates that for any \AgdaBound{c}-CAS variables \(x\) and \(y\), if the name of \(x\) is identical to the name of \(y\), then \AgdaBound{c} can determine that \(x\) is algebraically equal to \(y\).

\subsection{The Natural Number Sum Field}
Another aspect of a good computer algebra system is the correct calculation of sums of natural numbers.  Intuition dictates that in a good computer algebra system, the sum of two natural numbers should be the sum of the same two natural numbers.  However, as indicated by \AgdaField{CAS.fromℕ}, many computer algebra systems do not just work with natural numbers; accordingly, natural number arithmetic may accidentally be implemented incorrectly.  To prevent such incorrect implementations, correct calculation of natural number sums is ensured through \AgdaField{sum-of-nats-is-nat-sum} values, which are proofs which indicate that the corresponding computer algebra systems' natural number addition functions are defined correctly.

\subsection{The Non-Bogus Sum Field}
\AgdaField{VCAS.sum-is-not-bogus} indicates that for any given non-bogus values \AgdaBound{e1} and \AgdaBound{e2}, the sum of \AgdaBound{e1} and \AgdaBound{e2} is not bogus.

\subsection{The 1-Product Field}
\AgdaField{VCAS.product-of-e-and-1-is-e} \AgdaBound{c} indicates that for any non-bogus value \(e\) of the expression type for \AgdaBound{c}, the product of \(e\) and one is equal to \(e\).

\subsection{The Bogus Division Field}
That the quotient of any given number and zero is bogus, i.e., undefined, is well-known.  This fact --- the bogusness, not being well-known --- is represented through \AgdaField{VCAS.division-by-zero-is-bogus}.

\subsection{The Proof of Commutativity of Addition}
\AgdaField{VCAS.sum-is-commutative} indicates that addition is commutative in the relvant CAS.  More formally, \AgdaField{VCAS.sum-is-commutative} \AgdaBound{c} indicates that for any appropriate expression values \AgdaBound{e1} and \AgdaBound{e2}, some \AgdaBound{n} exists such that there exists a value of type \AgdaBound{CAS.equal-at-iteration} \AgdaBound{c2} \AgdaSymbol(\AgdaField{CAS.sumRepresentation} \AgdaBound{c2} \AgdaBound{e1} \AgdaBound{e2}\AgdaSymbol) \AgdaSymbol(\AgdaField{CAS.sumRepresentation} \AgdaBound{c2} \AgdaBound{e2} \AgdaBound{e1}\AgdaSymbol), where \AgdaBound{c2} is the CAS record which is verified by \AgdaBound{c}.

\subsection{The Proof of Commutativity of Multiplication}
\AgdaField{VCAS.product-is-commutative} indicates that multiplication is commutative in the relvant CAS.  More formally, \AgdaField{VCAS.product-is-commutative} \AgdaBound{c} indicates that for any appropriate expression values \AgdaBound{e1} and \AgdaBound{e2}, some \AgdaBound{n} exists such that a value of type \AgdaBound{CAS.equal-at-iteration} \AgdaBound{c2} \AgdaSymbol(\AgdaField{CAS.productRepresentation} \AgdaBound{c2} \AgdaBound{e1} \AgdaBound{e2}\AgdaSymbol) \AgdaSymbol(\AgdaField{CAS.productRepresentation} \AgdaBound{c2} \AgdaBound{e2} \AgdaBound{e1}\AgdaSymbol), where \AgdaBound{c2} is the CAS record which is verified by \AgdaBound{c}.

\subsection{The Proof of the Inverse Relationship between Multiplication and Division}
\AgdaField{VCAS.product-of-quotient-is-same} indicates that for the appropriate CAS, multiplication is the inverse of division.  More formally, \AgdaField{product-of-quotient-is-same} \AgdaBound{c} indicates that for all appropriate expression values \AgdaBound{e1} and \AgdaBound{e2}, \AgdaBound{e2} is equal to the \AgdaBound{c} CAS product of \AgdaBound{e1} and the \AgdaBound{c} CAS quotient of \AgdaBound{e2} and \AgdaBound{e1}.

\subsection{The Proof of the Futility of Taking the Limit of an Expression which does Not Use the Named Variable}
\AgdaField{limit-of-unrelated-value-is-unrelated-value} \AgdaBound{v} indicates that in the \AgdaBound{v} CAS, if \(x\) is not used in \(e\), then \(\lim_{x \rightarrow b} e\) is equivalent to \(e\) for all \(b\), \(e\), and \(x\).

\subsection{The Proof which Indicates that Simple Lambda Substitution Works}
\AgdaField{VCAS.simple-lambda-substitution-works} \AgdaBound{v} indicates that, at some iteration, the \AgdaBound{v} CAS can determine that the \AgdaBound{v} CAS's representation of \(\left(\lambda\ v \rightarrow v\right) e\) is algebrically equal to the \AgdaBound{v} CAS's representation of \(e\).

\subsection{The Proof of the Futility of Applying a Lambda Expression whose Bound Variable is Unused}
For all relevant \(v\), \(M\), and \(e\), if \(v\) is not referenced in \(M\), then \(\left(\lambda\ v \rightarrow M\right)\ e = M\).  The preceding fact is encoded through \AgdaField{VCAS.unapplicable-lambda-returns-lambda-body}.

\subsection{The Definition Proper}

\begin{code}
record VCAS {a : Level} {ε : Set a} (Cas : CAS ε) : Set a where
  open CAS Cas
  field
    equality-is-equivalence : IsEquivalence _≈_
    structural-equality-implies-definite-equality :
      (e1 e2 : ε) ->
      e1 ≡ e2 ->
      (iterations : ℕ) ->
      (isInj2 : Is-just (isInj₂ (definitelyEquals iterations e1 e2))) ->
      Is-just (to-witness isInj2)
    differently-named-variables-are-not-definitely-equal :
      (name1 name2 : String) ->
      name1 ≢ name2 ->
      (iterations : ℕ) ->
      _≡_ (inj₂ nothing)
          (definitelyEquals iterations
                            (variableNamed name1)
                            (variableNamed name2))
    identically-named-variables-are-equal :
      (name1 name2 : String) ->
      name1 ≡ name2 ->
      equal-at-some-iteration (variableNamed name1) (variableNamed name2)
    sum-of-nats-is-nat-sum :
      (n1 n2 iterations : ℕ) ->
      rEvaluate iterations (sumRepresentation (fromℕ n1) (fromℕ n2)) ≡
        inj₂ (fromℕ (n1 + n2))
    sum-is-not-bogus :
      (e1 e2 : ε) ->
      IsNotBogus e1 ->
      IsNotBogus e2 ->
      IsNotBogus (sumRepresentation e1 e2)
    product-of-e-and-1-is-e :
      (e : ε) ->
      IsNotBogus e ->
      equal-at-some-iteration (productRepresentation e (fromℕ 1)) e
    difference-is-negated-sum :
      (e1 e2 : ε) ->
      equal-at-some-iteration (differenceRepresentation e1 e2)
                              (sumRepresentation e1 (negationRepresentation e2))
    inverse-of-inverse-is-original :
      (e : ε) ->
      equal-at-some-iteration e (negationRepresentation (negationRepresentation e))
    division-by-zero-is-bogus :
      (e1 e2 : ε) ->
      (equal-at-some-iteration (fromℕ 0) e2) ->
      bogus-at-some-iteration (quotientRepresentation e1 e2)
    sum-is-commutative :
      (e1 e2 : ε) ->
      IsNotBogus e1 ->
      IsNotBogus e2 ->
      equal-at-some-iteration (sumRepresentation e1 e2)
                              (sumRepresentation e2 e1)
    product-is-commutative :
      (e1 e2 : ε) ->
      IsNotBogus e1 ->
      IsNotBogus e2 ->
      equal-at-some-iteration (productRepresentation e1 e2)
                              (productRepresentation e2 e1)
    product-of-quotient-is-same :
      (e1 e2 : ε) ->
      IsNotBogus (quotientRepresentation e2 e1) ->
      equal-at-some-iteration e2 (productRepresentation e1 (quotientRepresentation e2 e1))
    limit-of-unrelated-value-is-unrelated-value :
      (name : String) ->
      (e bound : ε) ->
      ¬ IsNameOfVariableIn name e ->
      equal-at-some-iteration e (limitRepresentation name bound e)
    simple-lambda-substitution-works :
      (name : String) ->
      (e : ε) ->
      equal-at-some-iteration e (lambdaRepresentation name (variableNamed name) e)
    nonapplicable-lambda-returns-lambda-body :
      (name : String) ->
      (e1 e2 : ε) ->
      ¬ IsNameOfVariableIn name e2 ->
      equal-at-some-iteration e2 (lambdaRepresentation name e2 e1)
\end{code}

\chapter{The Core Datatypes and Associated Functions}

\section{Type Declarations}

\subsection{\AgdaDatatype{F}'s Type and Summary}
Values of type \AgdaDatatype{F} represent functions.

\begin{code}
data F : Set
\end{code}

\subsection{\AgdaDatatype{ε}'s Type and Summary}
Values of \AgdaDatatype{ε} represent expressions.

\begin{code}
data ε : Set
\end{code}

\section{The Actual Definitions\ldots and Supporting Functions}

\subsection{Completing \AgdaDatatype{F}'s Definition}
The following statements hold:

\begin{itemize}
  \item \AgdaInductiveConstructor{Abs} represents the absolute value function.
  \item \AgdaInductiveConstructor{Negate} represents the negation function.
  \item \AgdaInductiveConstructor{Sum} represents the sum function.
  \item \AgdaInductiveConstructor{Product} represents the product, i.e., multiplication, function.
  \item \AgdaInductiveConstructor{Exponent} represents the exponentiation function.
  \item \AgdaInductiveConstructor{Limit} represents the limit function, i.e., \AgdaInductiveConstructor{Ap} \AgdaSymbol(\AgdaInductiveConstructor{Limit} \AgdaBound{name}\AgdaSymbol) \AgdaSymbol(\AgdaBound{bound} \AgdaOperator{\AgdaInductiveConstructor{∷}} \AgdaBound{expression} \AgdaInductiveConstructor{List.[]}\AgdaSymbol) represents the limit of \AgdaBound{expression} as \AgdaBound{name} approaches \AgdaBound{bound}.
  \item \AgdaInductiveConstructor{Lambda} \AgdaBound{names} \AgdaBound{body} represents a lambda function whose bound variables are listed in \AgdaBound{names} and whose body is \AgdaBound{body}.  Alternatively, if \AgdaBound{names} consists of values \texttt{n1}, \texttt{n2}, \texttt{n3}, and so on, one could say that \AgdaInductiveConstructor{Lambda} \AgdaBound{names} \AgdaBound{body} is equivalent to Agda's \texttt{\textbackslash\ n1 n2 n3 ... -> body2}, where \texttt{body2} is an expansion of \AgdaBound{body}.
\end{itemize}

\begin{code}
data F where
  Abs
   Negate
   Sum
   Product
   Exponent : F
  Lambda : List.List String -> ε -> F
  Limit : String -> F
\end{code}

\subsection{The Arity-Determining Function}
\AgdaFunction{arity} \AgdaBound{f} is the arity of the \AgdaBound{f} function.

\begin{code}
arity : F -> ℕ
arity Abs = 1
arity Negate = 1
arity Sum = 2
arity Product = 2
arity Exponent = 2
arity (Lambda names body) = List.length names
arity (Limit name) = 2
\end{code}

\subsection{The Commutativity-Determining Function}
\AgdaFunction{isCommutative} \AgdaBound{f} \AgdaBound{a} is \AgdaInductiveConstructor{true} if and only if \AgdaBound{f} represents a commutative function.

\begin{code}
isCommutative : (f : F) -> arity f ≡ 2 -> Bool
isCommutative Sum refl = true
isCommutative Product refl = true
isCommutative Exponent refl = false
isCommutative (Lambda names body) equality = false
isCommutative (Limit name) equality = false
\end{code}

\subsection{Completing \AgdaDatatype{ε}'s Definition}
The following statements hold:

\begin{itemize}
  \item \AgdaInductiveConstructor{Infinity} represents infinity.
  \item \AgdaInductiveConstructor{Variable} \AgdaBound{n} represents a variable whose name is \AgdaBound{n}.
  \item \AgdaInductiveConstructor{NumberRat} \AgdaBound{q} represents \AgdaBound{q}.
  \item \AgdaInductiveConstructor{Ap} \AgdaBound{f} \AgdaBound {e} represents the result of applying \AgdaBound{f} to \AgdaBound{e}.
\end{itemize}

\begin{code}
data ε where
  Infinity : ε
  Variable : String -> ε
  NumberRat : ℚ -> ε
  Ap : (f : F) -> Vec ε (arity f) -> ε
\end{code}

\section{Additional Functions}

\subsection{The Natural-Number-to-Expression Function}
\AgdaFunction{NumberNat} \AgdaBound{n} is Casanova Fly's representation of \AgdaBound{n}.

\begin{code}
NumberNat : ℕ -> ε
NumberNat n = NumberRat (ℚ.mkℚ (Data.Integer.+ n)
                               0
                               (Coprimality.sym (Coprimality.1-coprimeTo _)))
\end{code}
\subsection{Decidable Structural Equality on \AgdaDatatype{F}}
This function is used to determine whether or not the input arguments are structurally equivalent.

\begin{code}
structuralEqualityOnF : DecidableEquality F
structuralEqualityOnF = {!!}
\end{code}

\subsection{Decidable Structural Equality on \AgdaDatatype{ε}}
This function is used to determine whether or not the input arguments are structurally equivalent.

\begin{code}
{-# TERMINATING #-}
structuralEqualityOnε : DecidableEquality ε
structuralEqualityOnε = s
  where
  s : DecidableEquality ε
  s Infinity Infinity = yes refl
  s Infinity (Variable v) = no λ ()
  s Infinity (NumberRat r) = no λ ()
  s Infinity (Ap f x) = no λ ()
  s (Variable v) Infinity = no λ ()
  s (Variable v1) (Variable v2) with v1 Data.String.≟ v2
  ... | yes namesAreEqual = yes (cong Variable namesAreEqual)
  ... | no differentNames = no (differentNames ∘ same-variable-implies-same-name)
    where
    same-variable-implies-same-name :
      {n1 n2 : String} ->
      Variable n1 ≡ Variable n2 ->
      n1 ≡ n2
    same-variable-implies-same-name refl = refl
  s (Variable v) (NumberRat r) = no λ ()
  s (Variable v) (Ap f x) = no λ ()
  s (NumberRat r) Infinity = no λ ()
  s (NumberRat r) (Variable v) = no λ ()
  s (NumberRat r1) (NumberRat r2) with r1 ℚ.≟ r2
  ... | yes ratsAreEqual = yes (cong NumberRat ratsAreEqual)
  ... | no ratsAreDifferent = no (ratsAreDifferent ∘ same-numberRat-implies-same-rat)
    where
    same-numberRat-implies-same-rat :
      {q1 q2 : ℚ} ->
      NumberRat q1 ≡ NumberRat q2 ->
      q1 ≡ q2
    same-numberRat-implies-same-rat refl = refl
  s (NumberRat r) (Ap f x) = no λ ()
  s (Ap f x) Infinity = no λ ()
  s (Ap f x) (Variable v) = no λ ()
  s (Ap f x) (NumberRat r) = no λ ()
  s (Ap f1 x1) (Ap f2 x2) with structuralEqualityOnF f2 f1
  ... | no differentF = no (differentF ∘ sym ∘ same-only-with-same-function)
    where
    same-only-with-same-function :
      {f1 f2 : F} ->
      {x1 : Vec ε (arity f1)} ->
      {x2 : Vec ε (arity f2)} ->
      Ap f1 x1 ≡ Ap f2 x2 ->
      f1 ≡ f2
    same-only-with-same-function refl = refl
  ... | yes sameF with VecProp.≡-dec structuralEqualityOnε x1 (Data.Vec.cast (cong arity sameF) x2)
  ... | yes sameX = yes (combine sameF sameX)
    where
    combine :
      {f1 f2 : F} ->
      {x1 : Vec ε (arity f1)} ->
      {x2 : Vec ε (arity f2)} ->
      (sameF : f2 ≡ f1) ->
      x1 ≡ Data.Vec.cast (cong arity sameF) x2 ->
      Ap f1 x1 ≡ Ap f2 x2
    combine = {!!}
  ... | no differentX = no (differentX ∘ same-only-with-same-x sameF)
    where
    same-only-with-same-x :
      {f1 f2 : F} ->
      {x1 : Vec ε (arity f1)} ->
      {x2 : Vec ε (arity f2)} ->
      (sameF : f2 ≡ f1) ->
      Ap f1 x1 ≡ Ap f2 x2 ->
      x1 ≡ Data.Vec.cast (cong arity sameF) x2
    same-only-with-same-x = {!!}
\end{code}

\subsection{The Function for Commutativity Permutations}
\AgdaFunction{commutativePermutations} \AgdaBound{x} is a list of all expressions which are equivalent to \AgdaBound{x} and are derived from \AgdaBound{x} by commutativity.

\begin{code}
{-# TERMINATING #-}
commutativePermutations : ε -> List.List ε
commutativePermutations (Ap f e) = perms' f (Data.Vec.toList e) {!!}
  where
  c : {a : Level} -> {A B : Set a} -> A ≡ B -> A -> B
  c refl t = t
  combine : (f : F) -> (e : List.List ε) -> arity f ≡ List.length e -> ε
  combine f e lengthMatch = Ap f (c (sym (cong (Vec ε) lengthMatch))
                                    (Data.Vec.fromList e))
  perms' : (f : F) -> (e : List.List ε) -> arity f ≡ List.length e -> List.List ε
  perms' f e@(e1 List.∷ e2 List.∷ List.[]) lengthMatches =
    if isCommutative f lengthMatches then solo else list
    where
    solo = List.[ combine f e lengthMatches ]
    list =
      f' (e2 ∷ [ e1 ]) List.∷ f' (e1 ∷ [ e2 ]) List.∷
      List.map (\ e2 -> f' (e1 ∷ [ e2 ])) (commutativePermutations e2) List.++
      List.map (\ e1 -> f' (e1 ∷ [ e2 ])) (commutativePermutations e1) List.++
      List.concat (List.map (\ (e1 , e2) -> f' (e1 ∷ [ e2 ]) List.∷
                                            List.[ f' (e2 ∷ [ e1 ]) ])
                            (List.zip (commutativePermutations e1)
                                      (commutativePermutations e2)))
      where f' = Ap f ∘ c (sym (cong (Vec ε) lengthMatches))
  perms' f e lengthMatches = List.[ combine f e lengthMatches ]
commutativePermutations o = List.[ o ]
\end{code}

\chapter{Computational Functions and Ilk}

\section{The Variable Substitution Function}
\AgdaFunction{varSubstM} is the multi-variable substitution function.  In \AgdaFunction{varSubstM} \AgdaBound{l} \AgdaBound{e}, any variable in \AgdaBound{e} which also has an entry in \AgdaBound{l} will be replaced by the corresponding \AgdaDatatype{ε} entry in \AgdaBound{l}.  More formally, one can say that \AgdaFunction{varSubstM} \AgdaBound{l} \AgdaBound{e} is a derivative of \AgdaBound{e} such that for any given variable \AgdaBound{x} in \AgdaBound{e}, if a value \AgdaBound{i} exists such that \AgdaField{proj₁} \AgdaSymbol(\AgdaFunction{List.lookup} \AgdaBound{l} \AgdaBound{i}\AgdaSymbol) is \AgdaBound{x}, then \AgdaBound{x} is replaced by \AgdaField{proj₂} \AgdaSymbol(\AgdaFunction{List.lookup} \AgdaBound{l} \AgdaBound{i}\AgdaSymbol).

\begin{code}
{-# TERMINATING #-}
varSubstM : List.List (String × ε) -> ε -> ε
varSubstM List.[] x = x
varSubstM vars o@(NumberRat r) = o
varSubstM vars o@Infinity = o
varSubstM (v List.∷ vs) (Variable sv) =
  if proj₁ v Data.String.== sv
     then proj₂ v
     else varSubstM vs (Variable sv)
varSubstM vars o@(Ap f x) = Ap f (Data.Vec.map (varSubstM vars) x)
\end{code}

\section{The Single-Step Evaluation Function}
\AgdaFunction{exceptionallyEvaluate} \AgdaBound{x} contains the result of performing a single evaluation step on \AgdaBound{x} \emph{or} a value which indicates that \AgdaBound{x} is in some way nonsensical.

\begin{code}
{-# TERMINATING #-}
exceptionallyEvaluate : ε -> Exceptional ε
exceptionallyEvaluate = f
  where
  f : ε -> Exceptional ε
  f o@Infinity = inj₂ o
  f o@(Variable x) = inj₂ o
  f o@(NumberRat r) = inj₂ o
  f (Ap Sum (NumberRat x ∷ NumberRat y ∷ [])) =
    inj₂ (NumberRat (x ℚ.+ y))
  f (Ap Product (NumberRat x ∷ NumberRat y ∷ [])) =
    inj₂ (NumberRat (x ℚ.* y))
  f e@(Ap Exponent (NumberRat x ∷ NumberRat y ∷ [])) =
    if ((ℚ.denominatorℕ x Data.Nat.≡ᵇ 1) ∧
        (ℚ.denominatorℕ y Data.Nat.≡ᵇ 1) ∧
        (Data.Integer.0ℤ Data.Integer.≤ᵇ ℚ.numerator x) ∧
        (Data.Integer.0ℤ Data.Integer.≤ᵇ ℚ.numerator y))
       then if (numerator x Data.Nat.≡ᵇ 0) ∧
               (numerator y Data.Nat.≡ᵇ 0)
             then inj₁ "0^0 is undefined!"
             else inj₂ (NumberNat (numerator x ^ numerator y))
       else inj₂ e
       where numerator = Data.Integer.∣_∣ ∘ ℚ.numerator
  f (Ap (Lambda names body) expressions) =
    inj₂ (varSubstM (List.zip names (Data.Vec.toList expressions)) body)
  f (Ap f x) = [_,_] inj₁ (inj₂ ∘ Ap f) (condense (Data.Vec.map exceptionallyEvaluate x))
    where
    condense : {a : Level} ->
               {A : Set a} ->
               {n : ℕ} ->
               Vec (Exceptional A) n ->
               Exceptional (Vec A n)
    condense [] = inj₂ []
    condense (inj₁ x ∷ xs) = inj₁ x
    condense (inj₂ x ∷ xs) = [_,_] inj₁ (inj₂ ∘ _∷_ x) (condense xs)
\end{code}

\section{The Single-Step Evaluation Function which \emph{also} Supports Commutativity}
\AgdaFunction{commutativeEvaluate} \AgdaBound{e} performs a single evaluation step on the input expression but can also do some fancy stuff when applicable, e.g., switching the arguments of commutative functions.

\begin{code}
commutativeEvaluate : ε -> Exceptional ε
commutativeEvaluate e@(Ap f x) =
  if (e evaluates) then evaluate e else tryFlip (arity f Data.Nat.≟ 2)
  where
  -- evaluate is just an abbreviation.  "exceptionallyEvaluate" is a bit long.
  evaluate = exceptionallyEvaluate
  structuralEquality =
    Data.Sum.Properties.≡-dec Data.String._≟_ structuralEqualityOnε
  _evaluates : ε -> Bool
  _evaluates e = isNo (structuralEquality (inj₂ e) (evaluate e))
  tryFlip : Dec (arity f ≡ 2) -> Exceptional ε
  tryFlip (no arityDiffers) = evaluate e
  tryFlip (yes arityMatches) =
    if isCommutative f arityMatches ∧ (e2 evaluates) then inj₂ e2 else evaluate e
    where e2 = Ap f (reverse x)
commutativeEvaluate e = exceptionallyEvaluate e
\end{code}

\section{The Variable Usedness Type}
\AgdaBound{name} is the name of a variable which is referenced in \AgdaBound{e} if and only if there exists a value of type \AgdaFunction{IsReferencedIn} \AgdaBound{name} \AgdaBound{e}.

\begin{code}
{-# TERMINATING #-}
IsReferencedIn : String -> ε -> Set
IsReferencedIn name Infinity = ⊥
IsReferencedIn name (NumberRat r) = ⊥
IsReferencedIn name (Variable name2) = name ≡ name2
IsReferencedIn name (Ap f list) = AnyVec.Any (IsReferencedIn name) list
\end{code}

\chapter{Proofs of Correctness}

\begin{code}
module CommutativeEvaluationProperties where
  ce = commutativeEvaluate

  0^0-is-nonsense :
    Is-just (isInj₁ (exceptionallyEvaluate
      (Ap Exponent (NumberRat ℚ.0ℚ ∷ [ NumberRat ℚ.0ℚ ]))))
  0^0-is-nonsense = {!!}
\end{code}

\chapter{Wrapping up Everything}

\begin{code}
CasanovaFly-Base : CAS ε
CasanovaFly-Base = record
  { exceptionallyEvaluate = commutativeEvaluate
  ; structuralEquality = structuralEqualityOnε
  ; fromℕ = NumberNat
  ; variableNamed = Variable
  ; sumRepresentation = λ a b -> Ap Sum (a ∷ b ∷ [])
  ; differenceRepresentation = λ x y -> Ap Sum (x ∷ [ Ap Negate [ y ] ])
  ; productRepresentation = λ x y -> Ap Product (x ∷ [ y ])
  ; quotientRepresentation = λ x y ->
     Ap Product (x ∷ [ Ap Exponent (y ∷ [ Ap Negate [ NumberRat ℚ.1ℚ ] ]) ])
  ; exponentRepresentation = λ x y -> Ap Exponent (x ∷ [ y ])
  ; limitRepresentation = λ n b e -> Ap (Limit n) (b ∷ [ e ])
  ; IsNameOfVariableIn = IsReferencedIn
  ; lambdaRepresentation = λ name e1 e2 -> Ap (Lambda List.[ name ] e1) [ e2 ]
  ; negationRepresentation = Ap Negate ∘ [_]
  ; different-if-nats-are-different = {!!}
  ; differently-named-variables-are-different = {!!}
  }

CasanovaFly-Verified : VCAS CasanovaFly-Base
CasanovaFly-Verified = record
  { equality-is-equivalence = record
    { refl = equality-is-reflexive
    ; sym = equality-is-symmetric
    ; trans = {!!}
    }
  ; sum-of-nats-is-nat-sum = {!!}
  ; product-of-e-and-1-is-e = {!!}
  ; structural-equality-implies-definite-equality = {!!}
  ; identically-named-variables-are-equal = invae
  ; differently-named-variables-are-not-definitely-equal = {!!}
  ; difference-is-negated-sum = {!!}
  ; inverse-of-inverse-is-original = {!!}
  ; division-by-zero-is-bogus = {!!}
  ; sum-is-not-bogus = {!!}
  ; sum-is-commutative = {!!}
  ; product-is-commutative = {!!}
  ; product-of-quotient-is-same = {!!}
  ; limit-of-unrelated-value-is-unrelated-value = {!!}
  ; simple-lambda-substitution-works = {!!}
  ; nonapplicable-lambda-returns-lambda-body = {!!}
  }
  where
  open CAS CasanovaFly-Base
  open InternalEqualityFunctions

  equality-is-reflexive : Reflexive (CAS._≈_ CasanovaFly-Base)
  equality-is-reflexive = (0 , 0) , refl

  equality-is-symmetric : Symmetric _≈_
  equality-is-symmetric {e1} {e2} ((n1 , n2) , eq) with rEvaluate n1 e1 | rEvaluate n2 e2 | inspect (rEvaluate n1) e1 | inspect (rEvaluate n2) e2
  ... | inj₂ n11 | inj₂ n21 | ⟦ eq1 ⟧ | ⟦ eq2 ⟧ =
    (n1 , n2) , sym-≡₂ {!!}
    where
    sym-≡₂ : {e1 e2 : Exceptional ε} ->
             e1 ≡₂ e2 ->
             e2 ≡₂ e1
    sym-≡₂ {inj₂ e1} {inj₂ e2} refl = refl
  ... | inj₁ x | y | ⟦ eq1 ⟧ | ⟦ eq2 ⟧ =
    contradiction eq (subst₂ (¬_ ∘₂ _≡₂_)
                             eq1
                             eq2
                             (inj₁-is-not-≡₂ (rEvaluate n1 e1)
                                             (rEvaluate n2 e2)
                                             (x , eq1)))
    where
    inj₁-is-not-≡₂ :
      (e1 e2 : Exceptional ε) ->
      (Σ String (λ s -> e1 ≡ inj₁ s)) ->
      ¬ (e1 ≡₂ e2)
    inj₁-is-not-≡₂ (inj₁ e1) e2 (s , refl) ()
  ... | x | inj₁ y | ⟦ eq1 ⟧ | ⟦ eq2 ⟧ =
    contradiction eq (subst₂ (¬_ ∘₂ _≡₂_)
                             eq1
                             eq2
                             (inj₂-is-not-≡₂ (rEvaluate n1 e1)
                                             (rEvaluate n2 e2)
                                             (y , eq2)))
    where
    inj₂-is-not-≡₂ :
      (e1 e2 : Exceptional ε) ->
      (Σ String (λ s -> e2 ≡ inj₁ s)) ->
      ¬ (e1 ≡₂ e2)
    inj₂-is-not-≡₂ (inj₂ e1) (inj₁ e2) (s , refl) ()

  invae : (name1 name2 : String) ->
          name1 ≡ name2 ->
          equal-at-some-iteration (Variable name1) (Variable name2)
  invae n1 n2 refl = 0 , _ , sym theProof
    where
    theProof = begin
      definitelyEquals 0 v1 v1
        ≡⟨⟩
      inj₂ (sequenceMaybe (List.head List.[ checkEqualityAtIteration 0 0 v1 v1 ]))
        ≡⟨ cong inj₂
                (SequenceMaybe.Properties.sm-of-head-of-singleton-list-is-element
                  (checkEqualityAtIteration 0 0 v1 v1)) ⟩
      inj₂ (checkEqualityAtIteration 0 0 v1 v1)
        ≡⟨⟩
      inj₂ (Data.Maybe.map ((0 , 0) ,_)
                           (decToMaybe (rEvaluate 0 v1 ≟₂ rEvaluate 0 v1)))
        ≡⟨ cong (inj₂ ∘ Data.Maybe.map ((0 , 0) ,_) ∘ decToMaybe)
                (proj₂ equality) ⟩
      inj₂ (just ((0 , 0) , proj₁ equality)) ∎
      where
      open DefinitelyEqualsInternal
      v1 = Variable n1
      equality = dec-yes (rEvaluate 0 v1 ≟₂ rEvaluate 0 v1) refl
\end{code}
\end{document}
