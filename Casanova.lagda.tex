\documentclass{report}

\usepackage{newunicodechar}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
% The coloring distracts the author.
\usepackage[bw]{agda}

% What is a good place for this crap?
\newunicodechar{⊤}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{ℕ}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{₁}{\ensuremath{\mathnormal{_1}}}
\newunicodechar{₂}{\ensuremath{\mathnormal{_2}}}
\newunicodechar{≅}{\ensuremath{\mathnormal{\cong}}}

\title{Casanova Fly: A Formally-Verified Computer Algebra System}

\begin{document}
\maketitle{}

\begin{abstract}
In writing this paper, the author tries to answer the following questions:

\begin{itemize}
  \item Formally, what constitutes a computer algebra system, i.e., what are the essential functions of a computer algebra system?
  \item Formally, what constitutes a formally-verified computer system?  In other words, what guarantees can be made about \emph{all} good computer algebra systems?
  \item What is an example of such a formally-verified computer algebra system?
\end{itemize}

In short, the answer to the last question is ``Casanova Fly, of course''.  The remaining questions are hairy and are best answered through the non-abbreviated version of this paper.
\end{abstract}

\chapter{Prerequisites for Understanding}
The author recommends that anyone who tries to understand Casanova Fly is familiar with the following modules:

\begin{code}
open import Function
open import Data.Fin using (Fin)
open import Data.Nat
open import Data.Sum
open import Level
open import Data.String hiding (_≈_)
open import Relation.Binary.PropositionalEquality hiding ([_])
open import Data.Vec
open import Data.Maybe
open import Relation.Nullary
open import Relation.Binary
open import Data.Bool
open import Data.Rational
  as ℚ
  using (ℚ
        )
open import Data.Product
open import Data.List.Relation.Unary.Any as AnyList using (any?)
open import Data.Fin as Fin using (Fin)

import Data.List as List
import Data.Nat.Coprimality as Coprimality
import Data.Integer
import Data.Sum.Properties
\end{code}

\chapter{Useful Abbreviations and Associated Functions}
A value of type \AgdaFunction{Exceptional} \AgdaBound{A} can be a success-indicating value of \AgdaBound{A} or a \AgdaPostulate{String} which describes some sort of failure.

\begin{code}
Exceptional : {a : Level} -> Set a -> Set a
Exceptional A = String ⊎ A
\end{code}

If no values are exceptional, then the output contains the combination of both non-exceptional values.  Otherwise, the output contains the first exceptional value.

\begin{code}
condenseExceptions : {a : Level} ->
                     {A : Set a} ->
                     Exceptional A ->
                     Exceptional A ->
                     Exceptional (A × A)
condenseExceptions (inj₂ x) (inj₂ y) = inj₂ (x , y)
condenseExceptions (inj₁ e) _ = inj₁ e
condenseExceptions _ (inj₁ e) = inj₁ e
\end{code}

\chapter{The Computer Algebra System Types}

\section{The Type of Mostly-Unverified Computer Algebra Systems}
Fundamentally, a computer algebra system for an expression type \(\epsilon\) can be thought of as being a combination of the following:

\begin{itemize}
  \item an algebraic equality type,
  \item an algebraic \emph{in}equality type,
  \item a single-step evaluation function which is capable of describing failures,
  \item a proof of decidable structural equality of \(\epsilon\) values,
  \item a function which determines certain algebraic equality on non-bogus \(\epsilon\) values,
  \item a function which converts natural number values into \(\epsilon\) values,
  \item a function which converts the name of a variable into an \(\epsilon\) variable value,
  \item a function which converts the two input expressions into a representation of the sum of the input expressions,
  \item a function which converts the two input expressions into a representation of the quotient of the input expressions,
  \item a proof which indicates that for any two natural numbers \(n_1\) and \(n_2\), if \(n_1 \neq n_2\), then the representation of \(n_1\) is not equal to the representation of \(n_2\),
  \item a proof which indicates that variables of different names are not equivalent,
  \item a function which performs the maximum number of evaluation steps on the input,
  \item a function which displays all evaluation steps which are used on a given input, and
  \item some other functions which are really only terribly useful for verification.
\end{itemize}

\AgdaDatatype{CAS} is the type of such computer algebra systems.

\subsection{The Algebraic Equality Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}≈\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is algebraically equal to \AgdaBound{y}.

\subsection{The Algebraic \emph{In}equality Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}≉\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is algebraically \emph{un}equal to \AgdaBound{y}.

\subsection{The Single-Step Evaluation Function}
If such a step is possible, then the single-step evaluation function, which is represented in \AgdaDatatype{CAS} records as some \AgdaField{exceptionallyEvaluate} field, performs a single evaluation step on the input.  If no such step is possible, but the input is not bogus, then the output just contains the input.  If the input is bogus, then the output contains a description of the bogusness.

For the purposes of this document, an ``evaluation step'' is the application of a basic operation, e.g., addition or commuting the arguments of a function.  More formally, one can say that an evaluation step is the application of an operation which cannot be further simplified or decomposed into simpler operations.

\subsection{The Proof of Structural Equality}
This one, which is represented via the \AgdaField{structuralEquality} field, should be simple enough for anyone who is familiar with \AgdaFunction{DecidableEquality}.

\subsection{The Semi-Decidable Algebraic Equality Function}
\AgdaField{CAS.definitelyEquals} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is some value \AgdaInductiveConstructor{inj₂} \AgdaSymbol(\AgdaInductiveConstructor{just} \AgdaBound{equality}\AgdaSymbol) if and only if the \AgdaFild{CAS.definitelyEquals} function finds an appropriate value.  The \AgdaField{CAS.definitelyEquals} value is \AgdaInductiveConstructor{inj₂} \AgdaInductiveConstructor{nothing} if and only if the function cannot discover an appropriate proof of equality.  The function encounters an exceptional situation if and only if the \AgdaField{CAS.definitelyEquals} is \AgdaInductiveConstructor{inj₁} \AgdaBound{e}, where \AgdaBound{e} is a description of the exception.

\subsection{The Natural-to-ε Function}
The author thinks that any computer algebra system which is worthy of being given the time of day can represent natural numbers --- after all, the time of day can be represented \emph{as} a natural number!  Anyway, \AgdaField{fromℕ} indicates that a mapping from the natural numbers to the expression type of the given computer algebra system exists.

\subsection{The Variable Function}
Does a computer algebra system which lacks support for variables even qualify as being a computer algebra system?  The author is doubtful.  Anyway, \AgdaField{CAS.variableNamed} \AgdaBound{c} \AgdaBound{name} is \AgdaBound{c}'s representation of the variable whose name is \AgdaBound{name}.

\subsection{The Sum Function}
Any half-decent CAS is capable of representing the unevaluated sum of two expressions.  Accordingly, \AgdaField{sumRepresentation} values are unevaluated sum functions.  More formally, \AgdaField{CAS.sumRepresentation} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated sum of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Sum Function}
Any half-decent CAS can represent the difference of two given expressions, too.  Accordingly, \AgdaField{differenceRepresentation} values are unevaluated differences.  More formally, \AgdaField{CAS.differenceRepresentation} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated difference of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Product Function}
A decent CAS can represent the unevaluated product of two expressions.  Accordingly, \AgdaField{productRepresentation} values represent unevaluated products.  More formally, one can say that \AgdaField{CAS.productRepresentation} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated product of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Quotient Function}
Any \emph{good} CAS can \emph{also} represent the unevaluated quotient of two expressions.  Accordingly, \AgdaField{quotientRepresentation} values are unevaluated quotient functions.  More formally, \AgdaField{CAS.quotientRepresentation} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated quotient of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Additive Inverse Function}
\AgdaField{CAS.negationRepresentation} \AgdaBound{c} \AgdaBound{x} is the additive inverse of \AgdaBound{x}.

\subsection{The Natural Number Proofs}
In addition to the basic mapping, proofs of the following attributes should exist:

\begin{itemize}
  \item Any two natural numbers differ only if the CAS's representations of the numbers differ.
\end{itemize}

\subsection{The Proof which Indicates that Values of Different Names are Decidedly Not Equivalent}
Options on variables are only sensible if confusing variables is forbidden, i.e., variables of different names represented differently.  Accordingly, \AgdaField{CAS.differently-named-variables-are-different} \AgdaBound{c} indicates that within \AgdaBound{c}, given any two variables \(x\) and \(y\), if the name of \(x\) differs from the name of \(y\), then \AgdaBound{c}'s representations of \(x\) and \(y\) differ.

\subsection{The Tracing Recursive Evaluation Function}
A compliant CAS also has a function which performs the specified number of non-repeating simplification steps on the input, returning a list all steps which were taken to get the output, regardless of whether or not the output is an exception.  In \AgdaDatatype{CAS} records, this function is represented through \AgdaField{traceEvaluate}.

\subsection{The Non-Tracing Maximum Evaluation Function}
A compliant CAS also has a function which performs the specified number of non-repeating simplification steps on the input but just returns the resulting exception or expression.  In \AgdaDatatype{CAS} records, this function is represented through \AgdaField{rEvaluate}.

\subsection{The Iteration Equality Function}
A value of type \AgdaField{CAS.equal-at-iteration} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e1} \AgdaBound{e2} exists if and only if \AgdaField{CAS.definitelyEquals} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e1} \AgdaBound{e2} indicates that \AgdaBound{e1} is algebraically equal to \AgdaBound{e2}.  This function mostly exists to eliminate repetition.

\subsection{The Generic Iteration Equality Function}
A value of type \AgdaField{CAS.equal-at-some-iteration} \AgdaBound{c} \AgdaBound{e1} \AgdaBound{e2} exists if and only if \AgdaField{CAS.definitelyEquals} \AgdaBound{c} can determine that \AgdaBound{e1} is algebraically equal to \AgdaBound{e2} at some iteration.  Again, this function is really just good for reducing nasty redundancy.

\subsection{The Equality Step Function}
\AgdaField{CAS.equality-at-n-implies-equality-at-n+1} proves that two expressions are definitely equal at a given iteration only if these same expressions are also definitely equal at the following iteration.

\subsection{The Definition Proper}

\begin{code}
record CAS {a : Level} (ε : Set a) : Set (Level.suc Level.zero Level.⊔ a) where
  field
    exceptionallyEvaluate : ε -> Exceptional ε
    structuralEquality : DecidableEquality ε
    fromℕ : ℕ -> ε
    variableNamed : String -> ε
    sumRepresentation
     differenceRepresentation
     productRepresentation
     quotientRepresentation : ε -> ε -> ε
    negationRepresentation : ε -> ε
    different-if-nats-are-different :
      {n1 n2 : ℕ} -> n1 ≢ n2 -> fromℕ n1 ≢ fromℕ n2
    differently-named-variables-are-different :
      (name1 name2 : String) ->
      name1 ≢ name2 ->
      variableNamed name1 ≢ variableNamed name2

  traceEvaluate : ℕ -> ε -> List.List (Exceptional ε)
  traceEvaluate maxIter = t maxIter List.[] ∘ inj₂
    where
    t : ℕ -> List.List (Exceptional ε) -> Exceptional ε -> List.List (Exceptional ε)
    t ℕ.zero xs e = xs
    t (ℕ.suc iters) xs (inj₁ x) = xs List.++ List.[ inj₁ x ]
    t (ℕ.suc iters) xs e@(inj₂ x) with any? is-e xs
      where is-e = Data.Sum.Properties.≡-dec Data.String._≟_ structuralEquality e
    ... | yes _ = xs
    ... | no _ = t iters (xs List.++ List.[ e ]) (exceptionallyEvaluate x)

  rEvaluate : ℕ -> ε -> Exceptional ε
  rEvaluate n e = fromMaybe (inj₂ e) (List.last (traceEvaluate n e))

  _≈_ : ℕ -> ε -> ε -> Set a
  _≈_ iterations x y = AnyList.Any (uncurry _≡_) evaluationPairs
    where
    traceEvaluate2 = traceEvaluate iterations
    evaluationPairs = inj2s (List.cartesianProduct (traceEvaluate2 x) (traceEvaluate2 y))
      where
      inj2s : List.List (Exceptional ε × Exceptional ε) -> List.List (ε × ε)
      inj2s ((inj₂ e1 , inj₂ e2) List.∷ es) = (e1 , e2) List.∷ inj2s es
      inj2s (e List.∷ es) = inj2s es
      inj2s List.[] = List.[]

  _≉_ : ε -> ε -> Set a
  x ≉ y = (iterations : ℕ) -> ¬ _≈_ iterations x y

  definitelyEquals : (iterations : ℕ) ->
                     (x y : ε) ->
                     Exceptional (Maybe (_≈_ iterations x y))
  definitelyEquals iterations x y = with-justness (firstInj1 (trace x List.++ trace y))
    where
    firstInj1 : List.List (Exceptional ε) -> Maybe String
    firstInj1 List.[] = nothing
    firstInj1 (inj₂ e List.∷ es) = firstInj1 es
    firstInj1 (inj₁ e List.∷ es) = just e
    trace = traceEvaluate iterations
    with-justness : Maybe String ->
                    Exceptional (Maybe (_≈_ iterations x y))
    with-justness (just e) = inj₁ e
    with-justness nothing =
      inj₂ (decToMaybe (any? (uncurry structuralEquality) _))

  equal-at-iteration : ℕ -> (e1 e2 : ε) -> Set a
  equal-at-iteration iterations e1 e2 =
    Σ (_≈_ iterations e1 e2)
      (\ i -> inj₂ (just i) ≡ definitelyEquals iterations e1 e2)

  equal-at-some-iteration : (e1 e2 : ε) -> Set a
  equal-at-some-iteration e1 e2 = Σ ℕ (\ n -> equal-at-iteration n e1 e2)

  equality-at-n-implies-equality-at-n+1 :
    (iterations : ℕ) ->
    (e1 e2 : ε) ->
    equal-at-iteration iterations e1 e2 ->
    equal-at-iteration (iterations + 1) e1 e2
  equality-at-n-implies-equality-at-n+1 = {!!}
\end{code}

\section{The Type of Verified Computer Algebra Systems}
For the purposes of this document, a verified computer algebra system is the combination of a \AgdaDatatype{CAS} computer algebra system \emph{and} some guarantees about the corresponding CAS.  The non-\AgdaDatatype{CAS} parts of the combination are as follows:

\begin{itemize}
 \item a proof which indicates that the algebraic equality relation is an equaivalence relation,
 \item a proof which indicates that two values are structurally equivalent only if these same values are also algebraically equal,
 \item a proof which indicates that variables of different names are not definitely equal,
 \item a proof which indicates that two variables which have the same name are algebraically equal,
 \item a proof which indicates that for any two integers \(n_1\) and \(n_2\), the sum of the representation of \(n_1\) and \(n_2\) is the representation of \(n_1 + n_2\), and
 \item a proof which indicates that the product of any non-bogus element \(e\) of type \AgdaBound{ε} and one is \(e\).
\end{itemize}

\subsection{The Proof of the Equivalence Nature of the Algebraic Equality Relation}
A good CAS is used for representing the complex numbers, whose equality relation is an equivalence relation.  Accordingly, a verified CAS's algebraic equality relation should be an equivalence relation.  \AgdaField{equality-is-equivance} values indicate that the algebraic equality relations actually are equivalence relations.

\subsection{The Structural-Equivalence-to-Algebraic-Equality Function}
Also, in a good CAS, two expressions \(e_1\) and \(e_2\) are represented in the same way only if \(e_1\) is algebraically equal to \(e_2\).  This fact is represented through the use of \AgdaField{structural-equality-implies-definite-equality}.

\subsection{The Proof which Indicates that Values of Different Names are Not ``Definitely Equal''}
Any two given variables are not necessarily equal.  Accordingly, \AgdaField{VCAS.differently-named-variables-are-not-definitely-equal} \AgdaBound{c} indicates that within the \AgdaBound{c} CAS, given any two \AgdaBound{c} variables \(x\) and \(y\), if the name of \(x\) differs from the name of \(y\), then \(x\) is not definitely equal to \(y\).

\subsection{The Proof which Indicates that Variables of Identical Names are Algebraically Equal}
Also, options on variables are only sensible if for all variables \(x\) and \(y\), if the name of \(x\) is also the name of \(y\), then \(x\) is algebraically equal to \(y\).  Accordingly, \AgdaField{VCAS.identically-named-variables-are-equal} \AgdaBound{c} indicates that for any \AgdaBound{c}-CAS variables \(x\) and \(y\), if the name of \(x\) is identical to the name of \(y\), then \AgdaBound{c} can determine that \(x\) is algebraically equal to \(y\).

\subsection{The Natural Number Sum Field}
Another aspect of a good computer algebra system is the correct calculation of sums of natural numbers.  Intuition dictates that in a good computer algebra system, the sum of two natural number should be the sum of the same two natural numbers.  However, as indicated by \AgdaField{CAS.fromℕ}, many computer algebra systems do not just work with natural numbers; accordingly, natural number arithmetic may accidentally be implemented incorrectly.  However, correct calculation of natural number sums is ensured through \AgdaField{sum-of-nats-is-nat-sum} values, which are proof which indicate that the corresponding computer algebra systems' natural number addition functions are defined correctly.

\subsection{The 1-Product Field}
\AgdaField{VCAS.product-of-e-and-1-is-e} \AgdaBound{c} indicates that for any non-bogus value \(e\) of the expression type for \AgdaBound{c}, the product of \(e\) and one is equal to \(e\).

\subsection{The Definition Proper}

\begin{code}
record VCAS {a : Level} (ε : Set a) (Cas : CAS ε) : Set a where
  open CAS Cas
  field
    equality-is-equivalence : (iterations : ℕ) -> IsEquivalence (_≈_ iterations)
    structural-equality-implies-definite-equality :
      (e1 e2 : ε) ->
      e1 ≡ e2 ->
      (iterations : ℕ) ->
      (isInj2 : Is-just (isInj₂ (definitelyEquals iterations e1 e2))) ->
      Is-just (to-witness isInj2)
    differently-named-variables-are-not-definitely-equal :
      (name1 name2 : String) ->
      name1 ≢ name2 ->
      (iterations : ℕ) ->
      inj₂ nothing ≡ definitelyEquals iterations (variableNamed name1) (variableNamed name2) ⊎
      Σ String (\ s -> inj₁ s ≡ definitelyEquals iterations (variableNamed name1) (variableNamed name2))
    identically-named-variables-are-equal :
      (name1 name2 : String) ->
      name1 ≡ name2 ->
      equal-at-some-iteration (variableNamed name1) (variableNamed name2)
    sum-of-nats-is-nat-sum :
      (n1 n2 iterations : ℕ) ->
      rEvaluate iterations (sumRepresentation (fromℕ n1) (fromℕ n2)) ≡
        inj₂ (fromℕ (n1 + n2))
    product-of-e-and-1-is-e :
      (e : ε) ->
      equal-at-some-iteration (productRepresentation e (fromℕ 1)) e
    difference-is-negated-sum :
      (e1 e2 : ε) ->
      equal-at-some-iteration (differenceRepresentation e1 e2)
                              (sumRepresentation e1 (negationRepresentation e2))
    inverse-of-inverse-is-original :
      (e : ε) ->
      equal-at-some-iteration e (negationRepresentation (negationRepresentation e))
\end{code}

\chapter{The Core Datatypes and Associated Functions}

\section{Type Declarations}

\subsection{\AgdaDatatype{F}'s Type and Summary}
Values of type \AgdaDatatype{F} represent functions.

\begin{code}
data F : Set
\end{code}

\subsection{\AgdaDatatype{ε}'s Type and Summary}
Values of \AgdaDatatype{ε} represent expressions.

\begin{code}
data ε : Set
\end{code}

\section{The Actual Definitions\ldots and Supporting Functions}

\subsection{Completing \AgdaDatatype{F}'s Definition}
The following statements hold:

\begin{itemize}
  \item \AgdaInductiveConstructor{Abs} represents the absolute value function.
  \item \AgdaInductiveConstructor{Negate} represents the negation function.
  \item \AgdaInductiveConstructor{Sum} represents the sum function.
  \item \AgdaInductiveConstructor{Product} represents the product, i.e., multiplication, function.
  \item \AgdaInductiveConstructor{Exponentiation} represents the exponentiation function.
  \item \AgdaInductiveConstructor{Lambda} \AgdaBound{names} \AgdaBound{body} represents a lambda function whose bound variables are listed in \AgdaBound{names} and whose body is \AgdaBound{body}.  Alternatively, if \AgdaBound{names} consists of values \texttt{n1}, \texttt{n2}, \texttt{n3}, and so on, one could say that \AgdaInductiveConstructor{Lambda} \AgdaBound{names} \AgdaBound{body} is equivalent to Agda's \texttt{\textasciibackslash n1 n2 n3 ... -> body2}, where \texttt{body2} is an expansion of \AgdaBound{body}.
\end{itemize}

\begin{code}
data F where
  Abs
   Negate
   Sum
   Product
   Exponent : F
  Lambda : List.List String -> ε -> F
\end{code}

\subsection{The Arity-Determining Function}
\AgdaFunction{arity} \AgdaBound{f} is the arity of the \AgdaBound{f} function.

\begin{code}
arity : F -> ℕ
arity Abs = 1
arity Negate = 1
arity Sum = 2
arity Product = 2
arity Exponent = 2
arity (Lambda names body) = List.length names
\end{code}

\subsection{The Commutativity-Determining Function}
\AgdaFunction{isCommutative} \AgdaBound{f} \AgdaBound{a} is \AgdaInductiveConstructor{true} if and only if \AgdaBound{f} represents a commutative function.

\begin{code}
isCommutative : (f : F) -> arity f ≡ 2 -> Bool
isCommutative Sum refl = true
isCommutative Product refl = true
isCommutative Exponent refl = false
isCommutative (Lambda names body) equality = false
\end{code}

\subsection{Completing \AgdaDatatype{ε}'s Definition}
The following statements hold:

\begin{itemize}
  \item \AgdaInductiveConstructor{Infinity} represents infinity.
  \item \AgdaInductiveConstructor{Variable} \AgdaBound{n} represents a variable whose name is \AgdaBound{n}.
  \item \AgdaInductiveConstructor{NumberRat} \AgdaBound{q} represents \AgdaBound{q}.
  \item \AgdaInductiveConstructor{Ap} \AgdaBound{f} \AgdaBound {e} represents the result of applying \AgdaBound{f} to \AgdaBound{e}.
\end{itemize}

\begin{code}
data ε where
  Infinity : ε
  Variable : String -> ε
  NumberRat : ℚ -> ε
  Ap : (f : F) -> Vec ε (arity f) -> ε
\end{code}

\section{Additional Functions}

\subsection{Decidable Structural Equality on \AgdaDatatype{F}}
This function is used to determine whether or not the input arguments are structurally equivalent.

\begin{code}
structuralEqualityOnF : DecidableEquality F
structuralEqualityOnF = {!!}
\end{code}

\subsection{Decidable Structural Equality on \AgdaDatatype{ε}}
This function is used to determine whether or not the input arguments are structurally equivalent.

\begin{code}
structuralEqualityOnε : DecidableEquality ε
structuralEqualityOnε = {!!}
\end{code}

\subsection{The Function for Commutativity Permutations}
\AgdaFunction{commutativePermutations} \AgdaBound{x} is a list of all expressions which are equivalent to \AgdaBound{x} and are derived from \AgdaBound{x} by commutativity.

\begin{code}
commutativePermutations : ε -> List.List ε
commutativePermutations (Ap f e) = perms' f (Data.Vec.toList e) {!!}
  where
  c : {a : Level} ->
      {A B : Set a} ->
      A ≡ B ->
      A -> B
  c refl t = t
  combine : (f : F) -> (e : List.List ε) -> arity f ≡ List.length e -> ε
  combine f e lengthMatch = Ap f (c (sym (cong (Vec ε) lengthMatch))
                                    (Data.Vec.fromList e))
  perms' : (f : F) -> (e : List.List ε) -> arity f ≡ List.length e -> List.List ε
  perms' f e@(e1 List.∷ e2 List.∷ List.[]) lengthMatches with isCommutative f lengthMatches
  ... | false = List.[ combine f e lengthMatches ]
  ... | true =
    f' (reverse (e1 ∷ [ e2 ])) List.∷ f' (e1 ∷ [ e2 ]) List.∷
    List.map (\ e2 -> f' (e1 ∷ [ e2 ])) (commutativePermutations e2) List.++
    List.map (\ e1 -> f' (e1 ∷ [ e2 ])) (commutativePermutations e1) List.++
    List.concat (List.map (\ (e1 , e2) -> f' (e1 ∷ [ e2 ]) List.∷
                                          List.[ f' (e2 ∷ [ e1 ]) ])
                          (List.zip (commutativePermutations e1)
                                    (commutativePermutations e2)))
    where
    f' = Ap f ∘ c (sym (cong (Vec ε) lengthMatches))
  perms' f e lengthMatches = List.[ combine f e lengthMatches ]
commutativePermutations o = List.[ o ]
\end{code}

\chapter{Computational Functions and Ilk}

\section{The Single-Step Evaluation Function}
\AgdaFunction{exceptionallyEvaluate} \AgdaBound{x} contains the result of performing a single evaluation step on \AgdaBound{x} \emph{or} a value which indicates that \AgdaBound{x} is in some way nonsensical.

\begin{code}
exceptionallyEvaluate : ε -> Exceptional ε
exceptionallyEvaluate = {!!}
\end{code}

\section{The Single-Step Evaluation Function which \emph{also} Supports Commutativity}
\AgdaFunction{commutativeEvaluate} \AgdaBound{e} performs a single evaluation step on the input expression but can also do some fancy stuff when applicable, e.g., switching the arguments of commutative functions.

\begin{code}
commutativeEvaluate : ε -> Exceptional ε
commutativeEvaluate = {!!}
\end{code}

\chapter{Proofs of Correctness}

\begin{code}
module CommutativeEvaluationProperties where
  ce = commutativeEvaluate

  0^0-is-nonsense :
    Is-just (isInj₁ (exceptionallyEvaluate
      (Ap Exponent (NumberRat ℚ.0ℚ ∷ [ NumberRat ℚ.0ℚ ]))))
  0^0-is-nonsense = {!!}
\end{code}

\chapter{Wrapping up Everything}

\begin{code}
CasanovaFly-Base : CAS ε
CasanovaFly-Base = record
  { exceptionallyEvaluate = commutativeEvaluate
  ; structuralEquality = structuralEqualityOnε
  ; fromℕ = \ n ->
      NumberRat (ℚ.mkℚ (Data.Integer.+ n)
                       0
                       (Coprimality.sym (Coprimality.1-coprimeTo n)))
  ; variableNamed = Variable
  ; sumRepresentation = \ a b -> Ap Sum (a ∷ b ∷ [])
  ; differenceRepresentation = \ x y -> Ap Sum (x ∷ [ Ap Negate [ y ] ])
  ; productRepresentation = \ x y -> Ap Product (x ∷ [ y ])
  ; quotientRepresentation = \ x y ->
     Ap Product (x ∷ Ap Exponent (y ∷ Ap Negate (NumberRat ℚ.1ℚ ∷ []) ∷ []) ∷ [])
  ; negationRepresentation = Ap Negate ∘ [_]
  ; different-if-nats-are-different = {!!}
  ; differently-named-variables-are-different = {!!}
  }

CasanovaFly-Verified : VCAS ε CasanovaFly-Base
CasanovaFly-Verified = record
  { equality-is-equivalence = {!!}
  ; sum-of-nats-is-nat-sum = {!!}
  ; product-of-e-and-1-is-e = {!!}
  ; structural-equality-implies-definite-equality = {!!}
  ; identically-named-variables-are-equal = {!!}
  ; differently-named-variables-are-not-definitely-equal = {!!}
  ; difference-is-negated-sum = {!!}
  ; inverse-of-inverse-is-original = {!!}
  }
\end{code}
\end{document}
