\documentclass{report}

\usepackage{newunicodechar}
\usepackage{geometry}[margin=1.25in]
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
% The coloring distracts the author.
\usepackage[bw]{agda}
\usepackage{unicode-math}
\usepackage{physics}
\usepackage{fancyref}

\newcommand{\Epsilon}{E}

% What is a good place for this crap?
\newunicodechar{⊤}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{⊥}{\ensuremath{\mathnormal{\bot}}}
\newunicodechar{ℕ}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{₁}{\ensuremath{\mathnormal{_1}}}
\newunicodechar{₂}{\ensuremath{\mathnormal{_2}}}
\newunicodechar{≅}{\ensuremath{\mathnormal{\cong}}}
\newunicodechar{ε}{\ensuremath{\mathnormal{\epsilon}}}
\newunicodechar{τ}{\ensuremath{\mathnormal{\tau}}}
\newunicodechar{λ}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{ℚ}{\ensuremath{\mathnormal{\mathbb{Q}}}}
\newunicodechar{ℤ}{\ensuremath{\mathnormal{\mathbb{Z}}}}
\newunicodechar{∷}{\ensuremath{\mathnormal{\Colon}}}
\newunicodechar{⊎}{\ensuremath{\mathnormal{\uplus}}}
\newunicodechar{≈}{\ensuremath{\mathnormal{\approx}}}
\newunicodechar{≉}{\ensuremath{\mathnormal{\napprox}}}
\newunicodechar{≡}{\ensuremath{\mathnormal{\equiv}}}
\newunicodechar{≢}{\ensuremath{\mathnormal{\nequiv}}}
\newunicodechar{≤}{\ensuremath{\mathnormal{\leq}}}
\newunicodechar{⊔}{\ensuremath{\mathnormal{\sqcup}}}
\newunicodechar{≟}{\ensuremath{\mathnormal{\stackrel{?}{=}}}}
\newunicodechar{∘}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{∧}{\ensuremath{\mathnormal{\land}}}
\newunicodechar{∧}{\ensuremath{\mathnormal{\land}}}
\newunicodechar{⇒}{\ensuremath{\mathnormal{\Rightarrow}}}
\newunicodechar{⟨}{\ensuremath{\mathnormal{\langle}}}
\newunicodechar{⟩}{\ensuremath{\mathnormal{\rangle}}}
\newunicodechar{∎}{\ensuremath{\mathnormal{\blacksquare}}}
\newunicodechar{∈}{\ensuremath{\mathnormal{\in}}}
\newunicodechar{∉}{\ensuremath{\mathnormal{\notin}}}
\newunicodechar{ᵇ}{\ensuremath{\mathnormal{^\AgdaFontStyle{b}}}}
\newunicodechar{∣}{\ensuremath{\mathnormal{\lvert}}}
\newunicodechar{↭}{\ensuremath{\mathnormal{\leftrightsquigarrow}}}

\title{Casanova Fly: A Formally-Verified Computer Algebra System}
\author{Andrew Christopher Hawk}

\begin{document}
\maketitle{}

\begin{abstract}
In writing this paper, the author tries to answer the following questions:

\begin{itemize}
  \item Formally, what constitutes a computer algebra system, i.e., what are the essential functions of a computer algebra system?
  \item Formally, what constitutes a formally-verified computer system?  In other words, what guarantees can be made about \emph{all} good computer algebra systems?
  \item What is an example of such a formally-verified computer algebra system?
\end{itemize}

In short, the answer to the last question is ``Casanova Fly, of course''.  The remaining questions are hairy and are best answered through the non-abbreviated version of this paper.
\end{abstract}

\tableofcontents

\part{Generic Stuff}

\chapter{Prerequisites for Understanding}
The author recommends that anyone who tries to understand Casanova Fly is familiar with the following modules:

\begin{code}
open import Function
open import Data.Fin using (Fin)
open import Data.Nat using (ℕ)
open import Data.Sum
open import Level
open import Data.String hiding (_≈_; _<_; _≤_)
open import Relation.Binary.PropositionalEquality hiding ([_])
open ≡-Reasoning
open import Data.Vec
open import Data.Maybe
open import Relation.Nullary
open import Relation.Binary
open import Data.Bool hiding (_<_; _≤_)
open import Data.Rational
  as ℚ
  using (ℚ
        )
open import Data.Product
open import Data.List.Relation.Unary.Any as AnyList using (any?)
open import Data.Fin as Fin using (Fin)
open import Data.List.Relation.Unary.Unique.Propositional
  renaming
    ( Unique to UniqueList
    )
open import Relation.Nullary.Decidable
  using
    ( dec-yes
    )
open import Data.Empty.Polymorphic using (⊥)
open import Data.List.Membership.Propositional
open import Data.Unit.Polymorphic
open import Data.List.Relation.Binary.Permutation.Propositional
  as PermutationList
  using
    ( _↭_
    )
import Data.List as List
import Data.Nat.Coprimality as Coprimality
import Data.Integer
import Data.Sum.Properties
import Data.List.Relation.Unary.All as AllList
import Data.List.Relation.Unary.All.Properties as AllListProp
import Data.List.Relation.Unary.AllPairs as AllPairsList
import Data.Maybe.Properties
import Data.Maybe.Relation.Unary.Any as AnyMaybe
import Data.Nat.Properties
import Data.Product.Properties as ProdProp
import Data.Vec.Properties as VecProp
import Data.Vec.Relation.Unary.Any as AnyVec
\end{code}

\chapter{Useful Abbreviations and Ilk}

\section{The Exception Type}
A value of type \AgdaFunction{Exceptional} \AgdaBound{A} can be a success-indicating value of \AgdaBound{A} or a \AgdaPostulate{String} which describes some sort of failure.

\begin{code}
Exceptional : {a : Level} → Set a → Set a
Exceptional A = String ⊎ A
\end{code}

\subsection{The Exception Condensation Function}
If no values are exceptional, then the output contains the combination of both non-exceptional values.  Otherwise, the output contains the first exceptional value.

\begin{code}
condenseExceptions : {a : Level} →
                     {A : Set a} →
                     Exceptional A →
                     Exceptional A →
                     Exceptional (A × A)
condenseExceptions (inj₂ x) (inj₂ y) = inj₂ (x , y)
condenseExceptions (inj₁ e) _ = inj₁ e
condenseExceptions _ (inj₁ e) = inj₁ e
\end{code}

\section{The Exceptional Function Reapplication Function}
Informally, one can say that \AgdaFunction{repeatExceptional} \AgdaBound{n} \AgdaBound{f} \AgdaBound{x} applies \AgdaBound{f} to \AgdaBound{x} \AgdaBound{n} times; \AgdaInductiveConstructor{inj₂} values are subject to reapplication, and \AgdaInductiveConstructor{inj₁} values are immediately returned.  Formally, one can say that the following statements apply:

\begin{enumerate}
  \item \AgdaFunction{repeatExceptional} \AgdaNumber{0} \AgdaBound{f} \AgdaBound{x} is \AgdaInductiveConstructor{inj₂} \AgdaBound{x}.\label{enum:repeatExceptional-zeroIsInj2}
  \item If \AgdaBound{f} \AgdaBound{x} is some \AgdaInductiveConstructor{inj₁} value, then then \AgdaFunction{repeatExceptional} \AgdaBound{n} \AgdaBound{f} \AgdaBound{x} is \AgdaBound{f} \AgdaBound{x}.\label{enum:repeatExceptional-inj1GetsReturned}
  \item If \AgdaBound{f} \AgdaBound{x} is some value \AgdaInductiveConstructor{inj₂} \AgdaBound{x'}, then \AgdaFunction{repeatExceptional} \AgdaSymbol(\AgdaInductiveConstructor{ℕ.suc} \AgdaBound{n}\AgdaSymbol) \AgdaBound{f} \AgdaBound{x} is equivalent to \AgdaFunction{repeatExceptional} \AgdaBound{n} \AgdaBound{f} \AgdaBound{x'}.\label{enum:inj2GetsRepeat}
\end{enumerate}

\begin{code}
module repeatExceptional where
  repeatExceptional :
    {a b : Level} →
    {A : Set a} →
    {B : Set b} →
    ℕ → (f : A → B ⊎ A) → A → B ⊎ A
  repeatExceptional 0 f x = inj₂ x
  repeatExceptional (ℕ.suc n) f x =
    [_,_] inj₁ (repeatExceptional n f) (f x)
\end{code}

\subsection{The Properties of the Function}

\begin{code}
  module Properties
    {a b : Level}
    {A : Set a}
    {B : Set b}
    (f : A → B ⊎ A)
    (x : A) where
\end{code}

\subsubsection{The Zero Proof}
\AgdaFunction{zero-is-inj2}, indicates that in accordance with \fref{enum:repeatExceptional-zeroIsInj2}, \AgdaFunction{repeatExceptional} \AgdaNumber{0} \AgdaBound{f} \AgdaBound{x} is just \AgdaBound{f} \AgdaBound{x}.

\begin{code}
    zero-is-inj2 : repeatExceptional 0 f x ≡ inj₂ x
    zero-is-inj2 = refl
\end{code}

\subsubsection{The \AgdaInductiveConstructor{inj₁} Proof}
In accordance with \fref{enum:repeatExceptional-inj1GetsReturned}, \AgdaFunction{inj₁-immediate-return} indicates that if \AgdaBound{f} \AgdaBound{x} is some \AgdaInductiveConstructor{inj₁} value, then \AgdaFunction{repeatExceptional} \AgdaSymbol(\AgdaInductiveConstructor{ℕ.suc} \AgdaBound{n}\AgdaSymbol) \AgdaBound{f} \AgdaBound{x} is always \AgdaBound{f} \AgdaBound{x}.

\begin{code}
    inj1-immediate-return :
      {x' : B} →
      (n : ℕ) →
      f x ≡ inj₁ x' →
      repeatExceptional (ℕ.suc n) f x ≡ f x
    inj1-immediate-return {x'} 0 equality = begin
      [_,_]′ inj₁ (repeatExceptional 0 f) (f x)
        ≡⟨ cong ([_,_]′ inj₁ (repeatExceptional 0 f)) equality ⟩
      inj₁ x'
        ≡⟨ sym equality ⟩
      f x ∎
    inj1-immediate-return {x'} (ℕ.suc n) equality = begin
      repeatExceptional (ℕ.suc (ℕ.suc n)) f x
        ≡⟨⟩
      [_,_]′ inj₁ (repeatExceptional (ℕ.suc n) f) (f x)
        ≡⟨ cong ([_,_] inj₁ (repeatExceptional (ℕ.suc n) f)) equality ⟩
      [_,_]′ inj₁ (repeatExceptional (ℕ.suc n) f) (inj₁ x')
        ≡⟨⟩
      inj₁ x'
        ≡⟨ sym equality ⟩
      f x ∎
\end{code}

\subsubsection{The \AgdaInductiveConstructor{inj₂} Proof}
In accordance with \fref{enum:inj2GetsRepeat}, \AgdaFunction{inj2-repeat} indicates that if \AgdaBound{f} \AgdaBound{x} is some \AgdaInductiveConstructor{inj₂} \AgdaBound{x'}, then \AgdaFunction{repeatExceptional} \AgdaSymbol(\AgdaInductiveConstructor{ℕ.suc} \AgdaBound{n}\AgdaSymbol) \AgdaBound{f} \AgdaBound{x} is \AgdaFunction{repeatExceptional} \AgdaBound{n} \AgdaBound{f} \AgdaBound{x'}..

\begin{code}
    inj2-repeat :
      {x' : A} →
      (n : ℕ) →
      f x ≡ inj₂ x' →
      repeatExceptional (ℕ.suc n) f x ≡ repeatExceptional n f x'
    inj2-repeat {x'} n equality = begin
      repeatExceptional (ℕ.suc n) f x
        ≡⟨⟩
      [_,_]′ inj₁ (repeatExceptional n f) (f x)
        ≡⟨ cong ([_,_]′ inj₁ (repeatExceptional n f)) equality ⟩
      repeatExceptional n f x' ∎
\end{code}

\subsection{Exporting the Function}
``\AgdaFunction{repeatExceptional.repeatExceptional}'' is a bit repetitive and long, so the author encourages and enables the use of ``\AgdaFunction{repeatExceptional}''.

\begin{code}
repeatExceptional = repeatExceptional.repeatExceptional
\end{code}

\section{The First Repeat Position Function}
\AgdaFunction{firstRepeatPosition} is such that the following statements hold:

\begin{itemize}
  \item If \AgdaBound{x} contains no repeating elements, then \AgdaFunction{firstRepeatPosition} \AgdaBound{DEQ} \AgdaBound{x} is \AgdaInductiveConstructor{nothing}.
  \item If \AgdaBound{x} has repeating values, then \AgdaFunction{firstRepeatPosition} \AgdaBound{DEQ} \AgdaBound{x} contains the position of the first repeating value in \AgdaBound{x}.
\end{itemize}

\begin{code}
module firstRepeatPosition
  {a : Level}
  {A : Set a}
  (DEQ : DecidableEquality A) where

  firstRepeatPosition : (x : List.List A) → Maybe (Fin (List.length x))
  firstRepeatPositionHelper : (x y : List.List A) → Maybe (Fin (List.length y))

  firstRepeatPosition = firstRepeatPositionHelper List.[]

  firstRepeatPositionHelper x List.[] = nothing
  firstRepeatPositionHelper List.[] (y List.∷ ys) =
    Data.Maybe.map Fin.suc (firstRepeatPositionHelper List.[ y ] ys)
  firstRepeatPositionHelper (x List.∷ xs) (y List.∷ ys) =
    if isYes (any? (DEQ y) (x List.∷ xs))
      then just Fin.zero
      else Data.Maybe.map Fin.suc (firstRepeatPositionHelper (y List.∷ x List.∷ xs) ys)
\end{code}

\subsection{The Properties of the Function}
This module contains a few proofs which indicates that \AgdaFunction{firstRepeatPosition} really does work as described, after all.  For the sake of improving readability and preventing a repetitive strain injury, the author has also provided an abbreviation of the main function's name.

\begin{code}
  module Properties where

    pos = firstRepeatPosition
    posh = firstRepeatPositionHelper
\end{code}

\subsubsection{The Unique Prepending Proof}
\AgdaFunction{unique-element-prepend} indicates that if \AgdaBound{x} is not in \AgdaBound{xs}, then \AgdaFunction{pos} \AgdaSymbol(\AgdaBound{x} \AgdaOperator{\AgdaFunction{List.∷}} \AgdaBound{xs}\AgdaSymbol) contains the successor of \AgdaFunction{pos} \AgdaBound{xs} or is \AgdaInductiveConstructor{nothing}.

\begin{code}
    unique-element-prepend :
      (x : A) →
      (xs : List.List A) →
      AllList.All (_≢_ x) xs →
      pos (x List.∷ xs) ≡ Data.Maybe.map Fin.suc (pos xs)
    unique-element-prepend x List.[] all = refl
    unique-element-prepend x xs@(x1 List.∷ xs1) alls@(a AllList.∷ as) = begin
      pos (x List.∷ xs)
        ≡⟨⟩
      mapSuc (posh List.[ x ] xs)
        ≡⟨⟩
      mapSuc
        (if isYes (any? (DEQ x1) List.[ x ])
            then just Fin.zero
            else mapSuc (posh (x1 List.∷ List.[ x ]) xs1))
        ≡⟨ cong (λ e → mapSuc (if isYes e
                                   then just Fin.zero
                                   else mapSuc (posh (x1 List.∷ List.[ x ]) xs1)))
                x1-is-decidably-not-in-[x] ⟩
      mapSuc (mapSuc (posh (x1 List.∷ List.[ x ]) xs1))
        ≡⟨ cong mapSuc (sym (posh-moves-elements {x} {x1} {xs1} )) ⟩
      mapSuc (posh List.[ x ] xs)
        ≡⟨ cong mapSuc (sym (pos-is-posh {x} {xs} alls)) ⟩
      mapSuc (posh List.[] xs) ∎
      where
      mapSuc : {n : ℕ} → Maybe (Fin n) → Maybe (Fin (ℕ.suc n))
      mapSuc = Data.Maybe.map Fin.suc
      posh-moves-elements :
        {x y : A} →
        {xs : List.List A} →
        _≡_ (posh List.[ x ] (y List.∷ xs))
            (Data.Maybe.map Fin.suc (posh (y List.∷ List.[ x ]) xs))
      posh-moves-elements = {!!}
      pos-is-posh :
        {x : A} →
        {xs : List.List A} →
        AllList.All (_≢_ x) xs →
        pos xs ≡ posh List.[ x ] xs
      pos-is-posh = {!!}
      x1-is-decidably-not-in-[x] :
        _≡_ (any? (DEQ x1) List.[ x ])
            (no (AllListProp.All¬⇒¬Any ((_∘ sym) a AllList.∷ AllList.[])))
      x1-is-decidably-not-in-[x] = {!!}
\end{code}

\subsubsection{The Proof of Nothingness's Implication of Uniqueness}
\AgdaFunction{pos-is-nothing-only-if-list-is-unique} indicates that \AgdaFunction{pos} \AgdaBound{xs} is \AgdaInductiveConstructor{nothing} only if \AgdaBound{xs} is a unique list.

\begin{code}
    pos-is-nothing-only-if-list-is-unique :
      (x : List.List A) →
      pos x ≡ nothing →
      UniqueList x
    pos-is-nothing-only-if-list-is-unique = {!!}
\end{code}

\subsubsection{The Prepended Nonunique List Proof}
\AgdaFunction{nonunique-prepend} indicates that the result of prepending a value to a non-unique list is \emph{also} a non-unique list.

\begin{code}
    nonunique-prepend :
      (x : A) →
      (xs : List.List A) →
      Is-just (pos xs) →
      Is-just (pos (x List.∷ xs))
    nonunique-prepend x (y List.∷ ys) nonUniqueness with any? (DEQ x) (y List.∷ ys)
    ... | no xIsUniqueInYYs = justness-implies-justness index equality
      where
      index : Fin (List.length (x List.∷ y List.∷ ys))
      index = Fin.suc (to-witness nonUniqueness)
      justness-implies-justness :
        {a : Level} →
        {A : Set a} →
        {x : Maybe A} →
        (y : A) →
        x ≡ just y →
        Is-just x
      justness-implies-justness y refl = AnyMaybe.just _
      self-is-just-to-witness :
        {a : Level} →
        {A : Set a} →
        {x : Maybe A} →
        (isJust : Is-just x) →
        x ≡ just (to-witness isJust)
      self-is-just-to-witness {x = just x} (AnyMaybe.just isJust) = refl
      equality : pos (x List.∷ y List.∷ ys) ≡ just index
      equality = begin
        pos (x List.∷ y List.∷ ys)
          ≡⟨ unique-element-prepend x (y List.∷ ys)
                                    (AllListProp.¬Any⇒All¬ _ xIsUniqueInYYs) ⟩
        Data.Maybe.map Fin.suc (pos (y List.∷ ys))
          ≡⟨ cong (Data.Maybe.map Fin.suc) (self-is-just-to-witness nonUniqueness) ⟩
        Data.Maybe.map Fin.suc (just (to-witness nonUniqueness))
          ≡⟨⟩
        just index ∎
    ... | yes xAppears = {!!}
\end{code}

\subsubsection{The Proof of Recursive Nothingness}
\AgdaFunction{pos-is-nothing-only-if-removal-is-nothing} indicates that \AgdaFunction{pos} \AgdaSymbol(\AgdaBound{x} \AgdaOperator{\AgdaFunction{∷}} \AgdaBound{xs}\AgdaSymbol) is \AgdaBound{nothing} only if \AgdaBound{xs} is unique.  Equivalently, one can say that the function proves that the result of appending an element \(x\) to a list \(xs\) is a unique list only if \(xs\) is a unique list.

\begin{code}
    pos-is-nothing-only-if-removal-is-nothing :
      {x : A} →
      {xs : List.List A} →
      pos (x List.∷ xs) ≡ nothing →
      pos xs ≡ nothing
    pos-is-nothing-only-if-removal-is-nothing {x} {List.[]} always = refl
    pos-is-nothing-only-if-removal-is-nothing {x} {y List.∷ ys} isNothing with NOTHINGNESS
      where
      NOTHINGNESS : Dec (pos (y List.∷ ys) ≡ nothing)
      NOTHINGNESS = Data.Maybe.Properties.≡-dec Fin._≟_ _ _
    ... | yes alreadyDone = alreadyDone
    ... | no bogus = contradiction isNothing (just-is-not-nothing isJust)
      where
      module _
        {a : Level}
        {A : Set a} where

        nonnothing-is-just : {x : Maybe A} → x ≢ nothing → Is-just x
        nonnothing-is-just {x = just x} notNothing = AnyMaybe.just _
        nonnothing-is-just {x = nothing} notNothing = contradiction refl notNothing

        just-is-not-nothing : {x : Maybe A} → Is-just x → x ≢ nothing
        just-is-not-nothing {x = just x} j ()

      isJust = nonunique-prepend x (y List.∷ ys) (nonnothing-is-just bogus)
\end{code}

\subsubsection{The Proof of Being Nothing}
\AgdaFunction{pos-of-unique-list-is-length} indicates that \AgdaFunction{firstRepeatPosition} \AgdaBound{x} is \AgdaInductiveConstructor{nothing} if all elements of \AgdaBound{x} are unique.

\begin{code}
    pos-of-unique-list-is-nothing :
      (x : List.List A) →
      UniqueList x →
      pos x ≡ nothing
    pos-of-unique-list-is-nothing List.[] u = refl
    pos-of-unique-list-is-nothing (x List.∷ xs) (u AllPairsList.∷ us) =
      unique-prepend-nothing u (pos-of-unique-list-is-nothing xs us)
      where
      unique-prepend-nothing :
        {x : A} →
        {xs : List.List A} →
        AllList.All (_≢_ x) xs →
        pos xs ≡ nothing →
        pos (x List.∷ xs) ≡ nothing
      unique-prepend-nothing AllList.[] refl = refl
      unique-prepend-nothing {x} xs@{x1 List.∷ xs1} alls eq with any? (DEQ x) xs
      ... | yes nonsense = contradiction nonsense (AllListProp.All¬⇒¬Any alls)
      ... | no obviously = begin
        pos (x List.∷ xs)
          ≡⟨ unique-element-prepend x xs alls ⟩
        Data.Maybe.map Fin.suc (pos xs)
          ≡⟨ cong (Data.Maybe.map Fin.suc) pos-xs-is-nothing ⟩
        nothing ∎
        where
        x1-is-not-in-xs1 : AllList.All (_≢_ x1) xs1
        x1-is-not-in-xs1 with pos-is-nothing-only-if-list-is-unique xs eq
        ... | (u AllPairsList.∷ us) = u
        pos-xs-is-nothing : pos xs ≡ nothing
        pos-xs-is-nothing =
          unique-prepend-nothing {x1} {xs1}
                                 x1-is-not-in-xs1
                                 (pos-is-nothing-only-if-removal-is-nothing {x1} {xs1} eq)
\end{code}

\subsubsection{The Proof of Equalling the Position of the First Repeating Value}
\AgdaFunction{pos-is-position-of-first-repeat} indicates that \AgdaFunction{firstRepeatPosition} \AgdaBound{x} contains the position of the first repeating value in \AgdaBound{x} if \AgdaBound{x} has such a value.

\begin{code}
    pos-is-position-of-first-repeat :
      (x : List.List A) →
      (i : Fin (List.length x)) →
      UniqueList (List.take (Fin.toℕ i) x) →
      List.lookup x i ∈ List.take (Fin.toℕ i) x →
      pos x ≡ just i
    pos-is-position-of-first-repeat = {!!}
\end{code}

\subsection{The Proof of the Noncontainment of Zero}
\AgdaFunction{pos-is-never-zero} indicates that for no \AgdaBound{x}, \AgdaFunction{pos} \AgdaBound{x} contains a zero value.

\begin{code}
    pos-is-never-zero :
      (x : List.List A) →
      Data.Maybe.map Fin.toℕ (pos x) ≢ just 0
    pos-is-never-zero List.[] ()
    pos-is-never-zero (x List.∷ List.[]) ()
    pos-is-never-zero (x List.∷ xs) = {!!}
\end{code}

\subsection{Exporting the Function}
``\AgdaFunction{firstRepeatPosition.firstRepeatPosition}'' is a bit long; as such, the author has elected to permit using the relatively short --- but still mildly verbose --- ``\AgdaFunction{firstRepeatPosition}''.  Praise be.

\begin{code}
firstRepeatPosition = firstRepeatPosition.firstRepeatPosition
\end{code}

\section{The Non-Repeating Subsequence Function}
\AgdaFunction{nonRepeatingPortion} \AgdaBound{DEQ} \AgdaBound{x} is the longest initial non-repeating subsequence within \AgdaBound{x}.  Equivalently, one can say that \AgdaFunction{nonRepeatingPortion} \AgdaBound{DEQ} \AgdaBound{x} is equivalent to \AgdaFunction{List.take} \AgdaBound{n} \AgdaBound{x}, where \AgdaBound{n} is such that \AgdaFunction{List.take} \AgdaBound{n} \AgdaBound{x} contains no two identical values.

\begin{code}
nonRepeatingPortion : {a : Level} →
                      {A : Set a} →
                      DecidableEquality A →
                      List.List A →
                      List.List A
nonRepeatingPortion DEQ x = List.take nonRepeatLength x
  where nonRepeatLength = maybe Fin.toℕ (List.length x) (firstRepeatPosition DEQ x)
\end{code}

\subsection{Properties of the Function}
This module contains a few proofs which indicates that \AgdaFunction{notRepeatingPortion} really \emph{is} as described.  For the sake of improving readability, the author has defined some module-specific variables and abbreviated functions.

\begin{code}
module nonRepeatingPortion-Properties
  {a : Level}
  {A : Set a}
  (DEQ : DecidableEquality A) where

  private
    nrp : List.List A → List.List A
    nrp = nonRepeatingPortion DEQ
\end{code}

\subsubsection{The Proof of Being the Result of Taking}
\AgdaFunction{is-first-n-elements} \AgdaBound{x} indicates that \AgdaFunction{nrp} \AgdaBound{x} is really just the list of the first \(n\) elements of \AgdaBound{x}, where \(n\) is \AgdaFunction{List.length} \AgdaSymbol(\AgdaFunction{nrp} \AgdaBound{x}\AgdaSymbol).

\begin{code}
  is-first-n-elements :
    (x : List.List A) →
    nrp x ≡ List.take (List.length (nrp x)) x
  is-first-n-elements = {!!}
\end{code}

\subsubsection{The Proof of Non-Repetition}
\AgdaFunction{contains-no-repeats} \AgdaBound{x} indicates that any two elements of \AgdaFunction{nrp} \AgdaBound{x} which are indexed by \AgdaBound{i} and \AgdaBound{j}, respectively, are equal only if \AgdaBound{i} is equal to \AgdaBound{j}.  Equivalently, one can say that \AgdaFunction{contains-no-repeats} \AgdaBound{x} indicates that \AgdaFunction{nrp} \AgdaBound{x} is actually a unique list, i.e., \emph{contains no repeats} of values.

\begin{code}
  contains-no-repeats :
    (x : List.List A) →
    (i1 i2 : Fin (List.length (nrp x))) →
    List.lookup (nrp x) i1 ≡ List.lookup (nrp x) i2 →
    i1 ≡ i2
  contains-no-repeats List.[] ()
  contains-no-repeats (x List.∷ xs) i1 i2 equality with i1 Data.Fin.≟ i2
  ... | yes alreadyEqual = alreadyEqual
  ... | no shouldNotBe = {!!}
\end{code}

\subsubsection{The Proof which Indicates that the Value Really is the Longest Unique Sublist}
\AgdaFunction{is-really-the-longest} \AgdaBound{x} indicates that any value which immediately follows \AgdaFunction{nrp} \AgdaBound{x}'s last element of \AgdaBound{x} is already contained within \AgdaBound{nrp} \AgdaBound{x}.

\begin{code}
  is-really-the-longest :
    (x : List.List A) →
    (i : Fin (List.length x)) →
    Fin.toℕ i ≡ 1 Data.Nat.+ List.length (nrp x) →
    AnyList.Any (λ i2 → i2 ≡ List.lookup x i) (nrp x)
  is-really-the-longest = {!!}
\end{code}

\subsubsection{The Proof of Emptiness}
\AgdaFunction{only-empty-if-input-is-empty} indicates that for all lists \AgdaBound{x}, \AgdaFunction{nrp} \AgdaBound{x} is empty only if \AgdaBound{x} is empty.

\begin{code}
  only-empty-if-input-is-empty :
    (x : List.List A) →
    List.length (nrp x) ≡ 0 →
    List.length x ≡ 0
  only-empty-if-input-is-empty List.[] refl = refl
  only-empty-if-input-is-empty (x List.∷ xs) empty = contradiction empty {!!}
\end{code}

\subsubsection{The \emph{Other} Emptiness Proof}
\AgdaFunction{empty-inputs-beget-empty-outputs} indicates that the result of applying \AgdaFunction{nrp} to an empty list is just an empty list.

\begin{code}
  empty-inputs-beget-empty-outputs :
    (x : List.List A) →
    List.length x ≡ 0 →
    List.length (nrp x) ≡ 0
  empty-inputs-beget-empty-outputs List.[] refl = refl
\end{code}

\begin{code}
  nrp-of-concatenated-lists :
    (x y : List.List A) →
    nrp (x List.++ y) ≡ {!!}
  nrp-of-concatenated-lists = {!!}
\end{code}

\subsubsection{The Appending Proof}
\AgdaFunction{new-values-are-appended} indicates that if \AgdaBound{x} does not appear in \AgdaBound{xs}, then \AgdaFunction{nrp} \AgdaSymbol(\AgdaBound{xs} \AgdaOperator{\AgdaFunction{List.++}} \AgdaOperator{\AgdaFunction{List.[}} \AgdaBound{x} \AgdaOperator{\AgdaFunction{]}} is structurally identical to \AgdaFunction{nrp} \AgdaBound{xs} \AgdaOperator{\AgdaFunction{List.++}} \AgdaOperator{\AgdaFunction{List.[}} \AgdaBound{x} \AgdaOperator{\AgdaFunction{]}}.  More intuitively, one can say that new values which are appended to the input of \AgdaFunction{nrp} are \emph{also} appended to the output of \AgdaFunction{nrp}.

\begin{code}
  new-values-are-appended :
    (x : A) →
    (xs : List.List A) →
    x ∉ xs →
    nrp (xs List.++ List.[ x ]) ≡ nrp xs List.++ List.[ x ]
  new-values-are-appended x List.[] notElement = refl
  new-values-are-appended x (xs1 List.∷ xs) notElement = {!!}
\end{code}

\chapter{The Computer Algebra System Types}

\section{The Type of Mostly-Unverified Computer Algebra Systems}
Fundamentally, a computer algebra system for an expression type \(\epsilon\) can be thought of as being a combination of the following:

\begin{itemize}
  \item an algebraic equality type,
  \item an algebraic less-than type,
  \item an algebraic less-than-or-equal-to type,
  \item a single-step evaluation function which is capable of describing failures,
  \item a proof of decidable structural equality of \(\epsilon\) values,
  \item a function which determines certain algebraic equality on non-bogus \(\epsilon\) values,
  \item a function which determines certain inequality on non-bogus \(\epsilon\) values,
  \item a function which converts natural number values into \(\epsilon\) values,
  \item a function which converts the name of a variable into an \(\epsilon\) variable value,
  \item a function which converts the two input expressions into a representation of the sum of the input expressions,
  \item a function which converts the two input expressions into a representation of the quotient of the input expressions,
  \item a function which converts the two input expressions \(a\) and \(b\) into \(a^b\),
  \item the six trigonometric functions, i.e., the sine function, the cosine function, the tangent function, the cosecant function, the secant function, and the cotangent function,
  \item a derivative function,
  \item an antiderivative function,
  \item a limit function,
  \item a bounded integral function,
  \item a variable substitution function,
  \item a function which converts the input into the additive inverse of the input,
  \item a lambda expression function,
  \item a variable-is-used type,
  \item an expression-is-real type,
  \item an expression-is-imaginary type,
  \item an expression-is-valid-constant type,
  \item a proof which indicates that for any two natural numbers \(n_1\) and \(n_2\), if \(n_1 \neq n_2\), then the representation of \(n_1\) is not equal to the representation of \(n_2\),
  \item a proof which indicates that variables of different names are not equivalent,
  \item a function which performs the maximum number of evaluation steps on the input,
  \item a function which displays all evaluation steps which are used on a given input, and
  \item some other functions which are really only terribly useful for verification.
\end{itemize}

\AgdaDatatype{CAS} is the type of such computer algebra systems.

\subsection{The Algebraic Equality Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}≈\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is shown to be algebraically equal to \AgdaBound{y}.

\subsection{The Algebraic \emph{In}equality Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}≉\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is algebraically \emph{un}equal to \AgdaBound{y}.

\subsection{The Less-Than Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}<\AgdaUnderscore{}} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is less than \AgdaBound{y}.

\subsection{The Less-Than-or-Equal-to Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}≤\AgdaUnderscore{}} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is less than or equal to \AgdaBound{y}.

\subsection{The Single-Step Evaluation Function}
If such a step is possible, then the single-step evaluation function, which is represented in \AgdaDatatype{CAS} records as some \AgdaField{exceptionallyEvaluate} field, performs a single evaluation step on the input.  If no such step is possible, but the input is not bogus, then the output just contains the input.  If the input is bogus, then the output contains a description of the bogusness.

For the purposes of this document, an ``evaluation step'' is the application of a basic operation, e.g., addition or commuting the arguments of a function.  More formally, one can say that an evaluation step is the application of an operation which cannot be further simplified or decomposed into simpler operations.

\subsection{The Proof of Structural Equality}
This one, which is represented via the \AgdaField{structuralEquality} field, should be simple enough for anyone who is familiar with \AgdaFunction{DecidableEquality}.

\subsection{The Semi-Decidable Algebraic Equality Function}
Assuming that the function is defined such that iteration counts \emph{are actually meaningful}, \AgdaField{CAS.definitelyEquals} \AgdaBound{c} \AgdaBound{i} \AgdaBound{x} \AgdaBound{y} is some value \AgdaInductiveConstructor{inj₂} \AgdaSymbol(\AgdaInductiveConstructor{just} \AgdaBound{equality}\AgdaSymbol) if and only if the \AgdaField{CAS.definitelyEquals} function finds an appropriate value within \AgdaBound{i} iterations.  The \AgdaField{CAS.definitelyEquals} value is \AgdaInductiveConstructor{inj₂} \AgdaInductiveConstructor{nothing} if and only if the function cannot discover an appropriate proof of equality.  The function encounters an exceptional situation if and only if the \AgdaField{CAS.definitelyEquals} value is \AgdaInductiveConstructor{inj₁} \AgdaBound{e}, where \AgdaBound{e} is a description of the exception.

\subsection{The Semi-Decidable Less-Than Function}
Assuming that the relevant function actually \emph{considers} iteration counts, \AgdaField{CAS.definitelyEquals} \AgdaBound{c} \AgdaBound{i} \AgdaBound{x} \AgdaBound{y} is some value \AgdaInductiveConstructor{inj₂} \AgdaSymbol(\AgdaInductiveConstructor{just} \AgdaBound{lessThan}\AgdaSymbol) if and only if the \AgdaField{CAS.isDefinitelyLessThan} function finds an appropriate value.  The \AgdaField{CAS.isDefinitelyLessThan} value is \AgdaInductiveConstructor{inj₂} \AgdaInductiveConstructor{nothing} if and only if the function cannot discover an appropriate inequality proof.  The function encounters an exceptional situation if and only if the \AgdaField{CAS.isDefinitelyLessThan} is \AgdaInductiveConstructor{inj₁} \AgdaBound{e}, where \AgdaBound{e} is a description of the exception.

\subsection{The Natural-to-Expression Function}
The author thinks that any computer algebra system which is worthy of being given the time of day can represent natural numbers --- after all, the time of day can be represented \emph{as} a natural number!  Anyway, \AgdaField{fromℕ} indicates that a mapping from the natural numbers to the expression type of the given computer algebra system exists.

\subsection{The Variable Function}
Does a computer algebra system which lacks support for variables even qualify as being a computer algebra system?  The author is doubtful.  Anyway, \AgdaField{CAS.variableNamed} \AgdaBound{c} \AgdaBound{name} is \AgdaBound{c}'s representation of the variable whose name is \AgdaBound{name}.

\subsection{The Sum Function}
Any half-decent CAS is capable of representing the unevaluated sum of two expressions.  Accordingly, \AgdaField{\AgdaUnderscore{}+\AgdaUnderscore{}} values are unevaluated sum functions.  More formally, \AgdaField{CAS.\AgdaUnderscore{}+\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated sum of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Difference Function}
Any half-decent CAS can represent the difference of two given expressions, too.  Accordingly, \AgdaField{\AgdaUnderscore{}-\AgdaUnderscore{}} values are unevaluated differences.  More formally, \AgdaField{CAS.\AgdaUnderscore{}-\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated difference of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Product Function}
A decent CAS can represent the unevaluated product of two expressions.  Accordingly, \AgdaField{\AgdaUnderscore{}*\AgdaUnderscore{}} values represent unevaluated products.  More formally, one can say that \AgdaField{CAS.\AgdaUnderscore{}*\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated product of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Quotient Function}
Any \emph{good} CAS can \emph{also} represent the unevaluated quotient of two expressions.  Accordingly, \AgdaField{\AgdaUnderscore{}/\AgdaUnderscore{}} values are unevaluated quotient functions.  More formally, \AgdaField{CAS.\AgdaUnderscore{}/\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the unevaluated quotient of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Exponent Function}
The author is tired of the boilerplate nonsense.  \AgdaField{CAS.\AgdaUnderscore{}\textasciicircum\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of \AgdaBound{x} to the power of \AgdaBound{y}.

\subsection{The Trigonometric Functions}
As previously indicated, a CAS also supports certain trigonometric functions.  To prevent using too terribly many \texttt{subsection} declarations, the author uses an \texttt{itemize} environment to describe the relevant functions as follows:

\newcommand\boilerplateTrigDef[2]{\AgdaField{CAS.#1} \AgdaBound{c} \AgdaBound{x} is the \AgdaBound{c} CAS's representation of the application of the #2 function to \AgdaBound{x}.}

\begin{itemize}
  \item \boilerplateTrigDef{sin}{sine}
  \item \boilerplateTrigDef{cos}{cosine}
  \item \boilerplateTrigDef{tan}{tangent}
  \item \boilerplateTrigDef{csc}{cosecant}
  \item \boilerplateTrigDef{sec}{secant}
  \item \boilerplateTrigDef{cot}{cotangent}
\end{itemize}

\subsection{The Derivative Function}
\AgdaField{CAS.derivative} \AgdaBound{c} \AgdaBound{name} \AgdaBound{e} represents the derivative of \AgdaBound{e} with respect to the variable whose name is \AgdaBound{name}.

\subsection{The Antiderivative Function}
\AgdaField{CAS.antiderivative} \AgdaBound{c} \AgdaBound{name} \AgdaBound{e} represents the antiderivative of \AgdaBound{e} with regard to the variable whose name is \AgdaBound{name}.

\subsection{The Additive Inverse Function}
\AgdaField{CAS.negation} \AgdaBound{c} \AgdaBound{x} is the additive inverse of \AgdaBound{x}.

\subsection{The Simple Limit Function}
\AgdaField{CAS.limit} \AgdaBound{c} \AgdaBound{x} \AgdaBound{c} \AgdaBound{e} is \AgdaBound{c}'s representation of \(\lim_{\AgdaBound{c} \rightarrow \AgdaBound{x}} \textrm{\Epsilon}\), where ``\(\textrm{\Epsilon}\)'' denotes the expanded version of the \AgdaBound{e} expression.

\subsection{The Bounded Integral Function}
\AgdaField{CAS.boundedIntegral} \AgdaBound{c} \AgdaBound{name} \AgdaBound{b1} \AgdaBound{b2} \AgdaBound{e} is \AgdaBound{c}'s representation of \(\int_{\AgdaBound{name}=\AgdaBound{b1}}^{\AgdaBound{b2}} \mathrm{\Epsilon}\), where ``\(\mathrm{\Epsilon}\)'' denotes the expansion of \AgdaBound{e}.

\subsection{The Variable Substitution Function}
\AgdaField{CAS.substituteVariable} \AgdaBound{c} is the variable substitution function for the \AgdaBound{c} CAS.\footnote{You don't say.}
In short, \AgdaField{CAS.substituteVariable} \AgdaBound{c} \AgdaBound{list} \AgdaBound{e} is a version of \AgdaBound{e} such that for all \AgdaSymbol(\AgdaBound{variableName} \AgdaOperator{\AgdaInductiveConstructor{,}} \AgdaBound{replacement}\AgdaSymbol) in \AgdaBound{list}, all of \AgdaBound{e}'s free instances of \AgdaField{CAS.variableNamed} \AgdaBound{variableName} have been replaced by \AgdaBound{replacement}.  \AgdaField{CAS.substituteVariable} \AgdaBound{c} \AgdaBound{list} \AgdaBound{e} is otherwise equivalent to \AgdaBound{e}, though.

\subsection{The Variable Containment Type}
The variable whose name is \AgdaBound{name} is free in \AgdaBound{e} with regard to \AgdaBound{c} if and only if a value of type \AgdaFunction{CAS.IsNameOfVariableIn} \AgdaBound{c} \AgdaBound{name} \AgdaBound{e}.

\subsection{The Realness Type}
\AgdaBound{e} represents a real number with regard to \AgdaBound{c} if and only if there exists a value of type \AgdaField{CAS.IsReal} \AgdaBound{c} \AgdaBound{e}.

\subsection{The Complexity Type}
\AgdaBound{e} represents an imaginary number with regard to \AgdaBound{c} if and only if there exists a value of type \AgdaField{CAS.IsImaginary} \AgdaBound{c} \AgdaBound{e}.

\subsection{The Constant Type}
\AgdaBound{e} represents a constant with regard to \AgdaBound{c} if and only if there exists a value of type \AgdaField{CAS.IsConstant} \AgdaBound{c} \AgdaBound{e}.

\subsection{The Lambda Expression Function}
\AgdaField{CAS.lambda} \AgdaBound{c} \AgdaBound{name} \AgdaBound{expression} \AgdaBound{value} represents the application to \AgdaBound{value} of the lambda expression whose bound variable's name is \AgdaBound{name} and whose expression is \AgdaBound{expression}.  Equivalently, one can say that \AgdaField{CAS.lambda} \AgdaBound{c} \AgdaBound{name} \AgdaBound{M} \AgdaBound{value} is equivalent to \(\left(\lambda\ \AgdaBound{name} \rightarrow \AgdaBound{M}\right)\ \AgdaBound{value}\).

\subsection{The \(\tau\) Value}
\AgdaField{CAS.τ} \AgdaBound{c} is the \AgdaBound{c} CAS's representation of \(\tau\), i.e., the angular measure of a circle.

\subsection{The Natural Number Proofs}
In addition to the basic mapping, proofs of the following attributes should exist:

\begin{itemize}
  \item Any two natural numbers differ only if the CAS's representations of the numbers differ.
\end{itemize}

\subsection{The Proof which Indicates that Variables of Different Names are Decidedly Not Equivalent}
Operations on variables are only sensible if confusing variables is forbidden, i.e., variables of different names are represented differently.  Accordingly, \AgdaField{CAS.differently-named-variables-are-different} \AgdaBound{c} indicates that within \AgdaBound{c}, given any two variables \(x\) and \(y\), if the name of \(x\) differs from the name of \(y\), then \AgdaBound{c}'s representations of \(x\) and \(y\) differ.

\subsection{The Tracing Recursive Evaluation Function}
A compliant CAS also has a function which performs the specified number of non-repeating simplification steps on the input, returning a list all steps which were taken to get the output, regardless of whether or not the output is an exception.  In \AgdaDatatype{CAS} records, this function is represented through \AgdaField{traceEvaluate}.

\subsection{The Non-Tracing Maximum Evaluation Function}
A compliant CAS also has a function which performs the specified number of non-repeating simplification steps on the input but just returns the resulting exception or expression.  In \AgdaDatatype{CAS} records, this function is represented through \AgdaField{rEvaluate}.

\subsection{The Iteration Equality Function}
A value of type \AgdaField{CAS.equal-at-iteration} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e1} \AgdaBound{e2} exists if and only if \AgdaField{CAS.definitelyEquals} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e1} \AgdaBound{e2} indicates that \AgdaBound{e1} is algebraically equal to \AgdaBound{e2}.  This function mostly exists to eliminate repetition.

\subsection{The Generic Iteration Equality Function}
A value of type \AgdaField{CAS.equal-at-some-iteration} \AgdaBound{c} \AgdaBound{e1} \AgdaBound{e2} exists if and only if \AgdaField{CAS.definitelyEquals} \AgdaBound{c} can determine that \AgdaBound{e1} is algebraically equal to \AgdaBound{e2} at some iteration.  Again, this function is really just good for reducing nasty redundancy.

\subsection{The Equality Step Function}
\AgdaField{CAS.equality-at-n-implies-equality-at-n+1} proves that two expressions are definitely equal at a given iteration only if these same expressions are also definitely equal at the following iteration.

\subsection{The Iteration Bogosity Function}
A value of type \AgdaField{CAS.bogus-at-iteration} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e} exists if and only if \AgdaField{CAS.rEvaluate} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e} is an \AgdaInductiveConstructor{inj₂} value.

\subsection{The Generic Iteration Bogosity Function}
A value of type \AgdaField{CAS.bogus-at-some-iteration} \AgdaBound{c} \AgdaBound{e} exists if and only if \AgdaField{CAS.rEvaluate} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e} is an \AgdaInductiveConstructor{inj₂} value for some \AgdaBound{iterations}.

\subsection{The Bogosity Step Function}
\AgdaField{CAS.bogosity-at-n-implies-bogosity-at-n+1} proves that a given expression is bogus at some iteration only if the same expression is bogus at the following iteration.

\subsection{The Non-Bogus Type}
This type, in addition to not being bogus, is used to indicate that the relevant expression is not bogus.  More formally, a value of type \AgdaField{CAS.IsNotBogus} \AgdaBound{c} \AgdaBound{e} exists if and only if \AgdaBound{e} is bogus with regard to \AgdaField{CAS.rEvaluate} \AgdaBound{c} at no iteration, i.e., \AgdaField{CAS.rEvaluate} \AgdaBound{c} \AgdaBound{n} \AgdaBound{e} is non-bogus for all \AgdaBound{n}.

\subsection{The Bogus Type}
This type is not bogus but \emph{is} used to indicate that a given expression is bogus.  More formally, one can say that a value of type \AgdaField{CAS.IsBogus} \AgdaBound{c} \AgdaBound{e} exists if and only if \AgdaBound{e} is bogus with regard to \AgdaField{CAS.rEvaluate} \AgdaBound{c} at some iteration.

\subsection{The Definition Proper}

\begin{code}
record CAS {a : Level} (ε : Set a) : Set (Level.suc a) where
  field
    _≈_ : ε → ε → Set a
    _<_ : ε → ε → Set a
    definitelyEquals : (iterations : ℕ) →
                       (x y : ε) →
                       Exceptional (Maybe (x ≈ y))
    isDefinitelyLessThan : (iterations : ℕ) →
                           (x y : ε) →
                           Exceptional (Maybe (x < y))
    exceptionallyEvaluate : ε → Exceptional ε
    structuralEquality : DecidableEquality ε
    fromℕ : ℕ → ε
    variableNamed : String → ε
    _+_
     _-_
     _*_
     _/_
     _^_ : ε → ε → ε
    negation : ε → ε
    sin
     cos
     tan
     csc
     sec
     cot : ε → ε
    derivative
     antiderivative : String → ε → ε
    limit : String → ε → ε → ε
    boundedIntegral : String → ε → ε → ε → ε
    substituteVariables : List.List (String × ε) → ε → ε
    IsNameOfVariableIn : String → ε → Set
    IsReal : ε → Set
    lambda : String → ε → ε → ε
    τ : ε
    different-if-nats-are-different :
      {n1 n2 : ℕ} → n1 ≢ n2 → fromℕ n1 ≢ fromℕ n2
    differently-named-variables-are-different :
      (name1 name2 : String) →
      name1 ≢ name2 →
      variableNamed name1 ≢ variableNamed name2

  IsConstant : ε → Set
  IsConstant e = (name : String) → ¬ IsNameOfVariableIn name e

  rEvaluate : ℕ → ε → Exceptional ε
  rEvaluate 0 e = inj₂ e
  rEvaluate (ℕ.suc n) e = [_,_] inj₁ exceptionallyEvaluate (rEvaluate n e)

  traceEvaluate : ℕ → ε → List.List (Exceptional ε)
  traceEvaluate n e =
    nonRepeatingPortion decFun (List.map (flip rEvaluate e) (List.upTo (ℕ.suc n)))
      where decFun = Data.Sum.Properties.≡-dec Data.String._≟_ structuralEquality

  module EqualityVerificationParts where
    inj2s : List.List (Exceptional ε) → List.List ε
    inj2s (inj₂ e List.∷ es) = e List.∷ inj2s es
    inj2s (inj₁ e List.∷ es) = inj2s es
    inj2s List.[] = List.[]

    evaluationPairs : ℕ → ε → ε → List.List (ε × ε)
    evaluationPairs i = List.cartesianProduct on inj2s ∘ traceEvaluate i

    module ProofsOfCorrectness
      (i : ℕ)
      (e1 e2 : ε) where

      evp = evaluationPairs i e1 e2

      length-of-pairlist-is-suc : Σ ℕ (λ n → ℕ.suc n ≡ List.length evp)
      length-of-pairlist-is-suc = {!!}

      first-pair-index = Data.Fin.cast (proj₂ length-of-pairlist-is-suc) Fin.zero

      inputs-are-first-evaluation-pair :
        (e1 , e2) ≡ List.lookup evp first-pair-index
      inputs-are-first-evaluation-pair = {!!}

  open EqualityVerificationParts

  module InternalEqualityFunctions where
    _≡₂_ : Exceptional ε → Exceptional ε → Set a
    (inj₂ x) ≡₂ (inj₂ y) = x ≡ y
    x ≡₂ y = ⊥

    _≟₂_ : (x y : Exceptional ε) → Dec (x ≡₂ y)
    (inj₂ x) ≟₂ (inj₂ y) = structuralEquality x y
    (inj₁ x) ≟₂ (inj₂ y) = no (λ ())
    (inj₁ x) ≟₂ (inj₁ y) = no (λ ())
    (inj₂ x) ≟₂ (inj₁ y) = no (λ ())

  open InternalEqualityFunctions

  _≉_ : ε → ε → Set a
  x ≉ y = (iterations : ℕ) → ¬ x ≈ y

  _≤_ : ε → ε → Set a
  x ≤ y = (x < y) ⊎ (x ≈ y)

  equal-at-iteration : ℕ → (e1 e2 : ε) → Set a
  equal-at-iteration iterations e1 e2 =
    Σ (e1 ≈ e2)
      (λ i → inj₂ (just i) ≡ definitelyEquals iterations e1 e2)

  equal-at-some-iteration : (e1 e2 : ε) → Set a
  equal-at-some-iteration e1 e2 = Σ ℕ (λ n → equal-at-iteration n e1 e2)

  equality-at-n-implies-equality-at-n+1 :
    (iterations : ℕ) →
    (e1 e2 : ε) →
    equal-at-iteration iterations e1 e2 →
    equal-at-iteration (ℕ.suc iterations) e1 e2
  equality-at-n-implies-equality-at-n+1 = {!!}

  bogus-at-iteration : ℕ → ε → Set a
  bogus-at-iteration n e = Σ String (λ ex → inj₁ ex ≡ rEvaluate n e)

  bogus-at-some-iteration : ε → Set a
  bogus-at-some-iteration = Σ ℕ ∘ flip bogus-at-iteration

  bogosity-at-n-implies-bogosity-at-n+1 :
    (iterations : ℕ) →
    (e : ε) →
    bogus-at-iteration iterations e →
    bogus-at-iteration (ℕ.suc iterations) e
  bogosity-at-n-implies-bogosity-at-n+1 iter e (exc , bogosity) =
    exc , trans bogosity (sym eEquality)
    where
    eEquality : rEvaluate (ℕ.suc iter) e ≡ rEvaluate iter e
    eEquality = begin
      rEvaluate (ℕ.suc iter) e
        ≡⟨⟩
      [_,_]′ inj₁ exceptionallyEvaluate (rEvaluate iter e)
        ≡⟨ cong ([_,_] inj₁ exceptionallyEvaluate) (sym bogosity) ⟩
      inj₁ exc
        ≡⟨ bogosity ⟩
      rEvaluate iter e ∎

  IsNotBogus : ε → Set a
  IsNotBogus e = (n : ℕ) → Is-just (isInj₂ (rEvaluate n e))

  IsBogus : ε → Set a
  IsBogus e = Σ ℕ (λ n → Σ String (λ s → rEvaluate n e ≡ inj₁ s))

  IsImaginary : ε → Set a
  IsImaginary e = IsReal e × IsNotBogus e
\end{code}

\section{The Type of Verified Computer Algebra Systems}
For the purposes of this document, a verified computer algebra system is the combination of a \AgdaRecord{CAS} computer algebra system \(c\) \emph{and} some guarantees about \(c\).  The non-\AgdaRecord{CAS} parts of the combination are as follows:

\begin{itemize}
 \item a proof which indicates that the algebraic equality relation is an equaivalence relation,
 \item a proof which indicates that two values are structurally equivalent only if these same values are also algebraically equal,
 \item a proof which indicates that variables of different names are not definitely equal,
 \item a proof which indicates that two variables which have the same name are algebraically equal,
 \item a proof which indicates that for any two integers \(n_1\) and \(n_2\), the sum of the representations of \(n_1\) and \(n_2\) is the representation of \(n_1 + n_2\),
 \item a proof which indicates that the product of any non-bogus element \(e\) of type \AgdaBound{ε} and one is \(e\),
 \item a proof of commutativity of addition,
 \item a proof of commutativity of multiplication,
 \item a proof of associativity of addition,
 \item a proof of the inverse relationship between multiplication and division,
 \item a proof of the bogosity of \(0^0\),
 \item a proof of the bogosity of \(0^e\), where \(e < 0\),
 \item a proof which indicates that \(\lim_{x \rightarrow n} e\) is algebraically equal to \(n\) if \(x\) is not referenced in \(e\),
 \item a proof of the algebraic equality between \(\left(\lambda\ x \rightarrow x\right)\ e\) and \(e\),
 \item a proof which indicates that \(\left(\lambda\ x \rightarrow y\right)\ e\) is algebraically equal to \(y\) if \(x\) is not referenced in \(y\),
 \item a proof which indicates that if \(n\) does not appear in \(E\), then the \(n\)-derivative of \(E\) is equal to \(E\),
 \item a proof of \(0\)'s equality with \(\tau \cdot n \cdot \frac12\),
 \item a proof of the failure of garbage variable substitution\footnote{See \fref{fn:garbageVariable}.},
 \item a proof of the irrelevance of substitution list order,
 \item a proof which indicates that the derivative of a constant is \(0\),
 \item basic trigonometric derivative correctness proofs, and
 \item a proof of the algebraic equality between \(\derivative{x} \left(e_1 + e_2\right)\) and \(\derivative{x} e_1 + \derivative{x} e_2\).
\end{itemize}

\subsection{The Proof of the Equivalence Nature of the Algebraic Equality Relation}
A good CAS represents the complex numbers, whose equality relation is an equivalence relation.  Accordingly, a verified CAS's algebraic equality relation should be an equivalence relation.  \AgdaField{equality-is-equivance} values indicate that the algebraic equality relations actually are equivalence relations.

\subsection{The Structural-Equivalence-to-Algebraic-Equality Function}
Also, in a good CAS, two expressions \(e_1\) and \(e_2\) are represented in the same way only if \(e_1\) is algebraically equal to \(e_2\).  This fact is represented through the use of \AgdaField{structural-equality-implies-definite-equality}.

\subsection{The Proof which Indicates that Values of Different Names are Not ``Definitely Equal''}
Any two given variables are not necessarily equal.  Accordingly, \AgdaField{VCAS.differently-named-variables-are-not-definitely-equal} \AgdaBound{c} indicates that within the \AgdaBound{c} CAS, given any two \AgdaBound{c} variables \(x\) and \(y\), if the name of \(x\) differs from the name of \(y\), then \(x\) is not definitely equal to \(y\).

\subsection{The Proof which Indicates that Variables of Identical Names are Algebraically Equal}
Also, options on variables are only sensible if for all variables \(x\) and \(y\), if the name of \(x\) is also the name of \(y\), then \(x\) is algebraically equal to \(y\).  Accordingly, \AgdaField{VCAS.identically-named-variables-are-equal} \AgdaBound{c} indicates that for any \AgdaBound{c}-CAS variables \(x\) and \(y\), if the name of \(x\) is identical to the name of \(y\), then \AgdaBound{c} can determine that \(x\) is algebraically equal to \(y\).

\subsection{The Natural Number Sum Field}
Another aspect of a good computer algebra system is the correct calculation of sums of natural numbers.  Intuition dictates that in a good computer algebra system, the sum of two natural numbers should be the sum of the same two natural numbers.  However, as indicated by \AgdaField{CAS.fromℕ}, many computer algebra systems do not just work with natural numbers; accordingly, natural number arithmetic may accidentally be implemented incorrectly.  To prevent such incorrect implementations, correct calculation of natural number sums is ensured through \AgdaField{sum-of-nats-is-nat-sum} values, which are proofs which indicate that the corresponding computer algebra systems' natural number addition functions are defined correctly.

\subsection{The Non-Bogus Sum Field}
\AgdaField{VCAS.sum-is-not-bogus} indicates that for any given non-bogus values \AgdaBound{e1} and \AgdaBound{e2}, the sum of \AgdaBound{e1} and \AgdaBound{e2} is not bogus.

\subsection{The 1-Product Field}
\AgdaField{VCAS.product-of-e-and-1-is-e} \AgdaBound{c} indicates that for any non-bogus value \(e\) of the expression type for \AgdaBound{c}, the product of \(e\) and one is equal to \(e\).

\subsection{The Bogus Division Field}
That the quotient of any given number and zero is bogus, i.e., undefined, is well-known.  This fact --- the bogusness, not being well-known --- is represented through \AgdaField{VCAS.division-by-zero-is-bogus}.

\subsection{The Proof of Commutativity of Addition}
\AgdaField{VCAS.sum-is-commutative} indicates that addition is commutative in the relvant CAS.  More formally, \AgdaField{VCAS.sum-is-commutative} \AgdaBound{c} indicates that for any appropriate expression values \AgdaBound{e1} and \AgdaBound{e2}, some \AgdaBound{n} exists such that there exists a value of type \AgdaBound{CAS.equal-at-iteration} \AgdaBound{c2} \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}+\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e1} \AgdaBound{e2}\AgdaSymbol) \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}+\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e2} \AgdaBound{e1}\AgdaSymbol), where \AgdaBound{c2} is the CAS record which is verified by \AgdaBound{c}.

\subsection{The Proof of Commutativity of Multiplication}
\AgdaField{VCAS.product-is-commutative} indicates that multiplication is commutative in the relvant CAS.  More formally, \AgdaField{VCAS.product-is-commutative} \AgdaBound{c} indicates that for any appropriate expression values \AgdaBound{e1} and \AgdaBound{e2}, some \AgdaBound{n} exists such that a value of type \AgdaBound{CAS.equal-at-iteration} \AgdaBound{c2} \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}*\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e1} \AgdaBound{e2}\AgdaSymbol) \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}*\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e2} \AgdaBound{e1}\AgdaSymbol), where \AgdaBound{c2} is the CAS record which is verified by \AgdaBound{c}.

\subsection{The Proof of Associativity of Addition}
\AgdaField{VCAS.sum-is-commutative} indicates that addition is commutative in the relvant CAS.  More formally, \AgdaField{VCAS.sum-is-commutative} \AgdaBound{c} indicates that for any appropriate expression values \AgdaBound{e1} and \AgdaBound{e2}, some \AgdaBound{n} exists such that there exists a value of type \AgdaBound{CAS.equal-at-iteration} \AgdaBound{c2} \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}+\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e1} \AgdaBound{e2}\AgdaSymbol) \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}+\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e2} \AgdaBound{e1}\AgdaSymbol), where \AgdaBound{c2} is the CAS record which is verified by \AgdaBound{c}.


\subsection{The Proof of the Inverse Relationship between Multiplication and Division}
\AgdaField{VCAS.product-of-quotient-is-same} indicates that for the appropriate CAS, multiplication is the inverse of division.  More formally, \AgdaField{product-of-quotient-is-same} \AgdaBound{c} indicates that for all appropriate expression values \AgdaBound{e1} and \AgdaBound{e2}, \AgdaBound{e2} is equal to the \AgdaBound{c} CAS product of \AgdaBound{e1} and the \AgdaBound{c} CAS quotient of \AgdaBound{e2} and \AgdaBound{e1}.

\subsection{The Proof of the Bogosity of \(0^0\)}
\AgdaField{VCAS.0\textasciicircum{}0-is-bogus} \AgdaBound{c} indicates that in the \AgdaBound{c} CAS, \(0^0\) is bogus at some iteration count.

\subsection{The Proof of the Bogosity of \(0^e\), where \(e < 0\)}
\AgdaField{VCAS.0\textasciicircum{}-n-is-bogus} \AgdaBound{v} indicates that for all relevant expressions \(e\), if \(e < 0\), then the CAS will eventually determine that \(0^e\) is bogus.

\subsection{The Proof of the Futility of Taking the Limit of an Expression which does Not Use the Named Variable}
\AgdaField{limit-of-unrelated-value-is-unrelated-value} \AgdaBound{v} indicates that in the \AgdaBound{v} CAS, if \(x\) is not used in \(e\), then \(\lim_{x \rightarrow b} e\) is equivalent to \(e\) for all \(b\), \(e\), and \(x\).

\subsection{The Proof which Indicates that Simple Lambda Substitution Works}
\AgdaField{VCAS.simple-lambda-substitution-works} \AgdaBound{v} indicates that, at some iteration, the \AgdaBound{v} CAS can determine that the \AgdaBound{v} CAS's representation of \(\left(\lambda\ v \rightarrow v\right) e\) is algebrically equal to the \AgdaBound{v} CAS's representation of \(e\).

\subsection{The Proof of the Futility of Applying a Lambda Expression whose Bound Variable is Unused}
For all relevant \(v\), \(M\), and \(e\), if \(v\) is not referenced in \(M\), then \(\left(\lambda\ v \rightarrow M\right)\ e = M\).  The preceding fact is encoded through \AgdaField{VCAS.unapplicable-lambda-returns-lambda-body}.

\subsection{The Unrelated Derivative Proof}
\AgdaField{VCAS.unrelated-derivative} \AgdaBound{v} indicates that for all appropriate \AgdaBound{v} CAS expressions \(E\) and all appropriate \(n\), if the variable whose name is \(n\) does not appear in \(E\), then the \AgdaBound{v} CAS can determine that \(E\) is algebraically equal to the derivative of \AgdaBound{E} with respect to the variable whose name is \(n\).

\subsection{The Proof of the Equality of \(\operatorname{sin} \left(\tau \cdot n \cdot \frac12\right)\), where \(n\) is a Natural Number}
\AgdaField{VCAS.sin-n*pi-is-zero} \AgdaBound{v} proves that the \AgdaBound{v} CAS can determine that for all natural numbers \(n\), the sine of \(\tau \cdot n \cdot \frac12\), i.e., \(\pi \cdot n\), is algebraically equal to \(0\).

\subsection{The Proof of the Failure of Garbage Variable Substitution\footnote{``Garbage'' affects ``Variable Substitution'', although ``garbage variable'' \emph{could} \emph{also} apply\ldots\label{fn:garbageVariable}}}
\AgdaField{VCAS.garbage-variable-substitution-fails} \AgdaBound{v} proves that the \AgdaBound{v} CAS's variable substitution effectively returns the input expression if no variables of the substitution list are free in the input expression.

\subsection{The Proof of the Irrelevance of the Order of Substitution Lists}
\AgdaField{VCAS.substitution-order-is-irrelevant} \AgdaBound{v} proves that for the \AgdaBound{v} CAS, if some substitution list \(l_1\) is a permutation of some substitution list \(l_2\) and contains no repeated variable names, then the application of \(l_1\) to some expression \(e\) is algebraically equal to the application of \(l_2\) to \(e\).

\subsection{The Constant Derivative Proof}
\AgdaField{VCAS.derivative-of-constant} \AgdaBound{v} proves that the \AgdaBound{v} CAS can correctly determine that the derivative of any constant with regard to any variable is \(0\).

\subsection{Basic Trigonometric Derivative Correctness Proofs}
We ain't done yet, folks!  Additional fields include the basic trigonometric derivative correctness proof fields, which are fields for proofs of the correctness of the evaluation of derivatives of basic trigonometric functions.

\subsubsection{The Sine Derivative Proof}
\AgdaField{VCAS.derivative-of-sine} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\sin x\) with respect to \(x\) is \(\cos x\).

\subsubsection{The Cosine Derivative Proof}
\AgdaField{VCAS.derivative-of-cosine} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\cos x\) with respect to \(x\) is \(- \sin x\).

\subsubsection{The Tangent Derivative Proof}
\AgdaField{VCAS.derivative-of-tangent} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\tan x\) with respect to \(x\) is \(\left(\sec x\right)^2\).

\subsubsection{The Cosecant Derivative Proof}
\AgdaField{VCAS.derivative-of-cosecant} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\csc x\) with respect to \(x\) is \(- \cot x \cdot \csc x\).

\subsubsection{The Secant Derivative Proof}
\AgdaField{VCAS.derivative-of-secant} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\sec x\) with respect to \(x\) is \(\sec x \cdot \tan x\).

\subsubsection{The Cotangent Derivative Proof}
\AgdaField{VCAS.derivative-of-cotangent} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\cot x\) with respect to \(x\) is \(- \left(\csc x\right)^2\).

\subsubsection{The Derivative Sum Proof}
\AgdaField{VCAS.derivative-of-sum-is-sum-of-derivatives} \AgdaBound{v} proves that the \AgdaBound{v} CAS can correctly determine that for all relevant \(x\), \(e_1\), and \(e_2\), \(\derivative{x} \left(e_1 + e_2\right)\) is algebraically equal to \(\derivative{x} e_1 + \derivative{x} e_2\).

\subsection{The Definition Proper}

\begin{code}
record VCAS {a : Level} {ε : Set a} (Cas : CAS ε) : Set a where
  open CAS Cas
  field
    equality-is-equivalence : IsEquivalence _≈_
    structural-equality-implies-definite-equality :
      (e1 e2 : ε) →
      e1 ≡ e2 →
      (iterations : ℕ) →
      equal-at-iteration iterations e1 e2
    differently-named-variables-are-not-definitely-equal :
      (name1 name2 : String) →
      name1 ≢ name2 →
      (iterations : ℕ) →
      _≡_ (inj₂ nothing)
          (definitelyEquals iterations
                            (variableNamed name1)
                            (variableNamed name2))
    identically-named-variables-are-equal :
      (name1 name2 : String) →
      name1 ≡ name2 →
      equal-at-some-iteration (variableNamed name1) (variableNamed name2)
    sum-of-nats-is-nat-sum :
      (n1 n2 : ℕ) →
      equal-at-some-iteration (fromℕ n1 + fromℕ n2) (fromℕ (n1 Data.Nat.+ n2))
    sum-is-not-bogus :
      (e1 e2 : ε) →
      IsNotBogus e1 →
      IsNotBogus e2 →
      IsNotBogus (e1 + e2)
    product-of-e-and-1-is-e :
      (e : ε) →
      IsNotBogus e →
      equal-at-some-iteration (e * fromℕ 1) e
    difference-is-negated-sum :
      (e1 e2 : ε) →
      equal-at-some-iteration (e1 - e2)
                              (e1 + negation e2)
    inverse-of-inverse-is-original :
      (e : ε) →
      equal-at-some-iteration e (negation (negation e))
    division-by-zero-is-bogus :
      (e1 e2 : ε) →
      (equal-at-some-iteration (fromℕ 0) e2) →
      bogus-at-some-iteration (e1 / e2)
    sum-is-commutative :
      (e1 e2 : ε) →
      IsNotBogus e1 →
      IsNotBogus e2 →
      equal-at-some-iteration (e1 + e2) (e2 + e1)
    product-is-commutative :
      (e1 e2 : ε) →
      IsNotBogus e1 →
      IsNotBogus e2 →
      equal-at-some-iteration (e1 * e2) (e2 * e1)
    sum-is-associative :
      (a b c : ε) →
      IsNotBogus a →
      IsNotBogus b →
      IsNotBogus c →
      equal-at-some-iteration (a + (b + c)) ((a + b) + c)
    product-of-quotient-is-same :
      (e1 e2 : ε) →
      IsNotBogus (e2 / e1) →
      equal-at-some-iteration e2 (e1 * (e2 / e1))
    0^0-is-bogus : IsBogus (fromℕ 0 ^ fromℕ 0)
    0^-n-is-bogus : (e : ε) → e < fromℕ 0 → IsBogus (fromℕ 0 ^ e)
    limit-of-unrelated-value-is-unrelated-value :
      (name : String) →
      (e bound : ε) →
      ¬ IsNameOfVariableIn name e →
      equal-at-some-iteration e (limit name bound e)
    simple-lambda-substitution-works :
      (name : String) →
      (e : ε) →
      equal-at-some-iteration e (lambda name (variableNamed name) e)
    nonapplicable-lambda-returns-lambda-body :
      (name : String) →
      (e1 e2 : ε) →
      ¬ IsNameOfVariableIn name e2 →
      equal-at-some-iteration e2 (lambda name e2 e1)
    unrelated-derivative :
      (name : String) →
      (e : ε) →
      equal-at-some-iteration e (derivative name e)
    sin-n*pi-is-zero :
      (n : ℕ) →
      equal-at-some-iteration (fromℕ 0)
                              (sin (τ * (fromℕ n * (fromℕ 1 / fromℕ 2))))
    garbage-variable-substitution-fails :
      (e : ε)
      (list : List.List (String × ε)) →
      AllList.All (λ (var , rep) → ¬ IsNameOfVariableIn var e)
                  list →
      equal-at-some-iteration e (substituteVariables list e)
    substitution-order-is-irrelevant :
      (e : ε) →
      (list1 list2 : List.List (String × ε)) →
      list1 ↭ list2 →
      UniqueList list1 →
      equal-at-some-iteration (substituteVariables list1 e)
                              (substituteVariables list2 e)
    derivative-of-constant :
      (e : ε) →
      IsConstant e →
      (name : String) →
      equal-at-some-iteration (derivative "name" e) (fromℕ 0)
    derivative-of-sine :
      (name : String) →
      equal-at-some-iteration (derivative name (sin (variableNamed name)))
                              (cos (variableNamed name))
    derivative-of-cosine :
      (name : String) →
      equal-at-some-iteration (derivative name (cos (variableNamed name)))
                              (negation (sin (variableNamed name)))
    derivative-of-tangent :
      (name : String) →
      equal-at-some-iteration (derivative name (tan (variableNamed name)))
                              (sec (variableNamed name) ^ fromℕ 2)
    derivative-of-cosecant :
      (name : String) →
      equal-at-some-iteration (derivative name (csc (variableNamed name)))
                              (_*_ (negation (cot (variableNamed name)))
                                   (csc (variableNamed name)))
    derivative-of-secant :
      (name : String) →
      equal-at-some-iteration (derivative name (sec (variableNamed name)))
                              (_*_ (sec (variableNamed name))
                                   (tan (variableNamed name)))
    derivative-of-cotangent :
      (name : String) →
      equal-at-some-iteration (derivative name (tan (variableNamed name)))
                              (_^_ (negation (csc (variableNamed name)))
                                   (fromℕ 2))
    derivative-of-sum-is-sum-of-derivatives :
      (name : String) →
      (e1 e2 : ε) →
      equal-at-some-iteration (derivative name (e1 + e2))
                              (derivative name e1 + derivative name e2)
\end{code}

\part{The Rest is F-L-Y}

\chapter{The Core Datatypes and Associated Functions}

\section{Type Declarations}

\subsection{\AgdaDatatype{F}'s Type and Summary}
Values of type \AgdaDatatype{F} represent functions.

\begin{code}
data F : Set
\end{code}

\subsection{\AgdaDatatype{ε}'s Type and Summary}
Values of \AgdaDatatype{ε} represent expressions.

\begin{code}
data ε : Set
\end{code}

\section{The Actual Definitions\ldots and Supporting Functions}

\subsection{Completing \AgdaDatatype{F}'s Definition}
The following statements hold:

\begin{itemize}
  \item \AgdaInductiveConstructor{Abs} represents the absolute value function.
  \item \AgdaInductiveConstructor{Negate} represents the negation function.
  \item \AgdaInductiveConstructor{Sum} represents the sum function.
  \item \AgdaInductiveConstructor{Product} represents the product, i.e., multiplication, function.
  \item \AgdaInductiveConstructor{Exponent} represents the exponentiation function.
  \item \AgdaInductiveConstructor{Limit} represents the limit function, i.e., \AgdaInductiveConstructor{Ap} \AgdaSymbol(\AgdaInductiveConstructor{Limit} \AgdaBound{name}\AgdaSymbol) \AgdaSymbol(\AgdaBound{bound} \AgdaOperator{\AgdaInductiveConstructor{∷}} \AgdaBound{expression} \AgdaInductiveConstructor{List.[]}\AgdaSymbol) represents the limit of \AgdaBound{expression} as \AgdaBound{name} approaches \AgdaBound{bound}.
  \item \AgdaInductiveConstructor{Lambda} \AgdaBound{names} \AgdaBound{body} represents a lambda function whose bound variables are listed in \AgdaBound{names} and whose body is \AgdaBound{body}.  Alternatively, if \AgdaBound{names} consists of values \texttt{n1}, \texttt{n2}, \texttt{n3}, and so on, one could say that \AgdaInductiveConstructor{Lambda} \AgdaBound{names} \AgdaBound{body} is equivalent to Agda's \texttt{\textbackslash\ n1 n2 n3 ... -> body2}, where \texttt{body2} is an expansion of \AgdaBound{body}.
  {
    \newcommand{\boilerplateBogusTrigCrap}[2]{
      \item \AgdaInductiveConstructor{#1} represents the trigonometric #2 function.
    }

    \boilerplateBogusTrigCrap{Sin}{sine}
    \boilerplateBogusTrigCrap{Cos}{cosine}
    \boilerplateBogusTrigCrap{Tan}{tangent}
    \boilerplateBogusTrigCrap{Csc}{cosecant}
    \boilerplateBogusTrigCrap{Sec}{secant}
    \boilerplateBogusTrigCrap{Cot}{cotangent}
  }
  \item \AgdaInductiveConstructor{Derivative} \AgdaBound{name} represents \(\left(\lambda\ e \rightarrow \derivative{\AgdaBound{name}} e\right)\).
  \item \AgdaInductiveConstructor{Antiderivative} \AgdaBound{name} represents \(\left(\lambda\ e \rightarrow \int_{\AgdaBound{name}} e\right)\).
  \item \AgdaInductiveConstructor{BoundedIntegral} \AgdaBound{name} represents \(\left(\lambda\ b_1\ b_2\ e \rightarrow \int_{\AgdaBound{name} = b_1}^{b_2} e\right)\).
\end{itemize}

\begin{code}
data F where
  Abs
   Negate
   Sum
   Product
   Exponent : F
  Lambda : List.List String → ε → F
  Sin
   Cos
   Tan
   Csc
   Sec
   Cot : F
  Limit
   Derivative
   Antiderivative
   BoundedIntegral : String → F
\end{code}

\subsection{The Arity-Determining Function}
\AgdaFunction{arity} \AgdaBound{f} is the arity of the \AgdaBound{f} function.

\begin{code}
arity : F → ℕ
arity Abs = 1
arity Negate = 1
arity Sum = 2
arity Product = 2
arity Exponent = 2
arity Sin = 1
arity Cos = 1
arity Tan = 1
arity Csc = 1
arity Sec = 1
arity Cot = 1
arity (Lambda names body) = List.length names
arity (Limit name) = 2
arity (Derivative name) = 1
arity (Antiderivative name) = 1
arity (BoundedIntegral name) = 3
\end{code}

\subsection{The Commutativity-Determining Function}
\AgdaFunction{isCommutative} \AgdaBound{f} \AgdaBound{a} is \AgdaInductiveConstructor{true} if and only if \AgdaBound{f} represents a commutative function.

\begin{code}
isCommutative : (f : F) → arity f ≡ 2 → Bool
isCommutative Sum refl = true
isCommutative Product refl = true
isCommutative Exponent refl = false
isCommutative (Lambda names body) equality = false
isCommutative (Limit name) equality = false
\end{code}

\subsection{Completing \AgdaDatatype{ε}'s Definition}
The following statements hold:

\begin{itemize}
  \item \AgdaInductiveConstructor{Infinity} represents infinity.
  \item \AgdaInductiveConstructor{Variable} \AgdaBound{n} represents a variable whose name is \AgdaBound{n}.
  \item \AgdaInductiveConstructor{NumberRat} \AgdaBound{q} represents \AgdaBound{q}.
  \item \AgdaInductiveConstructor{Ap} \AgdaBound{f} \AgdaBound {e} represents the result of applying \AgdaBound{f} to \AgdaBound{e}.
\end{itemize}

\begin{code}
data ε where
  Infinity : ε
  Variable : String → ε
  NumberRat : ℚ → ε
  Ap : (f : F) → Vec ε (arity f) → ε
\end{code}

\section{Additional Functions}

\subsection{The Natural Number Pattern}
\AgdaInductiveConstructor{NumberNatP} \AgdaBound{n} \AgdaBound{c} is Casanova Fly's canonical representation of \AgdaBound{n}.  Despite generally being pretty powerful, the \AgdaKeyword{pattern} stuff can apparently \emph{not} do \AgdaFunction{Coprimality.1-coprimeTo} stuff.

\begin{code}
pattern NumberNatP n c = NumberRat (ℚ.mkℚ (Data.Integer.+ n) 0 c)
\end{code}

\subsection{The Natural-Number-to-Expression Function}
\AgdaFunction{NumberNat} \AgdaBound{n} is Casanova Fly's more manageable representation of \AgdaBound{n}.

\begin{code}
NumberNat : ℕ → ε
NumberNat n = NumberNatP n (Coprimality.sym (Coprimality.1-coprimeTo _))
\end{code}

\subsection{The Quotient Pattern}
\AgdaInductiveConstructor{NumberRat} \AgdaBound{x} \AgdaBound{y} \AgdaBound{coprimality} is Casanova Fly's representation of \(\frac{\AgdaBound{x}}{\AgdaBound{y}}\).

\begin{code}
pattern Quotient x y coprime =
  Ap Product
     ( x
     ∷ (Ap Exponent
           ( y
           ∷ Ap Negate (NumberNatP 1 coprime ∷ [])
           ∷ [])
     ∷ []))
\end{code}

\subsection{Decidable Structural Equality on \AgdaDatatype{F}}
This function is used to determine whether or not the input arguments are structurally equivalent.

\begin{code}
structuralEqualityOnF : DecidableEquality F
structuralEqualityOnF = s
  where
  s : DecidableEquality F
  s Abs Abs = yes refl
  s Abs Negate = no λ ()
  s Abs Sum = no λ ()
  s Abs Product = no λ ()
  s Abs Exponent = no λ ()
  s Abs (Lambda name exp) = no λ ()
  s Abs Sin = no λ ()
  s Abs Cos = no λ ()
  s Abs Tan = no λ ()
  s Abs Csc = no λ ()
  s Abs Sec = no λ ()
  s Abs Cot = no λ ()
  s Abs (Limit name) = no λ ()
  s Abs (Derivative name) = no λ ()
  s Abs (Antiderivative name) = no λ ()
  s Abs (BoundedIntegral name) = no λ ()
  s Negate Abs = no λ ()
  s Negate Negate = yes refl
  s Negate Sum = no λ ()
  s Negate Product = no λ ()
  s Negate Exponent = no λ ()
  s Negate (Lambda name exp) = no λ ()
  s Negate Sin = no λ ()
  s Negate Cos = no λ ()
  s Negate Tan = no λ ()
  s Negate Csc = no λ ()
  s Negate Sec = no λ ()
  s Negate Cot = no λ ()
  s Negate (Limit name) = no λ ()
  s Negate (Derivative name) = no λ ()
  s Negate (Antiderivative name) = no λ ()
  s Negate (BoundedIntegral name) = no λ ()
  s Sum Abs = no λ ()
  s Sum Negate = no λ ()
  s Sum Sum = yes refl
  s Sum Product = no λ ()
  s Sum Exponent = no λ ()
  s Sum (Lambda name exp) = no λ ()
  s Sum Sin = no λ ()
  s Sum Cos = no λ ()
  s Sum Tan = no λ ()
  s Sum Csc = no λ ()
  s Sum Sec = no λ ()
  s Sum Cot = no λ ()
  s Sum (Limit name) = no λ ()
  s Sum (Derivative name) = no λ ()
  s Sum (Antiderivative name) = no λ ()
  s Sum (BoundedIntegral name) = no λ ()
  s Product Abs = no λ ()
  s Product Negate = no λ ()
  s Product Sum = no λ ()
  s Product Product = yes refl
  s Product Exponent = no λ ()
  s Product (Lambda name exp) = no λ ()
  s Product Sin = no λ ()
  s Product Cos = no λ ()
  s Product Tan = no λ ()
  s Product Csc = no λ ()
  s Product Sec = no λ ()
  s Product Cot = no λ ()
  s Product (Limit name) = no λ ()
  s Product (Derivative name) = no λ ()
  s Product (Antiderivative name) = no λ ()
  s Product (BoundedIntegral name) = no λ ()
  s Exponent Abs = no λ ()
  s Exponent Negate = no λ ()
  s Exponent Sum = no λ ()
  s Exponent Product = no λ ()
  s Exponent Exponent = yes refl
  s Exponent (Lambda name exp) = no λ ()
  s Exponent Sin = no λ ()
  s Exponent Cos = no λ ()
  s Exponent Tan = no λ ()
  s Exponent Csc = no λ ()
  s Exponent Sec = no λ ()
  s Exponent Cot = no λ ()
  s Exponent (Limit name) = no λ ()
  s Exponent (Derivative name) = no λ ()
  s Exponent (Antiderivative name) = no λ ()
  s Exponent (BoundedIntegral name) = no λ ()
  s (Lambda n1 e1) Abs = no λ ()
  s (Lambda n1 e1) Negate = no λ ()
  s (Lambda n1 e1) Sum = no λ ()
  s (Lambda n1 e1) Product = no λ ()
  s (Lambda n1 e1) Exponent = no λ ()
  s (Lambda n1 e1) (Lambda n2 e2) = {!!}
  s (Lambda n1 e1) Sin = no λ ()
  s (Lambda n1 e1) Cos = no λ ()
  s (Lambda n1 e1) Tan = no λ ()
  s (Lambda n1 e1) Csc = no λ ()
  s (Lambda n1 e1) Sec = no λ ()
  s (Lambda n1 e1) Cot = no λ ()
  s (Lambda n1 e1) (Limit name) = no λ ()
  s (Lambda n1 e1) (Derivative name) = no λ ()
  s (Lambda n1 e1) (Antiderivative name) = no λ ()
  s (Lambda n1 e1) (BoundedIntegral name) = no λ ()
  -- Help!  I'm trapped in a boring nonsense factory!
  s Sin Abs = no λ ()
  s Sin Negate = no λ ()
  s Sin Sum = no λ ()
  s Sin Product = no λ ()
  s Sin Exponent = no λ ()
  s Sin (Lambda name exp) = no λ ()
  s Sin Sin = yes refl
  s Sin Cos = no λ ()
  s Sin Tan = no λ ()
  s Sin Csc = no λ ()
  s Sin Sec = no λ ()
  s Sin Cot = no λ ()
  s Sin (Limit name) = no λ ()
  s Sin (Derivative name) = no λ ()
  s Sin (Antiderivative name) = no λ ()
  s Sin (BoundedIntegral name) = no λ ()
  s Cos Abs = no λ ()
  s Cos Negate = no λ ()
  s Cos Sum = no λ ()
  s Cos Product = no λ ()
  s Cos Exponent = no λ ()
  s Cos (Lambda name exp) = no λ ()
  s Cos Sin = no λ ()
  s Cos Cos = yes refl
  s Cos Tan = no λ ()
  s Cos Csc = no λ ()
  s Cos Sec = no λ ()
  s Cos Cot = no λ ()
  s Cos (Limit name) = no λ ()
  s Cos (Derivative name) = no λ ()
  s Cos (Antiderivative name) = no λ ()
  s Cos (BoundedIntegral name) = no λ ()
  s Tan Abs = no λ ()
  s Tan Negate = no λ ()
  s Tan Sum = no λ ()
  s Tan Product = no λ ()
  s Tan Exponent = no λ ()
  s Tan (Lambda name exp) = no λ ()
  s Tan Sin = no λ ()
  s Tan Cos = no λ ()
  s Tan Tan = yes refl
  s Tan Csc = no λ ()
  s Tan Sec = no λ ()
  s Tan Cot = no λ ()
  s Tan (Limit name) = no λ ()
  s Tan (Derivative name) = no λ ()
  s Tan (Antiderivative name) = no λ ()
  s Tan (BoundedIntegral name) = no λ ()
  s Csc Abs = no λ ()
  s Csc Negate = no λ ()
  s Csc Sum = no λ ()
  s Csc Product = no λ ()
  s Csc Exponent = no λ ()
  s Csc (Lambda name exp) = no λ ()
  s Csc Sin = no λ ()
  s Csc Cos = no λ ()
  s Csc Tan = no λ ()
  s Csc Csc = yes refl
  s Csc Sec = no λ ()
  s Csc Cot = no λ ()
  s Csc (Limit name) = no λ ()
  s Csc (Derivative name) = no λ ()
  s Csc (Antiderivative name) = no λ ()
  s Csc (BoundedIntegral name) = no λ ()
  s Sec Abs = no λ ()
  s Sec Negate = no λ ()
  s Sec Sum = no λ ()
  s Sec Product = no λ ()
  s Sec Exponent = no λ ()
  s Sec (Lambda name exp) = no λ ()
  s Sec Sin = no λ ()
  s Sec Cos = no λ ()
  s Sec Tan = no λ ()
  s Sec Csc = no λ ()
  s Sec Sec = yes refl
  s Sec Cot = no λ ()
  s Sec (Limit name) = no λ ()
  s Sec (Derivative name) = no λ ()
  s Sec (Antiderivative name) = no λ ()
  s Sec (BoundedIntegral name) = no λ ()
  s Cot Abs = no λ ()
  s Cot Negate = no λ ()
  s Cot Sum = no λ ()
  s Cot Product = no λ ()
  s Cot Exponent = no λ ()
  s Cot (Lambda name exp) = no λ ()
  s Cot Sin = no λ ()
  s Cot Cos = no λ ()
  s Cot Tan = no λ ()
  s Cot Csc = no λ ()
  s Cot Sec = no λ ()
  s Cot Cot = yes refl
  s Cot (Limit name) = no λ ()
  s Cot (Derivative name) = no λ ()
  s Cot (Antiderivative name) = no λ ()
  s Cot (BoundedIntegral name) = no λ ()
  s (Limit n1) Abs = no λ ()
  s (Limit n1) Negate = no λ ()
  s (Limit n1) Sum = no λ ()
  s (Limit n1) Product = no λ ()
  s (Limit n1) Exponent = no λ ()
  s (Limit n1) (Lambda name exp) = no λ ()
  s (Limit n1) Sin = no λ ()
  s (Limit n1) Cos = no λ ()
  s (Limit n1) Tan = no λ ()
  s (Limit n1) Csc = no λ ()
  s (Limit n1) Sec = no λ ()
  s (Limit n1) Cot = no λ ()
  s (Limit n1) (Limit n2) with n1 Data.String.≟ n2
  ... | yes eq = yes (cong Limit eq)
  ... | no neq = no (neq ∘ equality-implies-variable-equality n1 n2)
    where
    equality-implies-variable-equality : (n1 n2 : String) →
           Limit n1 ≡ Limit n2 →
           n1 ≡ n2
    equality-implies-variable-equality n1 n2 refl = refl
  s (Limit n1) (Derivative name) = no λ ()
  s (Limit n1) (Antiderivative name) = no λ ()
  s (Limit n1) (BoundedIntegral name) = no λ ()
  s (Derivative n1) Abs = no λ ()
  s (Derivative n1) Negate = no λ ()
  s (Derivative n1) Sum = no λ ()
  s (Derivative n1) Product = no λ ()
  s (Derivative n1) Exponent = no λ ()
  s (Derivative n1) (Lambda name exp) = no λ ()
  s (Derivative n1) Sin = no λ ()
  s (Derivative n1) Cos = no λ ()
  s (Derivative n1) Tan = no λ ()
  s (Derivative n1) Csc = no λ ()
  s (Derivative n1) Sec = no λ ()
  s (Derivative n1) Cot = no λ ()
  s (Derivative n1) (Limit name) = no λ ()
  s (Derivative n1) (Derivative n2) with n1 Data.String.≟ n2
  ... | yes eq = yes (cong Derivative eq)
  ... | no neq = no (neq ∘ equality-implies-variable-equality n1 n2)
    where
    equality-implies-variable-equality : (n1 n2 : String) →
           Derivative n1 ≡ Derivative n2 →
           n1 ≡ n2
    equality-implies-variable-equality n1 n2 refl = refl
  s (Derivative n1) (Antiderivative name) = no λ ()
  s (Derivative n1) (BoundedIntegral name) = no λ ()
  s (Antiderivative n1) Abs = no λ ()
  s (Antiderivative n1) Negate = no λ ()
  s (Antiderivative n1) Sum = no λ ()
  s (Antiderivative n1) Product = no λ ()
  s (Antiderivative n1) Exponent = no λ ()
  s (Antiderivative n1) (Lambda name exp) = no λ ()
  s (Antiderivative n1) Sin = no λ ()
  s (Antiderivative n1) Cos = no λ ()
  s (Antiderivative n1) Tan = no λ ()
  s (Antiderivative n1) Csc = no λ ()
  s (Antiderivative n1) Sec = no λ ()
  s (Antiderivative n1) Cot = no λ ()
  s (Antiderivative n1) (Limit name) = no λ ()
  s (Antiderivative n1) (Derivative name) = no λ ()
  s (Antiderivative n1) (Antiderivative n2) with n1 Data.String.≟ n2
  ... | yes eq = yes (cong Antiderivative eq)
  ... | no neq = no (neq ∘ equality-implies-variable-equality n1 n2)
    where
    equality-implies-variable-equality : (n1 n2 : String) →
           Antiderivative n1 ≡ Antiderivative n2 →
           n1 ≡ n2
    equality-implies-variable-equality n1 n2 refl = refl
  s (Antiderivative n1) (BoundedIntegral name) = no λ ()
  s (BoundedIntegral n1) Abs = no λ ()
  s (BoundedIntegral n1) Negate = no λ ()
  s (BoundedIntegral n1) Sum = no λ ()
  s (BoundedIntegral n1) Product = no λ ()
  s (BoundedIntegral n1) Exponent = no λ ()
  s (BoundedIntegral n1) (Lambda name exp) = no λ ()
  s (BoundedIntegral n1) Sin = no λ ()
  s (BoundedIntegral n1) Cos = no λ ()
  s (BoundedIntegral n1) Tan = no λ ()
  s (BoundedIntegral n1) Csc = no λ ()
  s (BoundedIntegral n1) Sec = no λ ()
  s (BoundedIntegral n1) Cot = no λ ()
  s (BoundedIntegral n1) (Limit name) = no λ ()
  s (BoundedIntegral n1) (Derivative name) = no λ ()
  s (BoundedIntegral n1) (Antiderivative name) = no λ ()
  s (BoundedIntegral n1) (BoundedIntegral n2) with n1 Data.String.≟ n2
  ... | yes eq = yes (cong BoundedIntegral eq)
  ... | no neq = no (neq ∘ equality-implies-variable-equality n1 n2)
    where
    equality-implies-variable-equality : (n1 n2 : String) →
           BoundedIntegral n1 ≡ BoundedIntegral n2 →
           n1 ≡ n2
    equality-implies-variable-equality n1 n2 refl = refl
\end{code}

\subsection{Decidable Structural Equality on \AgdaDatatype{ε}}
This function is used to determine whether or not the input arguments are structurally equivalent.

\begin{code}
{-# TERMINATING #-}
structuralEqualityOnε : DecidableEquality ε
structuralEqualityOnε = s
  where
  s : DecidableEquality ε
  s Infinity Infinity = yes refl
  s Infinity (Variable v) = no λ ()
  s Infinity (NumberRat r) = no λ ()
  s Infinity (Ap f x) = no λ ()
  s (Variable v) Infinity = no λ ()
  s (Variable v1) (Variable v2) with v1 Data.String.≟ v2
  ... | yes namesAreEqual = yes (cong Variable namesAreEqual)
  ... | no differentNames = no (differentNames ∘ same-variable-implies-same-name)
    where
    same-variable-implies-same-name :
      {n1 n2 : String} →
      Variable n1 ≡ Variable n2 →
      n1 ≡ n2
    same-variable-implies-same-name refl = refl
  s (Variable v) (NumberRat r) = no λ ()
  s (Variable v) (Ap f x) = no λ ()
  s (NumberRat r) Infinity = no λ ()
  s (NumberRat r) (Variable v) = no λ ()
  s (NumberRat r1) (NumberRat r2) with r1 ℚ.≟ r2
  ... | yes ratsAreEqual = yes (cong NumberRat ratsAreEqual)
  ... | no ratsAreDifferent = no (ratsAreDifferent ∘ same-numberRat-implies-same-rat)
    where
    same-numberRat-implies-same-rat :
      {q1 q2 : ℚ} →
      NumberRat q1 ≡ NumberRat q2 →
      q1 ≡ q2
    same-numberRat-implies-same-rat refl = refl
  s (NumberRat r) (Ap f x) = no λ ()
  s (Ap f x) Infinity = no λ ()
  s (Ap f x) (Variable v) = no λ ()
  s (Ap f x) (NumberRat r) = no λ ()
  s (Ap f1 x1) (Ap f2 x2) with structuralEqualityOnF f2 f1
  ... | no differentF = no (differentF ∘ sym ∘ same-only-with-same-function)
    where
    same-only-with-same-function :
      {f1 f2 : F} →
      {x1 : Vec ε (arity f1)} →
      {x2 : Vec ε (arity f2)} →
      Ap f1 x1 ≡ Ap f2 x2 →
      f1 ≡ f2
    same-only-with-same-function refl = refl
  ... | yes sameF with VecProp.≡-dec structuralEqualityOnε
                                     x1 (Data.Vec.cast (cong arity sameF) x2)
  ... | yes sameX = yes (combine sameF sameX)
    where
    combine :
      {f1 f2 : F} →
      {x1 : Vec ε (arity f1)} →
      {x2 : Vec ε (arity f2)} →
      (sameF : f2 ≡ f1) →
      x1 ≡ Data.Vec.cast (cong arity sameF) x2 →
      Ap f1 x1 ≡ Ap f2 x2
    combine = {!!}
  ... | no differentX = no (differentX ∘ same-only-with-same-x sameF)
    where
    same-only-with-same-x :
      {f1 f2 : F} →
      {x1 : Vec ε (arity f1)} →
      {x2 : Vec ε (arity f2)} →
      (sameF : f2 ≡ f1) →
      Ap f1 x1 ≡ Ap f2 x2 →
      x1 ≡ Data.Vec.cast (cong arity sameF) x2
    same-only-with-same-x = {!!}
\end{code}

\subsection{The Function for Commutativity Permutations}
\AgdaFunction{commutativePermutations} \AgdaBound{x} is a list of all expressions which are equivalent to \AgdaBound{x} and are derived from \AgdaBound{x} by commutativity.

\begin{code}
{-# TERMINATING #-}
commutativePermutations : ε → List.List ε
commutativePermutations (Ap f e) = perms' f (Data.Vec.toList e) {!!}
  where
  combine : (f : F) → (e : List.List ε) → arity f ≡ List.length e → ε
  combine f e lengthMatch = Ap f (Data.Vec.cast (sym lengthMatch)
                                                (Data.Vec.fromList e))
  perms' : (f : F) → (e : List.List ε) → arity f ≡ List.length e → List.List ε
  perms' f e@(e1 List.∷ e2 List.∷ List.[]) lengthMatches =
    if isCommutative f lengthMatches then solo else list
    where
    solo = List.[ combine f e lengthMatches ]
    list =
      f' (e2 ∷ [ e1 ]) List.∷ f' (e1 ∷ [ e2 ]) List.∷
      List.map (λ e2 → f' (e1 ∷ [ e2 ])) (commutativePermutations e2) List.++
      List.map (λ e1 → f' (e1 ∷ [ e2 ])) (commutativePermutations e1) List.++
      List.concat (List.map (λ (e1 , e2) → f' (e1 ∷ [ e2 ]) List.∷
                                            List.[ f' (e2 ∷ [ e1 ]) ])
                            (List.zip (commutativePermutations e1)
                                      (commutativePermutations e2)))
      where f' = Ap f ∘ Data.Vec.cast (sym lengthMatches)
  perms' f e lengthMatches = List.[ combine f e lengthMatches ]
commutativePermutations o = List.[ o ]
\end{code}

\section{The Variable Substitution Function}
\AgdaFunction{varSubstM} is the multi-variable substitution function.  In \AgdaFunction{varSubstM} \AgdaBound{l} \AgdaBound{e}, any variable in \AgdaBound{e} which also has an entry in \AgdaBound{l} will be replaced by the corresponding \AgdaDatatype{ε} entry in \AgdaBound{l}.  More formally, one can say that \AgdaFunction{varSubstM} \AgdaBound{l} \AgdaBound{e} is a derivative of \AgdaBound{e} such that for any given variable \AgdaBound{x} in \AgdaBound{e}, if a value \AgdaBound{i} exists such that \AgdaField{proj₁} \AgdaSymbol(\AgdaFunction{List.lookup} \AgdaBound{l} \AgdaBound{i}\AgdaSymbol) is \AgdaBound{x}, then \AgdaBound{x} is replaced by \AgdaField{proj₂} \AgdaSymbol(\AgdaFunction{List.lookup} \AgdaBound{l} \AgdaBound{i}\AgdaSymbol).

\begin{code}
{-# TERMINATING #-}
varSubstM : List.List (String × ε) → ε → ε
varSubstM List.[] x = x
varSubstM vars o@(NumberRat r) = o
varSubstM vars o@Infinity = o
varSubstM (v List.∷ vs) (Variable sv) =
  if proj₁ v Data.String.== sv
     then proj₂ v
     else varSubstM vs (Variable sv)
varSubstM vars o@(Ap f x) = Ap f (Data.Vec.map (varSubstM vars) x)
\end{code}

\section{The Types of the Algebraic Equality Type and the Single-Step Evaluation Function}

\subsection{The Algebraic Equality Function}
A value of type \AgdaFunction{AlgebraicEquality} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is \emph{algebraically} equal to \AgdaBound{y}, i.e., \AgdaBound{x} and \AgdaBound{y} represent the same numerical value.  This algebraic equality type should not be confused with the \emph{propositional} equality type, which, as intended, fails to recognize that \(x + y\) is in some way equal to \(y + x\).

\begin{code}
AlgebraicEquality : ε → ε → Set
\end{code}

\subsection{The Algebraic Equality Determination Function}
Informally, one can say that \AgdaFunction{checkAlgebraicEquality} \AgdaBound{n} is the \AgdaBound{n}-iteration equality check function. Formally, one can say that the following statements apply:

\begin{enumerate}
  \item If \AgdaBound{x} and \AgdaBound{y} are shown to be \AgdaInductiveConstructor{inj₂-equal} within \AgdaBound{n} iterations,\footnote{In this context, we say that two \AgdaFunction{Exceptional} expressions \AgdaBound{x} and \AgdaBound{y} are \AgdaInductiveConstructor{inj₂}-equal if and only if some value \AgdaBound{p} of type \AgdaFunction{AlgebraicEquality} \AgdaBound{x} \AgdaBound{y} exists such that if \AgdaBound{p} is some value \AgdaInductiveConstructor{inj₂} \AgdaSymbol(\AgdaInductiveConstructor{inj₂} \AgdaSymbol(\AgdaSymbol(\AgdaBound{i1} \AgdaOperator{\AgdaInductiveConstructor{,}} \AgdaBound{i2}\AgdaSymbol) \AgdaOperator{\AgdaInductiveConstructor{,}} \AgdaBound{equals}\AgdaSymbol)\AgdaSymbol), then \AgdaBound{i1} and \AgdaBound{i2} are less than or equal to \AgdaBound{n}.}  then \AgdaFunction{checkAlgebraicEquality} \AgdaBound{n} \AgdaBound{x} \AgdaBound{y} is \AgdaInductiveConstructor{inj₂} \AgdaSymbol(\AgdaInductiveConstructor{just} \AgdaBound{p}\AgdaSymbol), where \AgdaBound{p} is a proof of the aforementined algebraic equality.\label{enum:eqCheck-just-if-equal}
  \item If \AgdaBound{x} and \AgdaBound{y} are non-bogus for all iteration counts which are less than or equal to \AgdaBound{n}, but no appropriate equality proof exists, then \AgdaFunction{checkAlgebraicEquality} \AgdaBound{n} \AgdaBound{x} \AgdaBound{y} is \AgdaInductiveConstructor{inj₂} \AgdaInductiveConstructor{nothing}.\label{enum:eqCheck-nothing-if-not-equal}
  \item If \AgdaBound{x} or \AgdaBound{y} is bogusly evaluated at some iteration count which is less than or equal to \AgdaBound{n}, then \AgdaFunction{checkAlgebraicEquality} \AgdaBound{n} \AgdaBound{x} \AgdaBound{y} is \AgdaInductiveConstructor{inj₁} \AgdaBound{s}, where \AgdaBound{s} is some description of the aforementioned bogosity.\label{enum:eqCheck-inj1-if-bogus}
\end{enumerate}

\begin{code}
checkAlgebraicEquality :
  ℕ → (x y : ε) → Exceptional (Maybe (AlgebraicEquality x y))
\end{code}

\subsection{The Single-Step Evaluation Function}
\AgdaFunction{exceptionallyEvaluate} \AgdaBound{x} contains the result of performing a single evaluation step on \AgdaBound{x} \emph{or} a value which indicates that \AgdaBound{x} is in some way nonsensical.

\begin{code}
exceptionallyEvaluate : ε → Exceptional ε
\end{code}

\section{The Single-Step Evaluation Function which \emph{also} Supports Commutativity}
\AgdaFunction{commutativeEvaluate} \AgdaBound{e} performs a single evaluation step on the input expression but can also do some fancy stuff when applicable, e.g., switching the arguments of commutative functions.

\begin{code}
commutativeEvaluate : ε → Exceptional ε
commutativeEvaluate e@(Ap f x) =
  if (e evaluates) then evaluate e else tryFlip (arity f Data.Nat.≟ 2)
  where
  -- evaluate is just an abbreviation.  "exceptionallyEvaluate" is a bit long.
  evaluate = exceptionallyEvaluate
  structuralEquality =
    Data.Sum.Properties.≡-dec Data.String._≟_ structuralEqualityOnε
  _evaluates : ε → Bool
  _evaluates e = isNo (structuralEquality (inj₂ e) (evaluate e))
  tryFlip : Dec (arity f ≡ 2) → Exceptional ε
  tryFlip (no arityDiffers) = evaluate e
  tryFlip (yes arityMatches) =
    if isCommutative f arityMatches ∧ (e2 evaluates) then inj₂ e2 else evaluate e
    where e2 = Ap f (reverse x)
commutativeEvaluate e = exceptionallyEvaluate e
\end{code}

\section{Completing the Algebraic Equality Function}
Regardless of the indentation in the compiled PDF document, this entire section, save for the final definition, constitutes a single module\ldots{} and facilitates defining \AgdaFunction{AlgebraicEquality}.

\begin{code}
module AlgebraicEquality where
\end{code}

\subsection{The Type of the Main Function}
A value of type \AgdaFunction{main} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is algebraically equal to \AgdaBound{y}.  The reader may be right to think that this explanation is uncannily similar to another explanation\ldots{}

\begin{code}
  main : ε → ε → Set
\end{code}

\subsection{The Basic Equality Type}
Basically, a proof of type \AgdaFunction{AE} \AgdaBound{x} \AgdaBound{y} if and only if \AgdaBound{x} is ``directly equal'' to \AgdaBound{y}.

This notion of being ``directly equal'' is best understood by reading the Agda-based definition, but the author's Englishy explanation is as follows: When possible, \AgdaFunction{AE} uses natural number equality proofs, quotient type equality proofs, and other such structural equality proofs which cannot be achieved through the use of \AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}} alone.  Where applicable, commutativity and associativity are also considered.

\begin{code}
  AE : ε → ε → Set
\end{code}

\subsubsection{\AgdaInductiveConstructor{Infinity}-Related Types}

\begin{code}
  AE Infinity Infinity = ⊤
  AE Infinity (Variable x) = ⊥
  AE Infinity (NumberRat x) = ⊥
  AE Infinity (Ap f x) = {!!}
\end{code}

\subsubsection{\AgdaInductiveConstructor{Variable}-Related Types}

\begin{code}
  AE (Variable x) (Variable y) = x ≡ y
  AE (Variable x) Infinity = ⊥
  AE (Variable x) (NumberRat y) = ⊥
  AE (Variable x) (Ap f y) = {!!}
\end{code}

\subsubsection{\AgdaInductiveConstructor{NumberRat}-Related Types}

\begin{code}
  AE (NumberRat x) (NumberRat y) = x ≡ y
  AE (NumberRat x) Infinity = ⊥
  AE (NumberRat x) (Variable y) = ⊥
  AE (NumberRat x) (Ap f y) = {!!}
\end{code}

\subsubsection{\AgdaInductiveConstructor{Ap}-Related Types}

\begin{code}
  AE (Ap f x) Infinity = {!!}
  AE (Ap f x) (Variable y) = {!!}
  AE (Ap f x) (NumberRat y) = {!!}
\end{code}

\subsubsection{Associativity-Related Types}

\begin{code}
  AE (Ap Sum (x1 ∷ Ap Sum (x2 ∷ x3 ∷ []) ∷ []))
     (Ap Sum (Ap Sum (y1 ∷ y2 ∷ []) ∷ y3 ∷ [])) =
     _×_ (AllList.All (λ x → AnyList.Any (main x) ys) xs)
         (AllList.All (λ y → AnyList.Any (main y) xs) ys)
     where
     xs = Data.Vec.toList (x1 ∷ x2 ∷ [ x3 ])
     ys = Data.Vec.toList (y1 ∷ y2 ∷ [ y3 ])
  AE (Ap Product (x1 ∷ Ap Product (x2 ∷ x3 ∷ []) ∷ []))
     (Ap Product (Ap Product (y1 ∷ y2 ∷ []) ∷ y3 ∷ [])) =
     _×_ (AllList.All (λ x → AnyList.Any (main x) ys) xs)
         (AllList.All (λ y → AnyList.Any (main y) xs) ys)
     where
     xs = Data.Vec.toList (x1 ∷ x2 ∷ [ x3 ])
     ys = Data.Vec.toList (y1 ∷ y2 ∷ [ y3 ])
\end{code}

\subsubsection{Commutativity-Related Types}

\begin{code}
  AE (Ap Sum (x1 ∷ y1 ∷ [])) (Ap Sum (x2 ∷ y2 ∷ [])) =
    _⊎_ (AlgebraicEquality x1 x2 × AlgebraicEquality y1 y2)
        (AlgebraicEquality x1 y2 × AlgebraicEquality y2 y1)
  AE (Ap Product (x1 ∷ y1 ∷ [])) (Ap Product (x2 ∷ y2 ∷ [])) =
    (main x1 x2 × main y1 y2) ⊎ (main x1 y2 × main y2 y1)
\end{code}

\subsubsection{\ldots{} and the Rest}

\begin{code}
  AE (Ap f x) (Ap g y) = {!!}
\end{code}

\subsection{The Exceptional Equality Type}
A value of type \AgdaFunction{AE2} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} and \AgdaBound{y} \AgdaInductiveConstructor{inj₂}-contain equal values.

\begin{code}
  AE2 : Exceptional ε → Exceptional ε → Set
  AE2 (inj₂ x) (inj₂ y) = main x y
  AE2 _ _ = ⊥
\end{code}

\subsection{Completing the Algebraic Equality Function}

\begin{code}
  main x y =
    x ≡ y ⊎
    AE x y ⊎
    Σ (ℕ × ℕ) (λ (n , m) → AE2 (repeatExceptional n commutativeEvaluate x)
                               (repeatExceptional m commutativeEvaluate y))
\end{code}

\subsection{Exporting and Defining the Global Algebraic Equality Function}
\AgdaFunction{AlgebraicEquality} is really just \AgdaFunction{AlgebraicEquality.main}.

\begin{code}
AlgebraicEquality = AlgebraicEquality.main
\end{code}

\section{Completing the Single-Step Evaluation Function}

\begin{code}
module exceptionallyEvaluate where
  main : ε → Exceptional ε

  firstInj2 : {n : ℕ} → {a : Level} → {A : Set a} →
              Vec (Maybe (Exceptional A)) (ℕ.suc n) → Exceptional A
  firstInj2 = fromMaybe errorMsg ∘ List.head ∘ List.catMaybes
            ∘ Data.Vec.toList
    where errorMsg = inj₁ "The list of exceptionallyEvaluate results \
                          \was just a bunch of nothingness!"

  functions =
    ( (λ { (Ap Negate (Ap Negate (x ∷ []) ∷ [])) → valid x
         ; _ → nothing})
    ∷ (λ { (Ap Negate (NumberRat x ∷ [])) → valid (NumberRat (ℚ.0ℚ ℚ.- x))
         ; _ → nothing})
    ∷ (λ { (Ap Sum (NumberNatP 0 c ∷ x ∷ [])) → valid x
         ; _ → nothing})
    ∷ (λ { (Ap Sum (NumberRat x ∷ NumberRat y ∷ [])) →
           valid (NumberRat (x ℚ.+ y))
         ; _ → nothing})
    ∷ (λ { (Ap Product (NumberRat x ∷ NumberRat y ∷ [])) →
           valid (NumberRat (x ℚ.* y))
         ; _ → nothing})
    ∷ (λ { (Ap Exponent (NumberNatP x c1 ∷ NumberNatP y c2 ∷ [])) →
           if (x Data.Nat.≡ᵇ 0) ∧ (y Data.Nat.≡ᵇ 0)
             then bust "0^0 is undefined!"
             else valid (NumberNat (x Data.Nat.^ y))
         ; _ → nothing})
    -- The following "x^0" evaluation rule is a bit dubious; this rule
    -- indicates that Variable x ^ fromℕ 0 is algebraically equal to
    -- fromℕ 1.  However, Variable x *could* feasibly be defined as
    -- being equal to fromℕ 0.
    -- The current behavior parallels Maxima, though.
    ∷ (λ { (Ap Exponent (x ∷ NumberNatP 0 c ∷ [])) → valid (NumberNat 1)
         ; _ → nothing})
    -- The following "0^x" evaluation rule, like the "x^0" rule, is
    -- kind of dubious.  This rule, too, mirrors the behavior of
    -- Maxima, though.
    ∷ (λ { (Ap Exponent ((NumberNatP 0 c) ∷ e ∷ [])) → valid (NumberNat 0)
         ; _ → nothing})
    ∷ (λ { (Ap Exponent (x ∷ NumberNatP 1 c ∷ [])) → valid x
         ; _ → nothing})
    -- The following evaluation rule is *also* kind of dubious, but,
    -- again, the behavior is like the behavior of Maxima.
    ∷ (λ { (Ap (Derivative v1) (Variable v2 ∷ [])) →
           if v1 Data.String.== v2
             then valid (NumberNat 1)
             else valid (NumberNat 0)
         ; _ → nothing})
    ∷ (λ { (Ap (Derivative v1) (NumberRat x ∷ [])) →
           valid (NumberNat 0)
         ; _ → nothing})
    ∷ (λ { (Ap (Derivative v1) (Ap Negate x ∷ [])) →
           valid (Ap Negate [ Ap (Derivative v1) x ])
         ; _ → nothing})
    ∷ (λ { (Ap (Derivative v1) (Ap Sum (x ∷ y ∷ []) ∷ [])) →
           valid (Ap Sum ( Ap (Derivative v1) [ x ]
                         ∷ [ Ap (Derivative v1) [ y ] ]))
         ; _ → nothing})
    ∷ (λ { (Ap (Derivative v1) (Ap Product (x ∷ y ∷ []) ∷ [])) →
           valid (Ap Product ( Ap (Derivative v1) [ x ]
                             ∷ [ Ap (Derivative v1) [ y ] ]))
         ; _ → nothing})
    ∷ (λ { (Ap (Derivative v1) (Ap Sin (Variable v2 ∷ []) ∷ [])) →
           if v1 Data.String.== v2
             then valid (Ap Cos [ Variable v1 ])
             else nothing
         ; _ → nothing})
    ∷ (λ { (Ap (Derivative v1) (Ap Cos (Variable v2 ∷ []) ∷ [])) →
           if v1 Data.String.== v2
             then valid (Ap Negate [ Ap Sin [ Variable v1 ] ])
             else nothing
         ; _ → nothing})
    ∷ (λ { (Ap (Derivative v1) (Ap Tan (Variable v2 ∷ []) ∷ [])) →
           if v1 Data.String.== v2
             then valid (Ap Exponent ( Ap Sec [ Variable v1 ] ∷ [ NumberNat 2 ]))
             else nothing
         ; _ → nothing})
    ∷ (λ { (Ap (Derivative v1) (Ap Csc (Variable v2 ∷ []) ∷ [])) →
           if v1 Data.String.== v2
             then valid (Ap Product
                            ( Ap Csc [ Variable v1 ]
                            ∷ [ Ap Negate [ Ap Cot [ Variable v1 ] ] ]))
             else nothing
         ; _ → nothing})
    ∷ (λ { (Ap (Derivative v1) (Ap Sec (Variable v2 ∷ []) ∷ [])) →
           if v1 Data.String.== v2
             then valid (Ap Product
                            ( Ap Sec [ Variable v1 ]
                            ∷ [ Ap Tan [ Variable v1 ] ]))
             else nothing
         ; _ → nothing})
    ∷ (λ { (Ap (Derivative v1) (Ap Cot (Variable v2 ∷ []) ∷ [])) →
           if v1 Data.String.== v2
             then valid (Ap Negate
                            [ Ap Exponent
                                 ( Ap Csc [ Variable v1 ]
                                 ∷ [ NumberNat 2 ]) ])
             else nothing
         ; _ → nothing})
    ∷ (λ { (Ap (Lambda names body) expressions) →
           valid (varSubstM (List.zip names (Data.Vec.toList expressions)) body)
         ; _ → nothing})
    ∷ (λ { (Ap f x) → [_,_] (just ∘ inj₁)
                            (just ∘ inj₂ ∘ Ap f)
                            (condense (Data.Vec.map main x))
         ; _ → nothing})
    ∷ [ just ∘ inj₂ ]
    )
    where
    bust = just ∘ inj₁
    valid = just ∘ inj₂
    condense : {a : Level} →
               {A : Set a} →
               {n : ℕ} →
               Vec (Exceptional A) n →
               Exceptional (Vec A n)
    condense [] = inj₂ []
    condense (inj₁ x ∷ xs) = inj₁ x
    condense (inj₂ x ∷ xs) = [_,_] inj₁ (inj₂ ∘ _∷_ x) (condense xs)

  {-# TERMINATING #-}
  main e = firstInj2 $ Data.Vec.map (_$ e) functions

{-# TERMINATING #-}
exceptionallyEvaluate = exceptionallyEvaluate.main
\end{code}

\section{Completing The Algebraic Equality Determination Function}

\begin{code}
module checkAlgebraicEquality where
  with-dec : {x y : ε} →
             ℕ →
             Dec (x ≡ y) →
             Exceptional (Maybe (AlgebraicEquality x y))
  with-dec iters (yes eq) = inj₂ (just (inj₁ eq))
  with-dec iters (no neq) = {!!}

  main : ℕ → (x y : ε) → Exceptional (Maybe (AlgebraicEquality x y))
  main iterations = with-dec iterations ∘₂ structuralEqualityOnε
checkAlgebraicEquality = checkAlgebraicEquality.main
\end{code}

\section{The Less-Than Type}
A value of type \AgdaFunction{LessThan} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is less than \AgdaBound{y}.

\begin{code}
module LessThan where
\end{code}

\subsection{The Basic Less-Than Type}
Basically, some value of type \AgdaFunction{LT} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} can be trivially, i.e., without using evaluation steps, shown to be less than \AgdaBound{y}.

As far as Casanova Fly is concerned, no value is greater than infinity; accordingly, \AgdaFunction{LessThan} \AgdaBound{x} \AgdaBound{Infinity} is \AgdaDatatype{⊥} for all \AgdaBound{x}.

\begin{code}
  LT : ε → ε → Set
  LT _ Infinity = ⊥
  LT Infinity (Variable x) = ⊥
  LT Infinity (NumberRat x) = ⊥
  LT Infinity (Ap f x) = ⊥
  LT (Variable x) (Variable y) = ⊥
  LT (Variable x) (NumberRat y) = ⊥
  LT (Variable x) (Ap f y) = ⊥
  LT (NumberRat x) (Variable y) = ⊥
  LT (NumberRat x) (NumberRat y) = x ℚ.< y
  LT (NumberRat x) (Ap f y) = {!!}
  LT (Ap f x) (Variable y) = ⊥
  LT (Ap f x) (NumberRat y) = {!!}
  LT (Ap f x) (Ap g y) = {!!}
\end{code}

\subsection{The \AgdaFunction{Exceptional} Less-Than Type}
Some thing is a value of type \AgdaFunction{LT2} \AgdaBound{x} \AgdaBound{y} if and only if \AgdaBound{x} and \AgdaBound{y} are \AgdaInductiveConstructor{inj₂}-containers for values \AgdaBound{x'} and \AgdaBound{y'}, respectively, and \AgdaBound{x'} can be trivially shown to be less than \AgdaBound{y'}.

\begin{code}
  LT2 : Exceptional ε → Exceptional ε → Set
  LT2 (inj₂ x) (inj₂ y) = LT x y
  LT2 _ _ = ⊥
\end{code}

\subsection{The Complex Less-Than Type}
In this case, ``complex'' is justified by \AgdaDatatype{\AgdaUnderscore{}⊎\AgdaUnderscore{}}'s relevance to the type, not complex numbers or something, although complex numbers are supported!  Anyway, according to \AgdaFunction{LessThan}, \AgdaBound{x} is less than \AgdaBound{y} if and only if \AgdaBound{x} can be trivially shown to be less than \AgdaBound{y}, or commutative evaluation reduces \AgdaBound{x} and \AgdaBound{y} to \AgdaBound{x'} and \AgdaBound{y'} such that \AgdaBound{x'} can be trivially shown to be less than \AgdaBound{y'}.

\begin{code}
  LessThan : ε → ε → Set
  LessThan x y =
    _⊎_ (LT x y)
        (let rEvaluate = flip repeatExceptional commutativeEvaluate in
         (Σ (ℕ × ℕ) (λ (m , n) → LT2 (rEvaluate m x) (rEvaluate n y))))
\end{code}

\subsection{Exporting the Function}
\AgdaFunction{LessThan.LessThan} has all necessary properties for the \AgdaFunction{LessThan} function; accordion, \AgdaFunction{LessThan} is really just \AgdaFunction{LessThan.LessThan}.

\begin{code}
LessThan = LessThan.LessThan
\end{code}

\section{The Variable Usedness Type}
\AgdaBound{name} is the name of a variable which is referenced in \AgdaBound{e} if and only if there exists a value of type \AgdaFunction{IsReferencedIn} \AgdaBound{name} \AgdaBound{e}.

\begin{code}
{-# TERMINATING #-}
IsReferencedIn : String → ε → Set
IsReferencedIn name Infinity = ⊥
IsReferencedIn name (NumberRat r) = ⊥
IsReferencedIn name (Variable name2) = name ≡ name2
IsReferencedIn name (Ap f list) = AnyVec.Any (IsReferencedIn name) list
\end{code}

\chapter{Wrapping up Everything}

\begin{code}
CasanovaFly-Base : CAS ε
CasanovaFly-Base = record
  { _≈_ = AlgebraicEquality
  ; _<_ = LessThan
  ; definitelyEquals = checkAlgebraicEquality
  ; isDefinitelyLessThan = {!!}
  ; exceptionallyEvaluate = commutativeEvaluate
  ; structuralEquality = structuralEqualityOnε
  ; fromℕ = NumberNat
  ; variableNamed = Variable
  ; _+_ = λ a b → Ap Sum (a ∷ b ∷ [])
  ; _-_ = λ x y → Ap Sum (x ∷ [ Ap Negate [ y ] ])
  ; _*_ = λ x y → Ap Product (x ∷ [ y ])
  ; _/_ = λ x y → Quotient x y (Coprimality.sym (Coprimality.1-coprimeTo 1))
  ; _^_ = λ x y → Ap Exponent (x ∷ [ y ])
  ; sin = Ap Sin ∘ [_]
  ; cos = Ap Cos ∘ [_]
  ; tan = Ap Tan ∘ [_]
  ; csc = Ap Csc ∘ [_]
  ; sec = Ap Sec ∘ [_]
  ; cot = Ap Cot ∘ [_]
  ; derivative = λ name e → Ap (Derivative name) [ e ]
  ; antiderivative = λ name e → Ap (Antiderivative name) [ e ]
  ; limit = λ n b e → Ap (Limit n) (b ∷ [ e ])
  ; boundedIntegral = λ name b1 b2 e → Ap (BoundedIntegral name) (b1 ∷ b2 ∷ [ e ])
  ; substituteVariables = varSubstM
  ; IsNameOfVariableIn = IsReferencedIn
  ; IsReal = {!!}
  ; τ = {!!}
  ; lambda = λ name e1 e2 → Ap (Lambda List.[ name ] e1) [ e2 ]
  ; negation = Ap Negate ∘ [_]
  ; different-if-nats-are-different = {!!}
  ; differently-named-variables-are-different = {!!}
  }

CasanovaFly-Verified : VCAS CasanovaFly-Base
CasanovaFly-Verified = record
  { equality-is-equivalence = record
    { refl = inj₁ refl
    ; sym = equality-is-symmetric
    ; trans = {!!}
    }
  ; sum-of-nats-is-nat-sum = sum-of-nats-is-nat-sum
  ; product-of-e-and-1-is-e = {!!}
  ; structural-equality-implies-definite-equality =
    structural-equality-implies-definite-equality
  ; identically-named-variables-are-equal = invae
  ; differently-named-variables-are-not-definitely-equal = {!!}
  ; difference-is-negated-sum = {!!}
  ; inverse-of-inverse-is-original = invert-inverse
  ; division-by-zero-is-bogus = division-by-zero-is-bogus
  ; sum-is-not-bogus = {!!}
  ; sum-is-commutative = {!!}
  ; product-is-commutative = {!!}
  ; sum-is-associative = {!!}
  ; product-of-quotient-is-same = {!!}
  ; 0^0-is-bogus = 1 , _ , refl
  ; 0^-n-is-bogus = {!!}
  ; limit-of-unrelated-value-is-unrelated-value = {!!}
  ; simple-lambda-substitution-works = {!!}
  ; nonapplicable-lambda-returns-lambda-body = {!!}
  ; unrelated-derivative = {!!}
  ; sin-n*pi-is-zero = {!!}
  ; garbage-variable-substitution-fails = {!!}
  ; substitution-order-is-irrelevant = {!!}
  ; derivative-of-constant = {!!}
  ; derivative-of-sine = {!!}
  ; derivative-of-cosine = {!!}
  ; derivative-of-tangent = {!!}
  ; derivative-of-cosecant = {!!}
  ; derivative-of-secant = {!!}
  ; derivative-of-cotangent = {!!}
  ; derivative-of-sum-is-sum-of-derivatives = {!!}
  }
  where
  open CAS CasanovaFly-Base
  open InternalEqualityFunctions

  equality-is-symmetric : Symmetric _≈_
  equality-is-symmetric (inj₁ refl) = inj₁ refl
  equality-is-symmetric (inj₂ (inj₁ complexAlgebraic)) = {!!}
  equality-is-symmetric (inj₂ (inj₂ evaluatedEquality)) = {!!}

  mapMaybe-justness-implies-output-justness :
    {a b : Level} →
    {A : Set a} →
    {B : Set b} →
    (f : A → Maybe B) →
    (x : List.List A) →
    (e : A) →
    Is-just (f e) →
    e ∈ x →
    Σ B (λ y → List.head (List.mapMaybe f x) ≡ just y)
  mapMaybe-justness-implies-output-justness = {!!}

  sum-of-nats-is-nat-sum :
    (n1 n2 : ℕ) →
    equal-at-some-iteration (fromℕ n1 + fromℕ n2) (fromℕ (n1 Data.Nat.+ n2))
  sum-of-nats-is-nat-sum n1 n2 = 1 , {!!}

  invert-inverse : (e : ε) → equal-at-some-iteration e (Ap Negate [ Ap Negate [ e ] ])
  invert-inverse e = 1 , inv-inv-propEq e , {!!}
    where
    inv = Ap Negate ∘ [_]
    inv-inv-propEq :
      (e : ε) →
      e ≈ inv (inv e)
    -- Regardless of *eventual* bogosity, the first step *should* be fine.
    inv-inv-propEq e = inj₂ (inj₂ ((0 , 1) ,  {!!}))

  division-by-zero-is-bogus :
    (e1 e2 : ε) →
    equal-at-some-iteration (fromℕ 0) e2 →
    bogus-at-some-iteration (e1 / e2)
  division-by-zero-is-bogus x y (iters , eq) with bogusBeforeIteration? (ℕ.suc iters) (x / y)
    where
    bogusBeforeIteration? :
      (n : ℕ) →
      (e : ε) →
      Maybe ((Σ (Fin n) (λ f → bogus-at-iteration (Fin.toℕ f) e)))
    bogusBeforeIteration? = {!!}
  ... | just (f , bogus) = Fin.toℕ f , bogus
  ... | nothing = ℕ.suc iters , _ , sym inj1Equality
    where
    inj1Equality = begin
      rEvaluate (ℕ.suc iters) (x / y)
        ≡⟨ {!!} ⟩
      inj₁ {!!} ∎

  structural-equality-implies-definite-equality :
    (e1 e2 : ε) →
    e1 ≡ e2 →
    (iterations : ℕ) →
    equal-at-iteration iterations e1 e2
  structural-equality-implies-definite-equality = {!!}

  invae : (name1 name2 : String) →
          name1 ≡ name2 →
          equal-at-some-iteration (Variable name1) (Variable name2)
  invae = {!!}
\end{code}
\end{document}
