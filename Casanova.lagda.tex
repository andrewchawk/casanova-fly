\documentclass{report}

\usepackage{newunicodechar}
\usepackage{geometry}[margin=1.25in]
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
% The coloring distracts the author.
\usepackage[bw]{agda}
\usepackage{unicode-math}
\usepackage{physics}
\usepackage{fancyref}
\usepackage[toc]{glossaries}
\usepackage[backend=bibtex]{biblatex}

\addbibresource{citationNeeded.bib}

\newcommand{\Epsilon}{E}

% What is a good place for this crap?
\newunicodechar{⊤}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{⊥}{\ensuremath{\mathnormal{\bot}}}
\newunicodechar{ℕ}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{₁}{\ensuremath{\mathnormal{_1}}}
\newunicodechar{₂}{\ensuremath{\mathnormal{_2}}}
\newunicodechar{≅}{\ensuremath{\mathnormal{\cong}}}
\newunicodechar{ε}{\ensuremath{\mathnormal{\epsilon}}}
\newunicodechar{τ}{\ensuremath{\mathnormal{\tau}}}
\newunicodechar{λ}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{ℚ}{\ensuremath{\mathnormal{\mathbb{Q}}}}
\newunicodechar{ℤ}{\ensuremath{\mathnormal{\mathbb{Z}}}}
\newunicodechar{∷}{\ensuremath{\mathnormal{\Colon}}}
\newunicodechar{⊎}{\ensuremath{\mathnormal{\uplus}}}
\newunicodechar{≈}{\ensuremath{\mathnormal{\approx}}}
\newunicodechar{≉}{\ensuremath{\mathnormal{\napprox}}}
\newunicodechar{≡}{\ensuremath{\mathnormal{\equiv}}}
\newunicodechar{≢}{\ensuremath{\mathnormal{\nequiv}}}
\newunicodechar{≤}{\ensuremath{\mathnormal{\leq}}}
\newunicodechar{⊔}{\ensuremath{\mathnormal{\sqcup}}}
\newunicodechar{≟}{\ensuremath{\mathnormal{\stackrel{?}{=}}}}
\newunicodechar{∘}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{∧}{\ensuremath{\mathnormal{\land}}}
\newunicodechar{∧}{\ensuremath{\mathnormal{\land}}}
\newunicodechar{⇒}{\ensuremath{\mathnormal{\Rightarrow}}}
\newunicodechar{⟨}{\ensuremath{\mathnormal{\langle}}}
\newunicodechar{⟩}{\ensuremath{\mathnormal{\rangle}}}
\newunicodechar{∎}{\ensuremath{\mathnormal{\blacksquare}}}
\newunicodechar{∈}{\ensuremath{\mathnormal{\in}}}
\newunicodechar{∉}{\ensuremath{\mathnormal{\notin}}}
\newunicodechar{ᵇ}{\ensuremath{\mathnormal{^\AgdaFontStyle{b}}}}
\newunicodechar{∣}{\ensuremath{\mathnormal{\lvert}}}
\newunicodechar{↭}{\ensuremath{\mathnormal{\leftrightsquigarrow}}}

\title{Casanova Fly: A Formally-Verified Computer Algebra System}
\author{Andrew Christopher Hawk}

\makeglossaries{}

\begin{document}
\maketitle{}

\begin{abstract}
In writing this paper, the author tries to answer the following questions:

\begin{itemize}
  \item Formally, what constitutes a computer algebra system, i.e., what are the essential functions of a computer algebra system?
  \item Formally, what constitutes a formally-verified computer system?  In other words, what guarantees can be made about \emph{all} good computer algebra systems?
  \item What is an example of such a formally-verified computer algebra system?
\end{itemize}

In short, the answer to the last question is ``Casanova Fly, of course''.  The remaining questions are hairy and are best answered through the non-abbreviated version of this paper.
\end{abstract}

\tableofcontents

\part{Generic Stuff}

\chapter{Prerequisites for Understanding}
The author recommends that anyone who tries to understand Casanova Fly is familiar with the following modules, which are defined in \cite{The_Agda_Community_Agda_Standard_Library_2024}:

\begin{code}
open import Function
open import Data.Fin using (Fin)
open import Data.Nat using (ℕ)
open import Data.Sum
open import Level
open import Data.String hiding (_≈_; _<_; _≤_)
open import Relation.Binary.PropositionalEquality renaming ([_] to ⟦_⟧)
open ≡-Reasoning
open import Data.Vec
open import Data.Maybe
open import Relation.Nullary
open import Relation.Binary
open import Data.Bool hiding (_<_; _≤_)
open import Data.Rational
  as ℚ
  using (ℚ
        )
open import Data.Product
open import Data.List.Relation.Unary.Any as AnyList using (any?)
open import Data.Fin as Fin using (Fin)
open import Data.List.Relation.Unary.Unique.Propositional
  renaming
    ( Unique to UniqueList
    )
open import Relation.Nullary.Decidable
  using
    ( dec-yes
    )
open import Data.Empty.Polymorphic using (⊥)
open import Data.List.Membership.Propositional
open import Data.Unit.Polymorphic
open import Data.List.Relation.Binary.Permutation.Propositional
  as PermutationList
  using
    ( _↭_
    )
open import Relation.Binary.PropositionalEquality.WithK
  using
    ( ≡-irrelevant
    )
import Data.List as List
import Data.Nat.Coprimality as Coprimality
import Data.Integer
import Data.Sum.Properties
import Data.List.Relation.Unary.All as AllList
import Data.List.Relation.Unary.All.Properties as AllListProp
import Data.List.Relation.Unary.AllPairs as AllPairsList
import Data.Maybe.Properties
import Data.Maybe.Relation.Unary.Any as AnyMaybe
import Data.Nat.Properties
import Data.Product.Properties as ProdProp
import Data.Vec.Properties as VecProp
import Data.Vec.Relation.Unary.Any as AnyVec
import Data.Vec.Relation.Unary.All as AllVec
import Data.List.Properties as ListProp
import Data.Maybe.Relation.Unary.All as AllMaybe
\end{code}

\chapter{Useful Abbreviations and Ilk}

\section{The Exception Type}
A value of type \AgdaFunction{Exceptional} \AgdaBound{A} can be a success-indicating value of \AgdaBound{A} or a \AgdaPostulate{String} which describes some sort of failure.

\begin{code}
Exceptional : {a : Level} → Set a → Set a
Exceptional A = String ⊎ A
\end{code}

\subsection{The Exception Condensation Function}
If no values are exceptional, then the output contains the combination of both non-exceptional values.  Otherwise, the output contains the first exceptional value.

\begin{code}
condenseExceptions : {a : Level} →
                     {A : Set a} →
                     Exceptional A →
                     Exceptional A →
                     Exceptional (A × A)
condenseExceptions (inj₂ x) (inj₂ y) = inj₂ (x , y)
condenseExceptions (inj₁ e) _ = inj₁ e
condenseExceptions _ (inj₁ e) = inj₁ e
\end{code}

\section{The Exceptional List Condensation Function}
Informally, one can say that \AgdaFunction{condenseExceptionList} \AgdaBound{l} \gls{inj2contain} all values in \AgdaBound{l}, or, if applicable, \AgdaFunction{condenseExceptionList} \AgdaBound{l} \gls{inj2contain} the first exceptional value in \AgdaBound{l}.  Formally and righteously, one can say that the following statements apply:

\begin{enumerate}
  \item \AgdaFunction{condenseExceptionList} \AgdaBound{l} contains an \AgdaInductiveConstructor{inj₁} value if and only if \AgdaFunction{condenseExceptionList} \AgdaBound{l} is the first exceptional value in \AgdaBound{l}.\label{enum:condenseExceptionList-inj1}
  \item \AgdaFunction{condenseExceptionList} \AgdaBound{l} is \AgdaInductiveConstructor{inj₂} \AgdaBound{l} if and only if all elements in \AgdaBound{l} are \AgdaInductiveConstructor{inj₂} values.\label{enum:condenseExceptionList-inj2}
\end{enumerate}

\begin{code}
condenseExceptionList :
  {a : Level} →
  {A : Set a} →
  {n : ℕ} →
  Vec (Exceptional A) n →
  Exceptional (Vec A n)
condenseExceptionList [] = inj₂ []
condenseExceptionList (inj₁ x ∷ xs) = inj₁ x
condenseExceptionList (inj₂ x ∷ xs) =
  [_,_] inj₁ (inj₂ ∘ _∷_ x) (condenseExceptionList xs)
\end{code}

\section{The Exceptional Function Reapplication Function}
Informally, one can say that \AgdaFunction{repeatExceptional} \AgdaBound{n} \AgdaBound{f} \AgdaBound{x} applies \AgdaBound{f} to \AgdaBound{x} \AgdaBound{n} times; \AgdaInductiveConstructor{inj₂} values are subject to reapplication, and \AgdaInductiveConstructor{inj₁} values are immediately returned.  Formally, one can say that the following statements apply:

\begin{enumerate}
  \item \AgdaFunction{repeatExceptional} \AgdaNumber{0} \AgdaBound{f} \AgdaBound{x} is \AgdaInductiveConstructor{inj₂} \AgdaBound{x}.\label{enum:repeatExceptional-zeroIsInj2}
  \item If \AgdaBound{f} \AgdaBound{x} is some \AgdaInductiveConstructor{inj₁} value, then then \AgdaFunction{repeatExceptional} \AgdaBound{n} \AgdaBound{f} \AgdaBound{x} is \AgdaBound{f} \AgdaBound{x}.\label{enum:repeatExceptional-inj1GetsReturned}
  \item If \AgdaBound{f} \AgdaBound{x} is some value \AgdaInductiveConstructor{inj₂} \AgdaBound{x'}, then \AgdaFunction{repeatExceptional} \AgdaSymbol(\AgdaInductiveConstructor{ℕ.suc} \AgdaBound{n}\AgdaSymbol) \AgdaBound{f} \AgdaBound{x} is equivalent to \AgdaFunction{repeatExceptional} \AgdaBound{n} \AgdaBound{f} \AgdaBound{x'}.\label{enum:inj2GetsRepeat}
\end{enumerate}

\begin{code}
module repeatExceptional where
  repeatExceptional :
    {a b : Level} →
    {A : Set a} →
    {B : Set b} →
    ℕ → (f : A → B ⊎ A) → A → B ⊎ A
  repeatExceptional 0 f x = inj₂ x
  repeatExceptional (ℕ.suc n) f x =
    [_,_] inj₁ (repeatExceptional n f) (f x)
\end{code}

\subsection{The Properties of the Function}

\begin{code}
  module Properties
    {a b : Level}
    {A : Set a}
    {B : Set b}
    (f : A → B ⊎ A)
    (x : A) where
\end{code}

\subsubsection{The Zero Proof}
\AgdaFunction{zero-is-inj2}, indicates that in accordance with \fref{enum:repeatExceptional-zeroIsInj2}, \AgdaFunction{repeatExceptional} \AgdaNumber{0} \AgdaBound{f} \AgdaBound{x} is just \AgdaBound{f} \AgdaBound{x}.

\begin{code}
    zero-is-inj2 : repeatExceptional 0 f x ≡ inj₂ x
    zero-is-inj2 = refl
\end{code}

\subsubsection{The \AgdaInductiveConstructor{inj₁} Proof}
In accordance with \fref{enum:repeatExceptional-inj1GetsReturned}, \AgdaFunction{inj₁-immediate-return} indicates that if \AgdaBound{f} \AgdaBound{x} is some \AgdaInductiveConstructor{inj₁} value, then \AgdaFunction{repeatExceptional} \AgdaSymbol(\AgdaInductiveConstructor{ℕ.suc} \AgdaBound{n}\AgdaSymbol) \AgdaBound{f} \AgdaBound{x} is always \AgdaBound{f} \AgdaBound{x}.

\begin{code}
    inj1-immediate-return :
      {x' : B} →
      (n : ℕ) →
      f x ≡ inj₁ x' →
      repeatExceptional (ℕ.suc n) f x ≡ f x
    inj1-immediate-return {x'} 0 equality = begin
      [_,_]′ inj₁ (repeatExceptional 0 f) (f x)
        ≡⟨ cong ([_,_]′ inj₁ (repeatExceptional 0 f)) equality ⟩
      inj₁ x'
        ≡⟨ sym equality ⟩
      f x ∎
    inj1-immediate-return {x'} (ℕ.suc n) equality = begin
      repeatExceptional (ℕ.suc (ℕ.suc n)) f x
        ≡⟨⟩
      [_,_]′ inj₁ (repeatExceptional (ℕ.suc n) f) (f x)
        ≡⟨ cong ([_,_] inj₁ (repeatExceptional (ℕ.suc n) f)) equality ⟩
      [_,_]′ inj₁ (repeatExceptional (ℕ.suc n) f) (inj₁ x')
        ≡⟨⟩
      inj₁ x'
        ≡⟨ sym equality ⟩
      f x ∎
\end{code}

\subsubsection{The \AgdaInductiveConstructor{inj₂} Proof}
In accordance with \fref{enum:inj2GetsRepeat}, \AgdaFunction{inj2-repeat} indicates that if \AgdaBound{f} \AgdaBound{x} is some \AgdaInductiveConstructor{inj₂} \AgdaBound{x'}, then \AgdaFunction{repeatExceptional} \AgdaSymbol(\AgdaInductiveConstructor{ℕ.suc} \AgdaBound{n}\AgdaSymbol) \AgdaBound{f} \AgdaBound{x} is \AgdaFunction{repeatExceptional} \AgdaBound{n} \AgdaBound{f} \AgdaBound{x'}..

\begin{code}
    inj2-repeat :
      {x' : A} →
      (n : ℕ) →
      f x ≡ inj₂ x' →
      repeatExceptional (ℕ.suc n) f x ≡ repeatExceptional n f x'
    inj2-repeat {x'} n equality = begin
      repeatExceptional (ℕ.suc n) f x
        ≡⟨⟩
      [_,_]′ inj₁ (repeatExceptional n f) (f x)
        ≡⟨ cong ([_,_]′ inj₁ (repeatExceptional n f)) equality ⟩
      repeatExceptional n f x' ∎
\end{code}

\subsection{Exporting the Function}
``\AgdaFunction{repeatExceptional.repeatExceptional}'' is a bit repetitive and long, so the author encourages and enables the use of ``\AgdaFunction{repeatExceptional}''.

\begin{code}
repeatExceptional = repeatExceptional.repeatExceptional
\end{code}

\section{The First Repeat Position Function}
\AgdaFunction{firstRepeatPosition} is such that the following statements hold:

\begin{itemize}
  \item If \AgdaBound{x} contains no repeating elements, then \AgdaFunction{firstRepeatPosition} \AgdaBound{DEQ} \AgdaBound{x} is \AgdaInductiveConstructor{nothing}.
  \item If \AgdaBound{x} has repeating values, then \AgdaFunction{firstRepeatPosition} \AgdaBound{DEQ} \AgdaBound{x} contains the position of the first repeating value in \AgdaBound{x}.  A bit more formally, one can say that if \(v\) is some value which occurs at multiple positions in \AgdaBound{x}, and there exists no value \(w\) such that \(w\) occurs at multiple positions in \AgdaBound{x} and occupies a position which precedes the first index of \(v\), then \AgdaFunction{firstRepeatPosition} \AgdaBound{DEQ} \AgdaBound{x} contains the first index of \(v\) in \AgdaBound{x}.  Way more formally, one can refer to the definition in \fref{sec:firstRepeatPosition-isFirst}.\label{enum:firstRepeatPosition-isFirst}
\end{itemize}

\begin{code}
module firstRepeatPosition
  {a : Level}
  {A : Set a}
  (DEQ : DecidableEquality A) where

  firstRepeatPosition : (x : List.List A) → Maybe (Fin (List.length x))
  firstRepeatPositionHelper : (x y : List.List A) → Maybe (Fin (List.length y))

  firstRepeatPosition = firstRepeatPositionHelper List.[]

  firstRepeatPositionHelper x List.[] = nothing
  firstRepeatPositionHelper List.[] (y List.∷ ys) =
    Data.Maybe.map Fin.suc (firstRepeatPositionHelper List.[ y ] ys)
  firstRepeatPositionHelper (x List.∷ xs) (y List.∷ ys) =
    if isYes (any? (DEQ y) (x List.∷ xs))
      then just Fin.zero
      else Data.Maybe.map Fin.suc (firstRepeatPositionHelper (y List.∷ x List.∷ xs) ys)
\end{code}

\subsection{The Properties of the Function}
This module contains a few proofs which indicates that \AgdaFunction{firstRepeatPosition} really does work as described, after all.  For the sake of improving readability and preventing a repetitive strain injury, the author has also provided an abbreviation of the main function's name.

\begin{code}
  module Properties where

    pos = firstRepeatPosition
    posh = firstRepeatPositionHelper
\end{code}

\subsubsection{The Unique Prepending Proof}
\AgdaFunction{unique-element-prepend} indicates that if \AgdaBound{x} is not in \AgdaBound{xs}, then \AgdaFunction{pos} \AgdaSymbol(\AgdaBound{x} \AgdaOperator{\AgdaFunction{List.∷}} \AgdaBound{xs}\AgdaSymbol) contains the successor of \AgdaFunction{pos} \AgdaBound{xs} or is \AgdaInductiveConstructor{nothing}.

\begin{code}
    unique-element-prepend :
      (x : A) →
      (xs : List.List A) →
      AllList.All (_≢_ x) xs →
      pos (x List.∷ xs) ≡ Data.Maybe.map Fin.suc (pos xs)
    unique-element-prepend x List.[] all = refl
    unique-element-prepend x xs@(x1 List.∷ xs1) alls@(a AllList.∷ as) = begin
      pos (x List.∷ xs)
        ≡⟨⟩
      mapSuc (posh List.[ x ] xs)
        ≡⟨⟩
      mapSuc (if isYes (any? (DEQ x1) List.[ x ])
                 then just Fin.zero
                 else mapSuc (posh (x1 List.∷ List.[ x ]) xs1))
        ≡⟨ cong (λ e → mapSuc (if isYes e
                                   then just Fin.zero
                                   else mapSuc (posh (x1 List.∷ List.[ x ]) xs1)))
                x1-is-decidably-not-in-[x] ⟩
      mapSuc (mapSuc (posh (x1 List.∷ List.[ x ]) xs1))
        ≡⟨ cong mapSuc (sym (posh-moves-elements {x} {x1} {xs1} )) ⟩
      mapSuc (posh List.[ x ] xs)
        ≡⟨ cong mapSuc (sym (pos-is-posh {x} {xs} alls)) ⟩
      mapSuc (posh List.[] xs) ∎
      where
      mapSuc : {n : ℕ} → Maybe (Fin n) → Maybe (Fin (ℕ.suc n))
      mapSuc = Data.Maybe.map Fin.suc
      posh-moves-elements :
        {x y : A} →
        {xs : List.List A} →
        _≡_ (posh List.[ x ] (y List.∷ xs))
            (Data.Maybe.map Fin.suc (posh (y List.∷ List.[ x ]) xs))
      posh-moves-elements = {!!}
      pos-is-posh :
        {x : A} →
        {xs : List.List A} →
        AllList.All (_≢_ x) xs →
        pos xs ≡ posh List.[ x ] xs
      pos-is-posh = {!!}
      x1-is-decidably-not-in-[x] :
        _≡_ (any? (DEQ x1) List.[ x ])
            (no (AllListProp.All¬⇒¬Any ((_∘ sym) a AllList.∷ AllList.[])))
      x1-is-decidably-not-in-[x] = {!!}
\end{code}

\subsubsection{The Proof of Nothingness's Implication of Uniqueness}
\AgdaFunction{pos-is-nothing-only-if-list-is-unique} indicates that \AgdaFunction{pos} \AgdaBound{xs} is \AgdaInductiveConstructor{nothing} only if \AgdaBound{xs} is a unique list.

\begin{code}
    pos-is-nothing-only-if-list-is-unique :
      (x : List.List A) →
      pos x ≡ nothing →
      UniqueList x
    pos-is-nothing-only-if-list-is-unique = {!!}
\end{code}

\subsubsection{The Prepended Nonunique List Proof}
\AgdaFunction{nonunique-prepend} indicates that the result of prepending a value to a non-unique list is \emph{also} a non-unique list.

\begin{code}
    nonunique-prepend :
      (x : A) →
      (xs : List.List A) →
      Is-just (pos xs) →
      Is-just (pos (x List.∷ xs))
    nonunique-prepend x (y List.∷ ys) nonUniqueness with any? (DEQ x) (y List.∷ ys)
    ... | no xIsUniqueInYYs = justness-implies-justness index equality
      where
      index : Fin (List.length (x List.∷ y List.∷ ys))
      index = Fin.suc (to-witness nonUniqueness)
      justness-implies-justness :
        {a : Level} →
        {A : Set a} →
        {x : Maybe A} →
        (y : A) →
        x ≡ just y →
        Is-just x
      justness-implies-justness y refl = AnyMaybe.just _
      self-is-just-to-witness :
        {a : Level} →
        {A : Set a} →
        {x : Maybe A} →
        (isJust : Is-just x) →
        x ≡ just (to-witness isJust)
      self-is-just-to-witness {x = just x} (AnyMaybe.just isJust) = refl
      equality : pos (x List.∷ y List.∷ ys) ≡ just index
      equality = begin
        pos (x List.∷ y List.∷ ys)
          ≡⟨ unique-element-prepend x (y List.∷ ys)
                                    (AllListProp.¬Any⇒All¬ _ xIsUniqueInYYs) ⟩
        Data.Maybe.map Fin.suc (pos (y List.∷ ys))
          ≡⟨ cong (Data.Maybe.map Fin.suc) (self-is-just-to-witness nonUniqueness) ⟩
        Data.Maybe.map Fin.suc (just (to-witness nonUniqueness))
          ≡⟨⟩
        just index ∎
    ... | yes xAppears = {!!}
\end{code}

\subsubsection{The Proof of Recursive Nothingness}
\AgdaFunction{pos-is-nothing-only-if-removal-is-nothing} indicates that \AgdaFunction{pos} \AgdaSymbol(\AgdaBound{x} \AgdaOperator{\AgdaFunction{∷}} \AgdaBound{xs}\AgdaSymbol) is \AgdaBound{nothing} only if \AgdaBound{xs} is unique.  Equivalently, one can say that the function proves that the result of appending an element \(x\) to a list \(xs\) is a unique list only if \(xs\) is a unique list.

\begin{code}
    pos-is-nothing-only-if-removal-is-nothing :
      {x : A} →
      {xs : List.List A} →
      pos (x List.∷ xs) ≡ nothing →
      pos xs ≡ nothing
    pos-is-nothing-only-if-removal-is-nothing {x} {List.[]} always = refl
    pos-is-nothing-only-if-removal-is-nothing {x} {y List.∷ ys} isNothing with NOTHINGNESS
      where
      NOTHINGNESS : Dec (pos (y List.∷ ys) ≡ nothing)
      NOTHINGNESS = Data.Maybe.Properties.≡-dec Fin._≟_ _ _
    ... | yes alreadyDone = alreadyDone
    ... | no bogus = contradiction isNothing (just-is-not-nothing isJust)
      where
      module _
        {a : Level}
        {A : Set a} where

        nonnothing-is-just : {x : Maybe A} → x ≢ nothing → Is-just x
        nonnothing-is-just {x = just x} notNothing = AnyMaybe.just _
        nonnothing-is-just {x = nothing} notNothing = contradiction refl notNothing

        just-is-not-nothing : {x : Maybe A} → Is-just x → x ≢ nothing
        just-is-not-nothing {x = just x} j ()

      isJust = nonunique-prepend x (y List.∷ ys) (nonnothing-is-just bogus)
\end{code}

\subsubsection{The Proof of Being Nothing}
\AgdaFunction{pos-of-unique-list-is-length} indicates that \AgdaFunction{firstRepeatPosition} \AgdaBound{x} is \AgdaInductiveConstructor{nothing} if all elements of \AgdaBound{x} are unique.

\begin{code}
    pos-of-unique-list-is-nothing :
      (x : List.List A) →
      UniqueList x →
      pos x ≡ nothing
    pos-of-unique-list-is-nothing List.[] u = refl
    pos-of-unique-list-is-nothing (x List.∷ xs) (u AllPairsList.∷ us) =
      unique-prepend-nothing u (pos-of-unique-list-is-nothing xs us)
      where
      unique-prepend-nothing :
        {x : A} →
        {xs : List.List A} →
        AllList.All (_≢_ x) xs →
        pos xs ≡ nothing →
        pos (x List.∷ xs) ≡ nothing
      unique-prepend-nothing AllList.[] refl = refl
      unique-prepend-nothing {x} xs@{x1 List.∷ xs1} alls eq with any? (DEQ x) xs
      ... | yes nonsense = contradiction nonsense (AllListProp.All¬⇒¬Any alls)
      ... | no obviously = begin
        pos (x List.∷ xs)
          ≡⟨ unique-element-prepend x xs alls ⟩
        Data.Maybe.map Fin.suc (pos xs)
          ≡⟨ cong (Data.Maybe.map Fin.suc) pos-xs-is-nothing ⟩
        nothing ∎
        where
        x1-is-not-in-xs1 : AllList.All (_≢_ x1) xs1
        x1-is-not-in-xs1 with pos-is-nothing-only-if-list-is-unique xs eq
        ... | (u AllPairsList.∷ us) = u
        pos-xs-is-nothing : pos xs ≡ nothing
        pos-xs-is-nothing =
          unique-prepend-nothing {x1} {xs1}
                                 x1-is-not-in-xs1
                                 (pos-is-nothing-only-if-removal-is-nothing {x1} {xs1} eq)
\end{code}

\subsubsection{The Proof of Equalling the Position of the First Repeating Value}
\AgdaFunction{pos-is-position-of-first-repeat} indicates that \AgdaFunction{firstRepeatPosition} \AgdaBound{x} contains the position of the first repeating value in \AgdaBound{x} if \AgdaBound{x} has such a value.  Equivalently, one can say that \AgdaFunction{pos-is-position-of-first-repeat} proves that \fref{enum:firstRepeatPosition-isFirst} actually applies.

\begin{code}
    pos-is-position-of-first-repeat :
      (l : List.List A) →
      (v : A) →
      (vi1 vi2 : Fin (List.length l)) →
      List.lookup l vi1 ≡ v →
      List.lookup l vi2 ≡ v →
      (vi1-is-first : (index : Fin (List.length l)) →
                      index Data.Fin.< vi1 →
                      List.lookup l index ≢ v) →
      ¬ (Σ (A × Fin (List.length l) × Fin (List.length l))
           (λ (w , wi1 , wi2) →
                List.lookup l wi1 ≡ w
              × List.lookup l wi2 ≡ w
              × wi1 Data.Fin.< vi1)) →
      pos l ≡ just vi1
    pos-is-position-of-first-repeat = {!!}
\end{code}

\subsubsection{The Proof of the Noncontainment of Zero}
\AgdaFunction{pos-is-never-zero} indicates that for no \AgdaBound{x}, \AgdaFunction{pos} \AgdaBound{x} contains a zero value.

\begin{code}
    pos-is-never-zero :
      (x : List.List A) →
      Data.Maybe.map Fin.toℕ (pos x) ≢ just 0
    pos-is-never-zero List.[] ()
    pos-is-never-zero (x List.∷ List.[]) ()
    pos-is-never-zero (x List.∷ xs) = {!!}
\end{code}

\subsection{Exporting the Function}
``\AgdaFunction{firstRepeatPosition.firstRepeatPosition}'' is a bit long; as such, the author has elected to permit using the relatively short --- but still mildly verbose --- ``\AgdaFunction{firstRepeatPosition}''.  Praise be.

\begin{code}
firstRepeatPosition = firstRepeatPosition.firstRepeatPosition
\end{code}

\section{The Non-Repeating Subsequence Function}
\AgdaFunction{nonRepeatingPortion} \AgdaBound{DEQ} \AgdaBound{x} is the longest initial non-repeating consecutive subsequence within \AgdaBound{x}.  Equivalently, one can say that \AgdaFunction{nonRepeatingPortion} \AgdaBound{DEQ} \AgdaBound{x} is equivalent to \AgdaFunction{List.take} \AgdaBound{n} \AgdaBound{x}, where \AgdaBound{n} is such that \AgdaFunction{List.take} \AgdaBound{n} \AgdaBound{x} contains no two identical values.

\begin{code}
nonRepeatingPortion : {a : Level} →
                      {A : Set a} →
                      DecidableEquality A →
                      List.List A →
                      List.List A
nonRepeatingPortion DEQ x = List.take nonRepeatLength x
  where nonRepeatLength = maybe Fin.toℕ (List.length x) (firstRepeatPosition DEQ x)
\end{code}

\subsection{Properties of the Function}
This module contains a few proofs which indicates that \AgdaFunction{notRepeatingPortion} really \emph{is} as described.  For the sake of improving readability, the author has defined some module-specific variables and abbreviated functions.

\begin{code}
module nonRepeatingPortion-Properties
  {a : Level}
  {A : Set a}
  (DEQ : DecidableEquality A) where

  private
    nrp : List.List A → List.List A
    nrp = nonRepeatingPortion DEQ
\end{code}

\subsubsection{The Proof of Being the Result of Taking}
\AgdaFunction{is-first-n-elements} \AgdaBound{x} indicates that \AgdaFunction{nrp} \AgdaBound{x} is really just the list of the first \(n\) elements of \AgdaBound{x}, where \(n\) is \AgdaFunction{List.length} \AgdaSymbol(\AgdaFunction{nrp} \AgdaBound{x}\AgdaSymbol).

\begin{code}
  is-first-n-elements :
    (x : List.List A) →
    nrp x ≡ List.take (List.length (nrp x)) x
  is-first-n-elements = {!!}
\end{code}

\subsubsection{The Proof of Non-Repetition}
\AgdaFunction{contains-no-repeats} \AgdaBound{x} indicates that any two elements of \AgdaFunction{nrp} \AgdaBound{x} which are indexed by \AgdaBound{i} and \AgdaBound{j}, respectively, are equal only if \AgdaBound{i} is equal to \AgdaBound{j}.  Equivalently, one can say that \AgdaFunction{contains-no-repeats} \AgdaBound{x} indicates that \AgdaFunction{nrp} \AgdaBound{x} is actually a unique list, i.e., \emph{contains no repeats} of values.

\begin{code}
  contains-no-repeats :
    (x : List.List A) →
    (i1 i2 : Fin (List.length (nrp x))) →
    List.lookup (nrp x) i1 ≡ List.lookup (nrp x) i2 →
    i1 ≡ i2
  contains-no-repeats List.[] ()
  contains-no-repeats (x List.∷ xs) i1 i2 equality with i1 Data.Fin.≟ i2
  ... | yes alreadyEqual = alreadyEqual
  ... | no shouldNotBe = {!!}
\end{code}

\subsubsection{The Proof which Indicates that the Value Really is the Longest Unique Sublist}
\AgdaFunction{is-really-the-longest} \AgdaBound{x} indicates that any value which immediately follows \AgdaFunction{nrp} \AgdaBound{x}'s last element of \AgdaBound{x} is already contained within \AgdaBound{nrp} \AgdaBound{x}.

\begin{code}
  is-really-the-longest :
    (x : List.List A) →
    (i : Fin (List.length x)) →
    Fin.toℕ i ≡ 1 Data.Nat.+ List.length (nrp x) →
    AnyList.Any (λ i2 → i2 ≡ List.lookup x i) (nrp x)
  is-really-the-longest = {!!}
\end{code}

\subsubsection{The Proof of Emptiness}
\AgdaFunction{only-empty-if-input-is-empty} indicates that for all lists \AgdaBound{x}, \AgdaFunction{nrp} \AgdaBound{x} is empty only if \AgdaBound{x} is empty.

\begin{code}
  only-empty-if-input-is-empty :
    (x : List.List A) →
    List.length (nrp x) ≡ 0 →
    List.length x ≡ 0
  only-empty-if-input-is-empty List.[] refl = refl
  only-empty-if-input-is-empty (x List.∷ xs) empty = contradiction empty {!!}
\end{code}

\subsubsection{The \emph{Other} Emptiness Proof}
\AgdaFunction{empty-inputs-beget-empty-outputs} indicates that the result of applying \AgdaFunction{nrp} to an empty list is just an empty list.

\begin{code}
  empty-inputs-beget-empty-outputs :
    (x : List.List A) →
    List.length x ≡ 0 →
    List.length (nrp x) ≡ 0
  empty-inputs-beget-empty-outputs List.[] refl = refl
\end{code}

\begin{code}
  nrp-of-concatenated-lists :
    (x y : List.List A) →
    nrp (x List.++ y) ≡ {!!}
  nrp-of-concatenated-lists = {!!}
\end{code}

\subsubsection{The Appending Proof}
\AgdaFunction{new-values-are-appended} indicates that if \AgdaBound{x} does not appear in \AgdaBound{xs}, then \AgdaFunction{nrp} \AgdaSymbol(\AgdaBound{xs} \AgdaOperator{\AgdaFunction{List.++}} \AgdaOperator{\AgdaFunction{List.[}} \AgdaBound{x} \AgdaOperator{\AgdaFunction{]}} is structurally identical to \AgdaFunction{nrp} \AgdaBound{xs} \AgdaOperator{\AgdaFunction{List.++}} \AgdaOperator{\AgdaFunction{List.[}} \AgdaBound{x} \AgdaOperator{\AgdaFunction{]}}.  More intuitively, one can say that new values which are appended to the input of \AgdaFunction{nrp} are \emph{also} appended to the output of \AgdaFunction{nrp}.

\begin{code}
  new-values-are-appended :
    (x : A) →
    (xs : List.List A) →
    x ∉ xs →
    nrp (xs List.++ List.[ x ]) ≡ nrp xs List.++ List.[ x ]
  new-values-are-appended x List.[] notElement = refl
  new-values-are-appended x (xs1 List.∷ xs) notElement = {!!}
\end{code}

\part{Formal Definitions for Computer Algebra Systems}

\chapter{The Type of Mostly-Unverified Computer Algebra Systems}
Fundamentally, a computer algebra system for an expression type \(\epsilon\) can be thought of as being a combination of the following:

\begin{itemize}
  \item an algebraic equality type,
  \item an algebraic less-than type,
  \item an algebraic less-than-or-equal-to type,
  \item a single-step evaluation function which is capable of describing failures,
  \item a proof of decidable structural equality of \(\epsilon\) values,
  \item a function which determines certain algebraic equality on non-bogus \(\epsilon\) values,
  \item a function which determines certain inequality on non-bogus \(\epsilon\) values,
  \item a function which converts natural number values into \(\epsilon\) values,
  \item a function which converts integer values into \(\epsilon\) values,
  \item a function which converts the name of a variable into an \(\epsilon\) variable value,
  \item a function which converts the two input expressions into a representation of the sum of the input expressions,
  \item a function which converts the two input expressions into a representation of the quotient of the input expressions,
  \item a function which converts the two input expressions \(a\) and \(b\) into \(a^b\),
  \item the six trigonometric functions, i.e., the sine function, the cosine function, the tangent function, the cosecant function, the secant function, and the cotangent function,
  \item a derivative function,
  \item an antiderivative function,
  \item a limit function,
  \item a bounded integral function,
  \item a variable substitution function,
  \item a function which converts the input into the additive inverse of the input,
  \item a lambda expression function,
  \item a variable-is-used type,
  \item an expression-is-real type,
  \item an expression-is-imaginary type,
  \item an expression-is-valid-constant type,
  \item an expression-is-infinite type,
  \item a proof which indicates that for any two natural numbers \(n_1\) and \(n_2\), if \(n_1 \neq n_2\), then the representation of \(n_1\) is not equal to the representation of \(n_2\),
  \item a proof which indicates that variables of different names are not equivalent,
  \item a function which performs the maximum number of evaluation steps on the input,
  \item a function which displays all evaluation steps which are used on a given input,
  \item a bounded bogosity check function, and
  \item some other functions which are really only terribly useful for verification.
\end{itemize}

\AgdaDatatype{CAS} is the type of such computer algebra systems.

\section{Types for Equalities and Inequalities}

\subsection{The Algebraic Equality Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}≈\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is shown to be \AgdaBound{c}-\gls{algEq} to \AgdaBound{y}.

\subsection{The Algebraic \emph{In}equality Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}≉\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is algebraically \emph{un}equal to \AgdaBound{y}.

\subsection{The Less-Than Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}<\AgdaUnderscore{}} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is less than \AgdaBound{y}.

\subsection{The Less-Than-or-Equal-to Type}
A value of type \AgdaField{CAS.\AgdaUnderscore{}≤\AgdaUnderscore{}} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is less than or equal to \AgdaBound{y}.

\section{Computational Functions}

\subsection{The Single-Step Evaluation Function}
If such a step is possible, then the single-step evaluation function, which is represented in \AgdaDatatype{CAS} records as some \AgdaField{exceptionallyEvaluate} field, performs a single evaluation step on the input.  If no such step is possible, but the input is not bogus, then the output just contains the input.  If the input is bogus, then the output contains a description of the bogusness.

For the purposes of this document, an ``evaluation step'' is the application of a basic operation, e.g., addition or commuting the arguments of a function, although this notion may not accurately describe some computer algebra systems, e.g., a computer algebra system which \emph{immediately} simplifies some expressions without explicitly using evaluation steps.\footnote{However, identifying and solving problems in such a computer algebra system \emph{could} be relatively difficult\ldots{}}  More formally, one can say that an evaluation step is the application of an operation which, with regard to the representation system which is used by the computer algebra system in question, cannot be further simplified or decomposed into simpler operations.

The author acknowledges that the ``more formal'' definition is pretty vague; in fact, this vagueness is intentional!  To justify the vagueness, the author has bestowed upon the reader\footnote{Is anyone actually reading this paper?} the following hypothetical: Computer algebra systems \(a\) and \(b\) can have methods of representing values which differ sufficiently wildly to enable the following conditions:

\begin{enumerate}
  \item \(a\) cannot directly compute natural number sums; rather, natural number sums must be represented as repeated applications of the successor function.  Different and more simplified results are achieved by repeatedly applying the single-step evaluation function.
  \item \(b\) immediately computes simple integrals, e.g., \(\int_{x} \sin x\).  The result is represented directly as a floating-point number, integer, or whatever type happens to be the best fit.  In any case, the immediate result \emph{cannot be further simplified}.
\end{enumerate}

\subsection{The Variable Substitution Function}
\AgdaField{CAS.substituteVariables} \AgdaBound{c} is the variable substitution function for the \AgdaBound{c} CAS.\footnote{You don't say.}
In short, \AgdaField{CAS.substituteVariables} \AgdaBound{c} \AgdaBound{list} \AgdaBound{e} is a version of \AgdaBound{e} such that for all \AgdaSymbol(\AgdaBound{variableName} \AgdaOperator{\AgdaInductiveConstructor{,}} \AgdaBound{replacement}\AgdaSymbol) in \AgdaBound{list}, all of \AgdaBound{e}'s free instances of \AgdaField{CAS.variableNamed} \AgdaBound{variableName} have been replaced by \AgdaBound{replacement}.  \AgdaField{CAS.substituteVariables} \AgdaBound{c} \AgdaBound{list} \AgdaBound{e} is otherwise equivalent to \AgdaBound{e}, though.

\subsection{The Non-Tracing Maximum Evaluation Function}
A compliant CAS also has a function which performs the specified number of non-repeating simplification steps on the input but just returns the resulting exception or expression.  In \AgdaDatatype{CAS} records, this function is represented through \AgdaField{rEvaluate}.

\subsection{The Tracing Recursive Evaluation Function}
A compliant CAS also has a function which performs the specified number of non-repeating simplification steps on the input, returning a list all steps which were taken to get the output, regardless of whether or not the output is an exception.  In \AgdaDatatype{CAS} records, this function is represented through \AgdaField{traceEvaluate}.

\subsection{The Bounded Bogosity Check Function}
\AgdaField{CAS.bogusBeforeIteration?} \AgdaBound{c} \AgdaBound{n} \AgdaBound{e} contains an appropriate value if and only if such a value exists.\footnote{In other words, the author so kindly suggests reading type definitions instead of expecting spoonfeeding.}  \emph{Gee}, \emph{that} explanation is the bee's knees!

\section{Representational Functions}

\subsection{The Natural-to-Expression Function}
The author thinks that any computer algebra system which is worthy of being given the time of day can represent natural numbers --- after all, the time of day can be represented \emph{as} a natural number!  Anyway, \AgdaField{fromℕ} indicates that a mapping from the natural numbers to the expression type of the given computer algebra system exists.

\subsection{The Integer-to-Expression Function}
Similarly, the author believes that any good computer algebra system can represent any given integer.  In fact, when using \AgdaRecord{CAS} records, this value can be derived automatically!  \AgdaField{CAS.fromℤ} \AgdaBound{c} \AgdaBound{x} is the \AgdaBound{c} CAS's representation of \AgdaBound{x}.

\subsection{The Variable Function}
Does a computer algebra system which lacks support for variables even qualify as being a computer algebra system?  The author is doubtful.  Anyway, \AgdaField{CAS.variableNamed} \AgdaBound{c} \AgdaBound{name} is \AgdaBound{c}'s representation of the variable whose name is \AgdaBound{name}.

\subsection{The Sum Function}
Any half-decent CAS is capable of representing the sum of two expressions.  Accordingly, \AgdaField{\AgdaUnderscore{}+\AgdaUnderscore{}} values are sums.  More formally, \AgdaField{CAS.\AgdaUnderscore{}+\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the sum of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Difference Function}
Any half-decent CAS can represent the difference of two given expressions, too.  Accordingly, \AgdaField{\AgdaUnderscore{}-\AgdaUnderscore{}} values are differences.  More formally, \AgdaField{CAS.\AgdaUnderscore{}-\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the difference of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Product Function}
A decent CAS can represent the product of two expressions.  Accordingly, \AgdaField{\AgdaUnderscore{}*\AgdaUnderscore{}} values represent products.  More formally, one can say that \AgdaField{CAS.\AgdaUnderscore{}*\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the product of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Quotient Function}
Any \emph{good} CAS can \emph{also} represent the quotient of two expressions.  Accordingly, \AgdaField{\AgdaUnderscore{}/\AgdaUnderscore{}} values are quotient functions.  More formally, \AgdaField{CAS.\AgdaUnderscore{}/\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of the quotient of \AgdaBound{x} and \AgdaBound{y}.

\subsection{The Exponent Function}
The author is tired of the boilerplate nonsense.  \AgdaField{CAS.\AgdaUnderscore{}\textasciicircum\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y} is \AgdaBound{c}'s representation of \AgdaBound{x} to the power of \AgdaBound{y}.

\subsection{The Trigonometric Functions}
As previously indicated, a CAS also supports certain trigonometric functions.  To prevent using too terribly many \texttt{subsection} declarations, the author uses an \texttt{itemize} environment to describe the relevant functions as follows:

\newcommand\boilerplateTrigDef[2]{\AgdaField{CAS.#1} \AgdaBound{c} \AgdaBound{x} is the \AgdaBound{c} CAS's representation of the application of the #2 function to \AgdaBound{x}.}

\begin{itemize}
  \item \boilerplateTrigDef{sin}{sine}
  \item \boilerplateTrigDef{cos}{cosine}
  \item \boilerplateTrigDef{tan}{tangent}
  \item \boilerplateTrigDef{csc}{cosecant}
  \item \boilerplateTrigDef{sec}{secant}
  \item \boilerplateTrigDef{cot}{cotangent}
\end{itemize}

\subsection{The Derivative Function}
\AgdaField{CAS.derivative} \AgdaBound{c} \AgdaBound{name} \AgdaBound{e} represents the derivative of \AgdaBound{e} with respect to the variable whose name is \AgdaBound{name}.

\subsection{The Antiderivative Function}
\AgdaField{CAS.antiderivative} \AgdaBound{c} \AgdaBound{name} \AgdaBound{e} represents the antiderivative of \AgdaBound{e} with regard to the variable whose name is \AgdaBound{name}.

\subsection{The Additive Inverse Function}
\AgdaField{CAS.negation} \AgdaBound{c} \AgdaBound{x} is the additive inverse of \AgdaBound{x}.

\subsection{The Simple Limit Function}
\AgdaField{CAS.limit} \AgdaBound{v} \AgdaBound{x} \AgdaBound{c} \AgdaBound{e} is \AgdaBound{v}'s representation of \(\lim_{\AgdaBound{x} \rightarrow \AgdaBound{c}} \mathrm{E}\), where ``\(\mathrm{E}\)'' denotes the expanded version of the \AgdaBound{e} expression.

\subsection{The Bounded Integral Function}
\AgdaField{CAS.boundedIntegral} \AgdaBound{c} \AgdaBound{name} \AgdaBound{b1} \AgdaBound{b2} \AgdaBound{e} is \AgdaBound{c}'s representation of \(\int_{\AgdaBound{name}=\AgdaBound{b1}}^{\AgdaBound{b2}} \mathrm{E}\), where ``\(\mathrm{E}\)'' denotes the expansion of \AgdaBound{e}.

\subsection{The Lambda Expression Function}
\AgdaField{CAS.lambda} \AgdaBound{c} \AgdaBound{name} \AgdaBound{expression} \AgdaBound{value} represents the application to \AgdaBound{value} of the lambda expression whose bound variable's name is \AgdaBound{name} and whose expression is \AgdaBound{expression}.  Equivalently, one can say that \AgdaField{CAS.lambda} \AgdaBound{c} \AgdaBound{name} \AgdaBound{M} \AgdaBound{value} is equivalent to \(\left(\lambda\ \AgdaBound{name} \rightarrow \AgdaBound{M}\right)\ \AgdaBound{value}\).

\section{Semi-Decidable Functions}

\subsection{The Semi-Decidable Algebraic Equality Function}
Assuming that the function is defined such that iteration counts \emph{are actually meaningful}, \AgdaField{CAS.definitelyEquals} \AgdaBound{c} \AgdaBound{i} \AgdaBound{x} \AgdaBound{y} is some value \AgdaInductiveConstructor{inj₂} \AgdaSymbol(\AgdaInductiveConstructor{just} \AgdaBound{equality}\AgdaSymbol) if and only if the \AgdaField{CAS.definitelyEquals} function finds an appropriate value within \AgdaBound{i} iterations.  The \AgdaField{CAS.definitelyEquals} value is \AgdaInductiveConstructor{inj₂} \AgdaInductiveConstructor{nothing} if and only if the function cannot discover an appropriate proof of equality.  The function encounters an exceptional situation if and only if the \AgdaField{CAS.definitelyEquals} value is \AgdaInductiveConstructor{inj₁} \AgdaBound{e}, where \AgdaBound{e} is a description of the exception.

\subsection{The Semi-Decidable Less-Than Function}
Assuming that the relevant function actually \emph{considers} iteration counts, \AgdaField{CAS.definitelyEquals} \AgdaBound{c} \AgdaBound{i} \AgdaBound{x} \AgdaBound{y} is some value \AgdaInductiveConstructor{inj₂} \AgdaSymbol(\AgdaInductiveConstructor{just} \AgdaBound{lessThan}\AgdaSymbol) if and only if the \AgdaField{CAS.isDefinitelyLessThan} function finds an appropriate value.  The \AgdaField{CAS.isDefinitelyLessThan} value is \AgdaInductiveConstructor{inj₂} \AgdaInductiveConstructor{nothing} if and only if the function cannot discover an appropriate inequality proof.  The function encounters an exceptional situation if and only if the \AgdaField{CAS.isDefinitelyLessThan} is \AgdaInductiveConstructor{inj₁} \AgdaBound{e}, where \AgdaBound{e} is a description of the exception.

\section{Types for Describing Single Expressions}

\subsection{The Variable Containment Type}
The variable whose name is \AgdaBound{name} is free in \AgdaBound{e} with regard to \AgdaBound{c} if and only if a value of type \AgdaFunction{CAS.IsNameOfVariableIn} \AgdaBound{c} \AgdaBound{name} \AgdaBound{e}.

\subsection{The Realness Type}
\AgdaBound{e} represents a real number with regard to \AgdaBound{c} if and only if there exists a value of type \AgdaField{CAS.IsReal} \AgdaBound{c} \AgdaBound{e}.

\subsection{The Complexity Type}
\AgdaBound{e} represents an imaginary number with regard to \AgdaBound{c} if and only if there exists a value of type \AgdaField{CAS.IsImaginary} \AgdaBound{c} \AgdaBound{e}.

\subsection{The Constant Type}
\AgdaBound{e} represents a constant with regard to \AgdaBound{c} if and only if there exists a value of type \AgdaField{CAS.IsConstant} \AgdaBound{c} \AgdaBound{e}.

\subsection{The Infinite Type}
\AgdaBound{e} represents an infinite thing with regard to \AgdaBound{c} if and only if there exists a value of type \AgdaField{CAS.IsInfinite} \AgdaBound{c} \AgdaBound{e}.

\subsection{The Non-Bogus Type}
This type, in addition to not being bogus, is used to indicate that the relevant expression is not bogus.  More formally, a value of type \AgdaField{CAS.IsNotBogus} \AgdaBound{c} \AgdaBound{e} exists if and only if \AgdaBound{e} is bogus with regard to \AgdaField{CAS.rEvaluate} \AgdaBound{c} at no iteration, i.e., \AgdaField{CAS.rEvaluate} \AgdaBound{c} \AgdaBound{n} \AgdaBound{e} is non-bogus for all \AgdaBound{n}.

\subsection{The Bogus Type}
This type is not bogus but \emph{is} used to indicate that a given expression is bogus.  More formally, one can say that a value of type \AgdaField{CAS.IsBogus} \AgdaBound{c} \AgdaBound{e} exists if and only if \AgdaBound{e} is bogus with regard to \AgdaField{CAS.rEvaluate} \AgdaBound{c} at some iteration.

\subsection{The Iteration Equality Function}
A value of type \AgdaField{CAS.equal-at-iteration} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e1} \AgdaBound{e2} exists if and only if \AgdaField{CAS.definitelyEquals} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e1} \AgdaBound{e2} indicates that \AgdaBound{e1} is algebraically equal to \AgdaBound{e2}.  This function mostly exists to eliminate repetition.

\subsection{The Iteration Bogosity Function}
A value of type \AgdaField{CAS.bogus-at-iteration} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e} exists if and only if \AgdaField{CAS.rEvaluate} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e} is an \AgdaInductiveConstructor{inj₁} value.

\subsection{The Generic Iteration Equality Function}
A value of type \AgdaField{CAS.equal-at-some-iteration} \AgdaBound{c} \AgdaBound{e1} \AgdaBound{e2} exists if and only if \AgdaField{CAS.definitelyEquals} \AgdaBound{c} can determine that \AgdaBound{e1} is algebraically equal to \AgdaBound{e2} at some iteration.  Again, this function is really just good for reducing nasty redundancy.

\subsection{The Generic Iteration Bogosity Function}
A value of type \AgdaField{CAS.bogus-at-some-iteration} \AgdaBound{c} \AgdaBound{e} exists if and only if \AgdaField{CAS.rEvaluate} \AgdaBound{c} \AgdaBound{iterations} \AgdaBound{e} is an \AgdaInductiveConstructor{inj₂} value for some \AgdaBound{iterations}.

\section{Specific Values}

\subsection{The \(\tau\) Value}
\AgdaField{CAS.τ} \AgdaBound{c} is the \AgdaBound{c} CAS's representation of \(\tau\), i.e., the angular measure of a circle.

\section{Some Assorted Proofs}

\subsection{The Proof of Structural Equality}
This one, which is represented via the \AgdaField{structuralEquality} field, should be simple enough for anyone who is familiar with \AgdaFunction{DecidableEquality}.

\subsection{The Natural Number Proofs}
In addition to the basic mapping, proofs of the following attributes should exist:

\begin{itemize}
  \item Any two natural numbers differ only if the CAS's representations of the numbers differ.
\end{itemize}

\subsection{The Proof which Indicates that Variables of Different Names are Decidedly Not Equivalent}
Operations on variables are only sensible if confusing variables is forbidden, i.e., variables of different names are represented differently.  Accordingly, \AgdaField{CAS.differently-named-variables-are-different} \AgdaBound{c} indicates that within \AgdaBound{c}, given any two variables \(x\) and \(y\), if the name of \(x\) differs from the name of \(y\), then \AgdaBound{c}'s representations of \(x\) and \(y\) differ.

\subsection{The Equality Step Function}
\AgdaField{CAS.equality-at-n-implies-equality-at-n+1} proves that two expressions are definitely equal at a given iteration only if these same expressions are also definitely equal at the following iteration.

\subsection{The Bogosity Step Function}
\AgdaField{CAS.bogosity-at-n-implies-bogosity-at-n+1} proves that a given expression is bogus at some iteration only if the same expression is bogus at the following iteration.

\section{The Definition Proper}

\begin{code}
record CAS {a : Level} (ε : Set a) : Set (Level.suc a) where
  field
    _≈_ : ε → ε → Set a
    _<_ : ε → ε → Set a
    definitelyEquals : (iterations : ℕ) →
                       (x y : ε) →
                       Exceptional (Maybe (x ≈ y))
    isDefinitelyLessThan : (iterations : ℕ) →
                           (x y : ε) →
                           Exceptional (Maybe (x < y))
    exceptionallyEvaluate : ε → Exceptional ε
    structuralEquality : DecidableEquality ε
    fromℕ : ℕ → ε
    variableNamed : String → ε
    _+_
     _-_
     _*_
     _/_
     _^_ : ε → ε → ε
    negation : ε → ε
    sin
     cos
     tan
     csc
     sec
     cot : ε → ε
    derivative
     antiderivative : String → ε → ε
    limit : String → ε → ε → ε
    boundedIntegral : String → ε → ε → ε → ε
    substituteVariables : List.List (String × ε) → ε → ε
    IsNameOfVariableIn : String → ε → Set
    IsReal : ε → Set
    IsInfinite : ε → Set a
    lambda : String → ε → ε → ε
    τ : ε
    different-if-nats-are-different :
      {n1 n2 : ℕ} → n1 ≢ n2 → fromℕ n1 ≢ fromℕ n2
    differently-named-variables-are-different :
      (name1 name2 : String) →
      name1 ≢ name2 →
      variableNamed name1 ≢ variableNamed name2

  IsConstant : ε → Set
  IsConstant e = (name : String) → ¬ IsNameOfVariableIn name e

  rEvaluate : ℕ → ε → Exceptional ε
  rEvaluate 0 e = inj₂ e
  rEvaluate (ℕ.suc n) e = [_,_] inj₁ exceptionallyEvaluate (rEvaluate n e)

  traceEvaluate : ℕ → ε → List.List (Exceptional ε)
  traceEvaluate n e =
    nonRepeatingPortion decFun (List.map (flip rEvaluate e) (List.upTo (ℕ.suc n)))
      where decFun = Data.Sum.Properties.≡-dec Data.String._≟_ structuralEquality

  module EqualityVerificationParts where
    inj2s : List.List (Exceptional ε) → List.List ε
    inj2s (inj₂ e List.∷ es) = e List.∷ inj2s es
    inj2s (inj₁ e List.∷ es) = inj2s es
    inj2s List.[] = List.[]

    evaluationPairs : ℕ → ε → ε → List.List (ε × ε)
    evaluationPairs i = List.cartesianProduct on inj2s ∘ traceEvaluate i

    module ProofsOfCorrectness
      (i : ℕ)
      (e1 e2 : ε) where

      evp = evaluationPairs i e1 e2

      length-of-pairlist-is-suc : Σ ℕ (λ n → ℕ.suc n ≡ List.length evp)
      length-of-pairlist-is-suc = {!!}

      first-pair-index = Data.Fin.cast (proj₂ length-of-pairlist-is-suc) Fin.zero

      inputs-are-first-evaluation-pair :
        (e1 , e2) ≡ List.lookup evp first-pair-index
      inputs-are-first-evaluation-pair = {!!}

  open EqualityVerificationParts

  module InternalEqualityFunctions where
    _≡₂_ : Exceptional ε → Exceptional ε → Set a
    (inj₂ x) ≡₂ (inj₂ y) = x ≡ y
    x ≡₂ y = ⊥

    _≟₂_ : (x y : Exceptional ε) → Dec (x ≡₂ y)
    (inj₂ x) ≟₂ (inj₂ y) = structuralEquality x y
    (inj₁ x) ≟₂ (inj₂ y) = no (λ ())
    (inj₁ x) ≟₂ (inj₁ y) = no (λ ())
    (inj₂ x) ≟₂ (inj₁ y) = no (λ ())

  open InternalEqualityFunctions

  _≉_ : ε → ε → Set a
  x ≉ y = (iterations : ℕ) → ¬ x ≈ y

  _≤_ : ε → ε → Set a
  x ≤ y = (x < y) ⊎ (x ≈ y)

  equal-at-iteration : ℕ → (e1 e2 : ε) → Set a
  equal-at-iteration iterations e1 e2 =
    Σ (e1 ≈ e2)
      (λ i → inj₂ (just i) ≡ definitelyEquals iterations e1 e2)

  equal-at-some-iteration : (e1 e2 : ε) → Set a
  equal-at-some-iteration e1 e2 = Σ ℕ (λ n → equal-at-iteration n e1 e2)

  equality-at-n-implies-equality-at-n+1 :
    (iterations : ℕ) →
    (e1 e2 : ε) →
    equal-at-iteration iterations e1 e2 →
    equal-at-iteration (ℕ.suc iterations) e1 e2
  equality-at-n-implies-equality-at-n+1 = {!!}

  bogus-at-iteration : ℕ → ε → Set a
  bogus-at-iteration n e = Σ String (λ ex → inj₁ ex ≡ rEvaluate n e)

  bogus-at-some-iteration : ε → Set a
  bogus-at-some-iteration = Σ ℕ ∘ flip bogus-at-iteration

  bogosity-at-n-implies-bogosity-at-n+1 :
    (iterations : ℕ) →
    (e : ε) →
    bogus-at-iteration iterations e →
    bogus-at-iteration (ℕ.suc iterations) e
  bogosity-at-n-implies-bogosity-at-n+1 iter e (exc , bogosity) =
    exc , trans bogosity (sym eEquality)
    where
    eEquality : rEvaluate (ℕ.suc iter) e ≡ rEvaluate iter e
    eEquality = begin
      rEvaluate (ℕ.suc iter) e
        ≡⟨⟩
      [_,_]′ inj₁ exceptionallyEvaluate (rEvaluate iter e)
        ≡⟨ cong ([_,_] inj₁ exceptionallyEvaluate) (sym bogosity) ⟩
      inj₁ exc
        ≡⟨ bogosity ⟩
      rEvaluate iter e ∎

  IsNotBogus : ε → Set a
  IsNotBogus e = (n : ℕ) → Is-just (isInj₂ (rEvaluate n e))

  IsBogus : ε → Set a
  IsBogus e = Σ ℕ (λ n → Σ String (λ s → rEvaluate n e ≡ inj₁ s))

  IsImaginary : ε → Set a
  IsImaginary e = IsReal e × IsNotBogus e

  fromℤ : Data.Integer.ℤ → ε
  fromℤ (Data.Integer.+ x) = fromℕ x
  fromℤ (Data.Integer.-[1+ x ]) = negation (fromℕ (ℕ.suc x))

  bogusBeforeIteration? :
    (n : ℕ) →
    (e : ε) →
    Maybe ((Σ (Fin n) (λ f → bogus-at-iteration (Fin.toℕ f) e)))
  bogusBeforeIteration? n e =
    List.head (List.catMaybes (List.map check (List.allFin n)))
    where
    isBogus? : (n : ℕ) → (e : ε) → Maybe (bogus-at-iteration n e)
    isBogus? n e with rEvaluate n e
    ... | inj₁ bogus = just (bogus , refl)
    ... | _ = nothing
    check = λ x → Data.Maybe.map (x ,_) (isBogus? (Data.Fin.toℕ x) e)
\end{code}

\chapter{The Type of Verified Computer Algebra Systems}
For the purposes of this document, a verified computer algebra system is the combination of a \AgdaRecord{CAS} computer algebra system \(c\) \emph{and} some guarantees about \(c\).  The non-\AgdaRecord{CAS} parts of the combination are as follows:

\begin{itemize}
 \item a proof which indicates that the algebraic equality relation is an equaivalence relation,
 \item a proof which indicates that two values are structurally equivalent only if these same values are also algebraically equal,
 \item a proof which indicates that variables of different names are not definitely equal,
 \item a proof which indicates that for any two integers \(n_1\) and \(n_2\), the sum of the representations of \(n_1\) and \(n_2\) is the representation of \(n_1 + n_2\),
 \item a proof which indicates that the product of any non-bogus element \(e\) of type \AgdaBound{ε} and one is \(e\),
 \item a proof of commutativity of addition,
 \item a proof of commutativity of multiplication,
 \item a proof of associativity of addition,
 \item a proof of the inverse relationship between multiplication and division,
 \item a proof of the bogosity of \(0^0\),
 \item a proof of the bogosity of \(0^e\), where \(e < 0\),
 \item a proof which indicates that \(\lim_{x \rightarrow n} e\) is algebraically equal to \(n\) if \(x\) is not referenced in \(e\),
 \item a proof of the algebraic equality between \(\left(\lambda\ x \rightarrow x\right)\ e\) and \(e\),
 \item a proof which indicates that \(\left(\lambda\ x \rightarrow y\right)\ e\) is algebraically equal to \(y\) if \(x\) is not referenced in \(y\),
 \item a proof which indicates that if \(n\) does not appear in \(E\), then the \(n\)-derivative of \(E\) is equal to \(E\),
 \item a proof of \(0\)'s equality with \(\tan \left(\tau \cdot n \cdot \frac12\right)\),
 \item a proof of the failure of garbage variable substitution\footnote{See \fref{sec:garbageVariableSubstitutionPseudoFootnote}.},
 \item a proof of the irrelevance of substitution list order,
 \item a proof which indicates that the derivative of a constant is \(0\),
 \item basic trigonometric derivative correctness proofs,
 \item a proof of the algebraic equality between \(\derivative{x} \left(e_1 + e_2\right)\) and \(\derivative{x} e_1 + \derivative{x} e_2\),
 \item a proof of the correct handling of the derivatives of products,
 \item a proof of the equality between \(c\) and \(\lim_{x \rightarrow y} c\), where \(c\) is a constant,
 \item a proof of the equality between \(\lim_{x \rightarrow y} x\) and \(y\),
 \item a proof of the equality between \(\lim_{x \rightarrow y} \left(a + b\right)\) and \(\left(\lim_{x \rightarrow y} a\right) + \lim_{x \rightarrow y} b\),
 \item a proof of the equality between \(\lim_{x \rightarrow y} \left(- x\right)\) and \(- \lim_{x \rightarrow y} x\),
 \item a proof of the equality between \(\lim_{x \rightarrow y} \left(a \cdot b\right)\) and \(\left(\lim_{x \rightarrow y} a\right) \cdot \lim_{x \rightarrow y} b\),
 \item a proof which indicates that \(f x\) is equal to \(\lim_{y \rightarrow x} \left(f y\right)\) if \(f x\) is non-bogus,
 \item a proof of the equality between \(x\) and \(- \left(- x\right)\), and
 \item a proof which indicates that if \AgdaBound{m} is less than \AgdaBound{n}, then \AgdaField{fromℕ} \AgdaBound{m} is less than \AgdaField{fromℕ} \AgdaBound{n}.
\end{itemize}

\section{General Proofs regarding Equality}

\subsection{The Proof of the Equivalence Nature of the Algebraic Equality Relation}
A good CAS represents the complex numbers, whose equality relation is an equivalence relation.  Accordingly, a verified CAS's algebraic equality relation should be an equivalence relation.  \AgdaField{equality-is-equivance} values indicate that the algebraic equality relations actually are equivalence relations.

\subsection{The Structural-Equivalence-to-Algebraic-Equality Function}
Also, in a good CAS, two expressions \(e_1\) and \(e_2\) are represented in the same way only if \(e_1\) is algebraically equal to \(e_2\).  This fact is represented through the use of \AgdaField{structural-equality-implies-definite-equality}.

\section{Variable Correctness Proofs}

\subsection{The Proof which Indicates that Values of Different Names are Not ``Definitely Equal''}
Any two given variables are not necessarily equal.  Accordingly, \AgdaField{VCAS.differently-named-variables-are-not-definitely-equal} \AgdaBound{c} indicates that within the \AgdaBound{c} CAS, given any two \AgdaBound{c} variables \(x\) and \(y\), if the name of \(x\) differs from the name of \(y\), then \(x\) is not definitely equal to \(y\).

\section{Addition Correctness Proofs}

\subsection{The Natural Number Sum Field}
Another aspect of a good computer algebra system is the correct calculation of sums of natural numbers.  Intuition dictates that in a good computer algebra system, the sum of two natural numbers should be the sum of the same two natural numbers.  However, as indicated by \AgdaField{CAS.fromℕ}, many computer algebra systems do not just work with natural numbers; accordingly, natural number arithmetic may accidentally be implemented incorrectly.  To prevent such incorrect implementations, correct calculation of natural number sums is ensured through \AgdaField{sum-of-nats-is-nat-sum} values, which are proofs which indicate that the corresponding computer algebra systems' natural number addition functions are defined correctly.

\subsection{The Non-Bogus Sum Field}
\AgdaField{VCAS.sum-is-not-bogus} indicates that for any given non-bogus values \AgdaBound{e1} and \AgdaBound{e2}, the sum of \AgdaBound{e1} and \AgdaBound{e2} is not bogus.

\subsection{The Proof of Commutativity of Addition}
\AgdaField{VCAS.sum-is-commutative} indicates that addition is commutative in the relvant CAS.  More formally, \AgdaField{VCAS.sum-is-commutative} \AgdaBound{c} indicates that for any appropriate expression values \AgdaBound{e1} and \AgdaBound{e2}, some \AgdaBound{n} exists such that there exists a value of type \AgdaBound{CAS.equal-at-iteration} \AgdaBound{c2} \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}+\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e1} \AgdaBound{e2}\AgdaSymbol) \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}+\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e2} \AgdaBound{e1}\AgdaSymbol), where \AgdaBound{c2} is the CAS record which is verified by \AgdaBound{c}.

\subsection{The Proof of Commutativity of Multiplication}
\AgdaField{VCAS.product-is-commutative} indicates that multiplication is commutative in the relvant CAS.  More formally, \AgdaField{VCAS.product-is-commutative} \AgdaBound{c} indicates that for any appropriate expression values \AgdaBound{e1} and \AgdaBound{e2}, some \AgdaBound{n} exists such that a value of type \AgdaBound{CAS.equal-at-iteration} \AgdaBound{c2} \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}*\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e1} \AgdaBound{e2}\AgdaSymbol) \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}*\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e2} \AgdaBound{e1}\AgdaSymbol), where \AgdaBound{c2} is the CAS record which is verified by \AgdaBound{c}.

\subsection{The Proof of Associativity of Addition}
\AgdaField{VCAS.sum-is-commutative} indicates that addition is commutative in the relvant CAS.  More formally, \AgdaField{VCAS.sum-is-commutative} \AgdaBound{c} indicates that for any appropriate expression values \AgdaBound{e1} and \AgdaBound{e2}, some \AgdaBound{n} exists such that there exists a value of type \AgdaBound{CAS.equal-at-iteration} \AgdaBound{c2} \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}+\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e1} \AgdaBound{e2}\AgdaSymbol) \AgdaSymbol(\AgdaField{CAS.\AgdaUnderscore{}+\AgdaUnderscore{}} \AgdaBound{c2} \AgdaBound{e2} \AgdaBound{e1}\AgdaSymbol), where \AgdaBound{c2} is the CAS record which is verified by \AgdaBound{c}.

\section{Multiplication Correctness Proofs}

\subsection{The 1-Product Field}
\AgdaField{VCAS.product-of-e-and-1-is-e} \AgdaBound{c} indicates that for any non-bogus value \(e\) of the expression type for \AgdaBound{c}, the product of \(e\) and one is equal to \(e\).

\section{Division Correctness Proofs}

\subsection{The Bogus Division Field}
That the quotient of any given number and zero is bogus, i.e., undefined, is well-known.  This fact --- the bogusness, not being well-known --- is represented through \AgdaField{VCAS.division-by-zero-is-bogus}.

\section{The Proof of the Inverse Relationship between Multiplication and Division}
\AgdaField{VCAS.product-of-quotient-is-same} indicates that for the appropriate CAS, multiplication is the inverse of division.  More formally, \AgdaField{product-of-quotient-is-same} \AgdaBound{c} indicates that for all appropriate expression values \AgdaBound{e1} and \AgdaBound{e2}, \AgdaBound{e2} is equal to the \AgdaBound{c} CAS product of \AgdaBound{e1} and the \AgdaBound{c} CAS quotient of \AgdaBound{e2} and \AgdaBound{e1}.

\section{Exponentiation Correctness Proofs}

\subsection{The Proof of the Bogosity of \(0^0\)}
\AgdaField{VCAS.0\textasciicircum{}0-is-bogus} \AgdaBound{c} indicates that in the \AgdaBound{c} CAS, \(0^0\) is bogus at some iteration count.

\subsection{The Proof of the Bogosity of \(0^e\), where \(e < 0\)}
\AgdaField{VCAS.0\textasciicircum{}-n-is-bogus} \AgdaBound{v} indicates that for all relevant expressions \(e\), if \(e < 0\), then the CAS will eventually determine that \(0^e\) is bogus.

\section{Limit Correctness Proofs}

\subsection{The Constant Limit Field}
\AgdaField{VCAS.limit-of-constant-is-constant} \AgdaBound{v} proves that for all constants \(e\), \(e\) is \AgdaBound{c}-\gls{algEq} to \(\lim_{x \rightarrow y} e\), where \AgdaBound{v} is a value of type \AgdaRecord{VCAS} \AgdaBound{c}.

\subsection{The Proof of the Futility of Taking the Limit of an Expression which does Not Use the Named Variable}
\AgdaField{limit-of-unrelated-value-is-unrelated-value} \AgdaBound{v} indicates that in the \AgdaBound{v} CAS, if \(x\) is not used in \(e\), then \(\lim_{x \rightarrow b} e\) is equivalent to \(e\) for all \(b\), \(e\), and \(x\).

\subsection{The Same Variable Limit Field}
\AgdaField{VCAS.limit-of-same-variable-is-value} \AgdaBound{v} proves that the \AgdaBound{v} CAS can correctly determine that \(\lim_{x \rightarrow y} x\) is algebraically equivalent to \(y\).

\subsection{The Sum Limit Field}
\AgdaField{VCAS.limit-of-sums-is-sum} \AgdaBound{v} proves that the \AgdaBound{v} CAS can correctly determine that \(\lim_{x \rightarrow y} \left(v + w\right)\) is algebraically equivalent to \(\left(\lim_{x \rightarrow y} v\right) + \lim_{x \rightarrow y} w\).

\subsubsection{The Negation Limit Field}
\AgdaField{VCAS.limit-negation} \AgdaBound{v} proves that the \AgdaBound{v} CAS can correctly determine that \(\lim_{x \rightarrow y} \left(- w\right)\), i.e., \(\lim_{x \rightarrow y} \left(0 - w\right)\), i.e., \(0 - \lim_{x \rightarrow y} w\), is algebraically equivalent to \(- \lim_{x \rightarrow y} w\).

\subsection{The Product Limit Field}
\AgdaField{VCAS.limit-of-products-is-product} \AgdaBound{v} proves that the \AgdaBound{v} CAS can correctly determine that \(\lim_{x \rightarrow y} \left(v \cdot w\right)\) is algebraically equivalent to \(\left(\lim_{x \rightarrow y} v\right) \cdot \lim_{x \rightarrow y} w\).

\subsection{The Non-Bogus Limit Field}
\AgdaField{VCAS.limit-of-non-bogus-expression} \AgdaBound{v} proves that if \(f y\) is not \gls{bogusWrt} \AgdaBound{c}, then \(\lim_{x \rightarrow y} \left(f x\right)\) is \AgdaBound{c}-\gls{algEq} \(f y\).

\section{Lambda Correctness Proofs}

\subsection{The Proof which Indicates that Simple Lambda Substitution Works}
\AgdaField{VCAS.simple-lambda-substitution-works} \AgdaBound{v} indicates that, at some iteration, the \AgdaBound{v} CAS can determine that the \AgdaBound{v} CAS's representation of \(\left(\lambda\ v \rightarrow v\right) e\) is algebrically equal to the \AgdaBound{v} CAS's representation of \(e\).

\subsection{The Proof of the Futility of Applying a Lambda Expression whose Bound Variable is Unused}
For all relevant \(v\), \(M\), and \(e\), if \(v\) is not referenced in \(M\), then \(\left(\lambda\ v \rightarrow M\right)\ e = M\).  The preceding fact is encoded through \AgdaField{VCAS.unapplicable-lambda-returns-lambda-body}.

\section{Variable Substitution Correctness Proofs}

\subsection{The Proof of the Failure of Garbage Variable Substitution}
\AgdaField{VCAS.garbage-variable-substitution-fails} \AgdaBound{v} proves that the \AgdaBound{v} CAS's variable substitution effectively returns the input expression if no variables of the substitution list are free in the input expression.

\subsubsection{On the Name of this Subsection}\label{sec:garbageVariableSubstitutionPseudoFootnote} % Using this jank instead of a footnote ensures that no footnote-related errors occur.
In the title of this subsection, ``Garbage'' affects ``Variable Substitution'', although ``garbage variable'' \emph{could} \emph{also} apply\ldots

\subsection{The Proof of the Irrelevance of the Order of Substitution Lists}
\AgdaField{VCAS.substitution-order-is-irrelevant} \AgdaBound{v} proves that for the \AgdaBound{v} CAS, if some substitution list \(l_1\) is a permutation of some substitution list \(l_2\) and contains no repeated variable names, then the application of \(l_1\) to some expression \(e\) is algebraically equal to the application of \(l_2\) to \(e\).

\section{Derivative Correctness Proofs}

\subsection{The Unrelated Derivative Proof}
\AgdaField{VCAS.unrelated-derivative} \AgdaBound{v} indicates that for all appropriate \AgdaBound{v} CAS expressions \(E\) and all appropriate \(n\), if the variable whose name is \(n\) does not appear in \(E\), then the \AgdaBound{v} CAS can determine that \(E\) is algebraically equal to the derivative of \AgdaBound{E} with respect to the variable whose name is \(n\).

\subsection{The Constant Derivative Proof}
\AgdaField{VCAS.derivative-of-constant} \AgdaBound{v} proves that the \AgdaBound{v} CAS can correctly determine that the derivative of any constant with regard to any variable is \(0\).

\subsection{Basic Trigonometric Derivative Correctness Proofs}
We ain't done yet, folks!  Additional fields include the basic trigonometric derivative correctness proof fields, which are fields for proofs of the correctness of the evaluation of derivatives of basic trigonometric functions.

\subsubsection{The Sine Derivative Proof}
\AgdaField{VCAS.derivative-of-sine} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\sin x\) with respect to \(x\) is \(\cos x\).

\subsubsection{The Cosine Derivative Proof}
\AgdaField{VCAS.derivative-of-cosine} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\cos x\) with respect to \(x\) is \(- \sin x\).

\subsubsection{The Tangent Derivative Proof}
\AgdaField{VCAS.derivative-of-tangent} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\tan x\) with respect to \(x\) is \(\left(\sec x\right)^2\).

\subsubsection{The Cosecant Derivative Proof}
\AgdaField{VCAS.derivative-of-cosecant} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\csc x\) with respect to \(x\) is \(- \cot x \cdot \csc x\).

\subsubsection{The Secant Derivative Proof}
\AgdaField{VCAS.derivative-of-secant} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\sec x\) with respect to \(x\) is \(\sec x \cdot \tan x\).

\subsubsection{The Cotangent Derivative Proof}
\AgdaField{VCAS.derivative-of-cotangent} \AgdaBound{v} proves that the \AgdaBound{v} CAS correctly determines that for all variables \(x\), the derivative of \(\cot x\) with respect to \(x\) is \(- \left(\csc x\right)^2\).

\subsubsection{The Derivative Sum Proof}
\AgdaField{VCAS.derivative-of-sum-is-sum-of-derivatives} \AgdaBound{v} proves that the \AgdaBound{v} CAS can correctly determine that for all relevant \(x\), \(e_1\), and \(e_2\), \(\derivative{x} \left(e_1 + e_2\right)\) is algebraically equal to \(\derivative{x} e_1 + \derivative{x} e_2\).

\subsubsection{The Product Derivative Proof}
\AgdaField{VCAS.derivative-of-product} \AgdaBound{v} proves that the \AgdaBound{v} CAS can correctly determine that \(\derivative{n} \left(x \cdot y\right)\) is algebraically equal to \(\left(\derivative{n} x\right) \cdot y + \left(\derivative{n} y\right) \cdot x\).

\section{Trigonometric Function Correctness Proofs}
\subsection{The Proof of the Equality of \(\operatorname{sin} \left(\tau \cdot n \cdot \frac12\right)\), where \(n\) is a Natural Number}
\AgdaField{VCAS.sin-n*pi-is-zero} \AgdaBound{v} proves that the \AgdaBound{v} CAS can determine that for all natural numbers \(n\), the sine of \(\tau \cdot n \cdot \frac12\), i.e., \(\pi \cdot n\), is algebraically equal to \(0\).

\subsection{The Tangent Bogosity Proof}
\AgdaField{VCAS.tangent-is-bogus-at-quarter-tau} \AgdaBound{v} proves that the \AgdaBound{v} CAS can correctly determine that \(\sin \left(\tau \cdot \left(n + \frac{1}{4}\right)\right)\) is totally bogus for all integers \(n\).

\section{General Proofs}

\subsection{The Repeated Negation Proof}
\AgdaField{VCAS.repeated-negation-cancelation} \AgdaBound{v} proves that the \AgdaBound{v} CAS recognizes that for all expressions \(x\), \(- \left(- x\right) = x\).


\section{The Natural Number Less-Than Proof}
\AgdaField{VCAS.natural-number-less-than} \AgdaBound{v} proves that for any two natural numbers \(m\) and \(n\), if \(m < n\), then the \AgdaBound{v} CAS can determine that the \AgdaBound{v} CAS's representation of \(m\) is less than the \AgdaBound{v} CAS's representation of \(n\).

\section{The Definition Proper}

\begin{code}
record VCAS {a : Level} {ε : Set a} (Cas : CAS ε) : Set a where
  open CAS Cas
  field
    equality-is-equivalence : IsEquivalence _≈_
    structural-equality-implies-definite-equality :
      (e1 e2 : ε) →
      e1 ≡ e2 →
      (iterations : ℕ) →
      equal-at-iteration iterations e1 e2
    differently-named-variables-are-not-definitely-equal :
      (name1 name2 : String) →
      name1 ≢ name2 →
      (iterations : ℕ) →
      _≡_ (inj₂ nothing)
          (definitelyEquals iterations
                            (variableNamed name1)
                            (variableNamed name2))
    sum-of-nats-is-nat-sum :
      (n1 n2 : ℕ) →
      equal-at-some-iteration (fromℕ n1 + fromℕ n2) (fromℕ (n1 Data.Nat.+ n2))
    sum-is-not-bogus :
      (e1 e2 : ε) →
      IsNotBogus e1 →
      IsNotBogus e2 →
      IsNotBogus (e1 + e2)
    product-of-e-and-1-is-e :
      (e : ε) →
      IsNotBogus e →
      equal-at-some-iteration (e * fromℕ 1) e
    difference-is-negated-sum :
      (e1 e2 : ε) →
      equal-at-some-iteration (e1 - e2)
                              (e1 + negation e2)
    inverse-of-inverse-is-original :
      (e : ε) →
      equal-at-some-iteration e (negation (negation e))
    division-by-zero-is-bogus :
      (e1 e2 : ε) →
      (equal-at-some-iteration (fromℕ 0) e2) →
      bogus-at-some-iteration (e1 / e2)
    sum-is-commutative :
      (e1 e2 : ε) →
      IsNotBogus e1 →
      IsNotBogus e2 →
      equal-at-some-iteration (e1 + e2) (e2 + e1)
    product-is-commutative :
      (e1 e2 : ε) →
      IsNotBogus e1 →
      IsNotBogus e2 →
      equal-at-some-iteration (e1 * e2) (e2 * e1)
    sum-is-associative :
      (a b c : ε) →
      IsNotBogus a →
      IsNotBogus b →
      IsNotBogus c →
      equal-at-some-iteration (a + (b + c)) ((a + b) + c)
    product-of-quotient-is-same :
      (e1 e2 : ε) →
      IsNotBogus (e2 / e1) →
      equal-at-some-iteration e2 (e1 * (e2 / e1))
    0^0-is-bogus : IsBogus (fromℕ 0 ^ fromℕ 0)
    0^-n-is-bogus : (e : ε) → e < fromℕ 0 → IsBogus (fromℕ 0 ^ e)
    repeated-negation-cancelation :
      (e : ε) → equal-at-some-iteration e (negation (negation e))
    simple-lambda-substitution-works :
      (name : String) →
      (e : ε) →
      equal-at-some-iteration e (lambda name (variableNamed name) e)
    nonapplicable-lambda-returns-lambda-body :
      (name : String) →
      (e1 e2 : ε) →
      ¬ IsNameOfVariableIn name e2 →
      equal-at-some-iteration e2 (lambda name e2 e1)
    unrelated-derivative :
      (name : String) →
      (e : ε) →
      equal-at-some-iteration e (derivative name e)
    sin-n*pi-is-zero :
      (n : ℕ) →
      equal-at-some-iteration (fromℕ 0)
                              (sin (τ * (fromℕ n * (fromℕ 1 / fromℕ 2))))
    garbage-variable-substitution-fails :
      (e : ε)
      (list : List.List (String × ε)) →
      AllList.All (λ (var , rep) → ¬ IsNameOfVariableIn var e)
                  list →
      equal-at-some-iteration e (substituteVariables list e)
    substitution-order-is-irrelevant :
      (e : ε) →
      (list1 list2 : List.List (String × ε)) →
      list1 ↭ list2 →
      UniqueList list1 →
      equal-at-some-iteration (substituteVariables list1 e)
                              (substituteVariables list2 e)
    derivative-of-constant :
      (e : ε) →
      IsConstant e →
      (name : String) →
      equal-at-some-iteration (derivative "name" e) (fromℕ 0)
    derivative-of-sine :
      (name : String) →
      equal-at-some-iteration (derivative name (sin (variableNamed name)))
                              (cos (variableNamed name))
    derivative-of-cosine :
      (name : String) →
      equal-at-some-iteration (derivative name (cos (variableNamed name)))
                              (negation (sin (variableNamed name)))
    derivative-of-tangent :
      (name : String) →
      equal-at-some-iteration (derivative name (tan (variableNamed name)))
                              (sec (variableNamed name) ^ fromℕ 2)
    derivative-of-cosecant :
      (name : String) →
      equal-at-some-iteration (derivative name (csc (variableNamed name)))
                              (_*_ (negation (cot (variableNamed name)))
                                   (csc (variableNamed name)))
    derivative-of-secant :
      (name : String) →
      equal-at-some-iteration (derivative name (sec (variableNamed name)))
                              (_*_ (sec (variableNamed name))
                                   (tan (variableNamed name)))
    derivative-of-cotangent :
      (name : String) →
      equal-at-some-iteration (derivative name (tan (variableNamed name)))
                              (_^_ (negation (csc (variableNamed name)))
                                   (fromℕ 2))
    derivative-of-sum-is-sum-of-derivatives :
      (name : String) →
      (e1 e2 : ε) →
      equal-at-some-iteration (derivative name (e1 + e2))
                              (derivative name e1 + derivative name e2)
    derivative-of-product :
      (name : String) →
      (e1 e2 : ε) →
      IsNotBogus e1 →
      IsNotBogus e2 →
      equal-at-some-iteration (derivative name (e1 * e2))
                              ((derivative name e1 * e2) + (derivative name e2 * e1))
    limit-of-constant-is-constant :
      (name : String) →
      (e bound : ε) →
      IsConstant e →
      equal-at-some-iteration e (limit name bound e)
    limit-of-unrelated-value-is-unrelated-value :
      (name : String) →
      (e bound : ε) →
      ¬ IsNameOfVariableIn name e →
      equal-at-some-iteration e (limit name bound e)
    limit-of-same-variable-is-value :
      (name : String) →
      (bound : ε) →
      equal-at-some-iteration (limit name bound (variableNamed name))
                              bound
    limit-of-sums-is-sum :
      (name : String) →
      (bound e1 e2 : ε) →
      IsNotBogus e1 →
      IsNotBogus e2 →
      equal-at-some-iteration (limit name bound (e1 + e2))
                              (limit name bound e1 + limit name bound e2)
    limit-negation :
      (name : String) →
      (bound e : ε) →
      IsNotBogus e →
      equal-at-some-iteration (limit name bound (negation e))
                              (negation (limit name bound e))
    limit-of-products-is-product :
      (name : String) →
      (bound e1 e2 : ε) →
      IsNotBogus e1 →
      IsNotBogus e2 →
      equal-at-some-iteration (limit name bound (e1 * e2))
                              (limit name bound e1 * limit name bound e2)
    limit-of-non-bogus-expression :
      (name : String) →
      (bound e : ε) →
      IsNotBogus (substituteVariables List.[ name , bound ] e) →
      equal-at-some-iteration (limit name bound e)
                              (substituteVariables List.[ name , bound ] e)

    tangent-is-bogus-at-quarter-tau :
      (n : ℕ) →
      let product = τ * (fromℕ n + (fromℕ 1 / fromℕ 4)) in
      _×_ (bogus-at-some-iteration product)
          (bogus-at-some-iteration (negation product))

    natural-less-than : (m n : ℕ) → m Data.Nat.< n → fromℕ m < fromℕ n
\end{code}

\part{The Core Components of Casanova Fly}\label{sec:casanovaFlyCore}

\begin{code}
module CasanovaFlyCore where
\end{code}

\chapter{The Types of Functions and Expressions}

\section{Type Declarations}

\subsection{\AgdaDatatype{F}'s Type and Summary}
Values of type \AgdaDatatype{F} represent functions.

\begin{code}
  data F : Set
\end{code}

\subsection{The Type and Summary of the Arity Function}
\AgdaFunction{arity} \AgdaBound{f} is the arity of the \AgdaBound{f} function.

\begin{code}
  arity : F → ℕ
\end{code}

\subsection{\AgdaDatatype{ε}'s Type and Summary}
Values of \AgdaDatatype{ε} represent expressions.

\begin{code}
  data ε : Set
\end{code}

\section{The Actual Definitions\ldots and Supporting Functions}

\subsection{Completing \AgdaDatatype{F}'s Definition}
The following statements hold:

\begin{itemize}
  \item \AgdaInductiveConstructor{Abs} represents the absolute value function.
  \item \AgdaInductiveConstructor{Negate} represents the negation function.
  \item \AgdaInductiveConstructor{Sum} represents the sum function.
  \item \AgdaInductiveConstructor{Product} represents the product, i.e., multiplication, function.
  \item \AgdaInductiveConstructor{Exponent} represents the exponentiation function.
  \item \AgdaInductiveConstructor{Limit} represents the limit function, i.e., \AgdaInductiveConstructor{Ap} \AgdaSymbol(\AgdaInductiveConstructor{Limit} \AgdaBound{name}\AgdaSymbol) \AgdaSymbol(\AgdaBound{bound} \AgdaOperator{\AgdaInductiveConstructor{∷}} \AgdaBound{expression} \AgdaOperator{\AgdaInductiveConstructor{∷}} \AgdaInductiveConstructor{List.[]}\AgdaSymbol) represents the limit of \AgdaBound{expression} as \AgdaBound{name} approaches \AgdaBound{bound}.
  \item \AgdaInductiveConstructor{Lambda} represents the lambda function function.\footnote{No typo exists here.}  Alternatively, one can say that \AgdaInductiveConstructor{Lambda} \AgdaBound{names} can be used for representing the lambda function whose bound variables are listed in \AgdaBound{names} and whose body is the first argument of the relevant \AgdaDatatype{Vec} value.  A bit more directly, one can say that \AgdaInductiveConstructor{Ap} \AgdaSymbol(\AgdaField{Lambda} \AgdaBound{names}\AgdaSymbol) \AgdaSymbol(\AgdaBound{M} \AgdaOperator{\AgdaInductiveConstructor{∷}} \AgdaBound{values}\AgdaSymbol) represents \(\left(\lambda\ \AgdaBound{N} \rightarrow \AgdaBound{M'}\right)\ \AgdaBound{V}\), where ``\AgdaBound{N}'', ``\AgdaBound{M'}'', and ``\AgdaBound{V}'' denote the appropriate expansions of \AgdaBound{names}, \AgdaBound{M}, and \AgdaBound{values}, respectively.  Alternatively, if \AgdaBound{names} consists of values \texttt{n1}, \texttt{n2}, \texttt{n3}, and so on, then one could say that \AgdaInductiveConstructor{Lambda} \AgdaBound{names} is \emph{similar} to Agda's \texttt{\textbackslash\ body n1 n2 n3 ... -> body2}, where \texttt{body2} is an expansion of \AgdaBound{body}.  The author suggests that anyone who is \emph{still} uncertain about \AgdaInductiveConstructor{Lambda} inspects \AgdaFunction{varSubstM}, which is defined in \fref{sec:varSubstM-def}.
  {
    \newcommand{\boilerplateBogusTrigCrap}[2]{
      \item \AgdaInductiveConstructor{#1} represents the trigonometric #2 function.
    }

    \boilerplateBogusTrigCrap{Sin}{sine}
    \boilerplateBogusTrigCrap{Cos}{cosine}
    \boilerplateBogusTrigCrap{Tan}{tangent}
    \boilerplateBogusTrigCrap{Csc}{cosecant}
    \boilerplateBogusTrigCrap{Sec}{secant}
    \boilerplateBogusTrigCrap{Cot}{cotangent}
  }
  \item \AgdaInductiveConstructor{Derivative} \AgdaBound{name} represents \(\left(\lambda\ e \rightarrow \derivative{\AgdaBound{name}} e\right)\).
  \item \AgdaInductiveConstructor{Antiderivative} \AgdaBound{name} represents \(\left(\lambda\ e \rightarrow \int_{\AgdaBound{name}} e\right)\).
  \item \AgdaInductiveConstructor{BoundedIntegral} \AgdaBound{name} represents \(\left(\lambda\ b_1\ b_2\ e \rightarrow \int_{\AgdaBound{name} = b_1}^{b_2} e\right)\).
  \item \AgdaInductiveConstructor{Compose} \AgdaBound{g} \AgdaBound{f} represents the composition of \AgdaBound{g} and \AgdaBound{f}, i.e., \(g' ∘ f'\), where \(g'\) and \(f'\) are the functions which are represented by \AgdaBound{g} and \AgdaBound{f}, respectively.
\end{itemize}

\begin{code}
  data F where
    Abs
     Negate
     Sum
     Product
     Exponent : F
    Lambda : List.List String → F
    Sin
     Cos
     Tan
     Csc
     Sec
     Cot : F
    Limit
     Derivative
     Antiderivative
     BoundedIntegral : String → F
    Compose : (g f : F) → arity g ≡ 1 → F
\end{code}

\subsection{Completing the Arity Function}

\begin{code}
  arity Abs = 1
  arity Negate = 1
  arity Sum = 2
  arity Product = 2
  arity Exponent = 2
  arity Sin = 1
  arity Cos = 1
  arity Tan = 1
  arity Csc = 1
  arity Sec = 1
  arity Cot = 1
  arity (Lambda names) = ℕ.suc (List.length names)
  arity (Limit name) = 2
  arity (Derivative name) = 1
  arity (Antiderivative name) = 1
  arity (BoundedIntegral name) = 3
  arity (Compose g f eq) = arity f
\end{code}

\subsection{Completing \AgdaDatatype{ε}'s Definition}
The following statements hold:

\begin{itemize}
  \item \AgdaInductiveConstructor{Infinity} represents infinity.
  \item \AgdaInductiveConstructor{Variable} \AgdaBound{n} represents a variable whose name is \AgdaBound{n}.
  \item \AgdaInductiveConstructor{NumberRat} \AgdaBound{q} represents \AgdaBound{q}.
  \item \AgdaInductiveConstructor{Ap} \AgdaBound{f} \AgdaBound {e} represents the result of applying \AgdaBound{f} to \AgdaBound{e}.
\end{itemize}

\begin{code}
  data ε where
    Infinity : ε
    Variable : String → ε
    NumberRat : ℚ → ε
    Ap : (f : F) → Vec ε (arity f) → ε
\end{code}

\section{Patterns}

\subsection{The Natural Number Pattern}
\AgdaInductiveConstructor{NumberNatP} \AgdaBound{n} \AgdaBound{c} is Casanova Fly's canonical representation of \AgdaBound{n}.  Despite generally being pretty powerful, the \AgdaKeyword{pattern} stuff can apparently \emph{not} do \AgdaFunction{Coprimality.1-coprimeTo} stuff.

\begin{code}
  pattern NumberNatP n c = NumberRat (ℚ.mkℚ (Data.Integer.+ n) 0 c)
\end{code}

\subsection{The Quotient Pattern}
\AgdaInductiveConstructor{Quotient} \AgdaBound{x} \AgdaBound{y} \AgdaBound{coprimality} is Casanova Fly's representation of \(\frac{\AgdaBound{x}}{\AgdaBound{y}}\).

\begin{code}
  pattern Quotient x y coprime =
    Ap Product
       ( x
       ∷ (Ap Exponent
             ( y
             ∷ Ap Negate (NumberNatP 1 coprime ∷ [])
             ∷ [])
       ∷ []))
\end{code}

\section{Shorthand Functions}

\subsection{The Natural-Number-to-Expression Function}
\AgdaFunction{NumberNat} \AgdaBound{n} is Casanova Fly's more manageable representation of \AgdaBound{n}.

\begin{code}
  NumberNat : ℕ → ε
  NumberNat n = NumberNatP n (Coprimality.sym (Coprimality.1-coprimeTo _))
\end{code}

\chapter{General-Purpose Functions}

\section{The Commutativity-Determining Function}
\AgdaFunction{isCommutative} \AgdaBound{f} \AgdaBound{a} is \AgdaInductiveConstructor{true} only if \AgdaBound{f} represents a commutative function.

\begin{code}
  isCommutative : (f : F) → arity f ≡ 2 → Bool
  isCommutative Sum refl = true
  isCommutative Product refl = true
  isCommutative Exponent refl = false
  isCommutative (Lambda names) equality = false
  isCommutative (Limit name) equality = false
  isCommutative (Compose g f eq) x = false
\end{code}

\section{The Variable Substitution Function}\label{sec:varSubstM-def}
\AgdaFunction{varSubstM} is the multi-variable substitution function.  In \AgdaFunction{varSubstM} \AgdaBound{l} \AgdaBound{e}, any variable in \AgdaBound{e} which also has an entry in \AgdaBound{l} will be replaced by the corresponding \AgdaDatatype{ε} entry in \AgdaBound{l}.  More formally, one can say that \AgdaFunction{varSubstM} \AgdaBound{l} \AgdaBound{e} is a derivative of \AgdaBound{e} such that for any given variable \AgdaBound{x} in \AgdaBound{e}, if a value \AgdaBound{i} exists such that \AgdaField{proj₁} \AgdaSymbol(\AgdaFunction{List.lookup} \AgdaBound{l} \AgdaBound{i}\AgdaSymbol) is \AgdaBound{x}, then \AgdaBound{x} is replaced by \AgdaField{proj₂} \AgdaSymbol(\AgdaFunction{List.lookup} \AgdaBound{l} \AgdaBound{i}\AgdaSymbol).

\begin{code}
  {-# TERMINATING #-}
  varSubstM : List.List (String × ε) → ε → ε
  varSubstM List.[] x = x
  varSubstM vars o@(NumberRat r) = o
  varSubstM vars o@Infinity = o
  varSubstM (v List.∷ vs) (Variable sv) =
    if proj₁ v Data.String.== sv
       then proj₂ v
       else varSubstM vs (Variable sv)
  varSubstM vars o@(Ap f x) = Ap f (Data.Vec.map (varSubstM vars) x)
\end{code}

\section{The Function for Commutativity Permutations}
\AgdaFunction{commutativePermutations} \AgdaBound{x} is a list of all expressions which are equivalent to \AgdaBound{x} and are derived from \AgdaBound{x} by commutativity.

\begin{code}
  {-# TERMINATING #-}
  commutativePermutations : ε → List.List ε
  commutativePermutations (Ap f e) = perms' f (Data.Vec.toList e) {!!}
    where
    combine : (f : F) → (e : List.List ε) → arity f ≡ List.length e → ε
    combine f e lengthMatch = Ap f (Data.Vec.cast (sym lengthMatch)
                                                  (Data.Vec.fromList e))
    perms' : (f : F) → (e : List.List ε) → arity f ≡ List.length e → List.List ε
    perms' f e@(e1 List.∷ e2 List.∷ List.[]) lengthMatches =
      if isCommutative f lengthMatches then solo else list
      where
      solo = List.[ combine f e lengthMatches ]
      list =
        f' (e2 ∷ [ e1 ]) List.∷ f' (e1 ∷ [ e2 ]) List.∷
        List.map (λ e2 → f' (e1 ∷ [ e2 ])) (commutativePermutations e2) List.++
        List.map (λ e1 → f' (e1 ∷ [ e2 ])) (commutativePermutations e1) List.++
        List.concat (List.map (λ (e1 , e2) → f' (e1 ∷ [ e2 ]) List.∷
                                              List.[ f' (e2 ∷ [ e1 ]) ])
                              (List.zip (commutativePermutations e1)
                                        (commutativePermutations e2)))
        where f' = Ap f ∘ Data.Vec.cast (sym lengthMatches)
    perms' f e lengthMatches = List.[ combine f e lengthMatches ]
  commutativePermutations o = List.[ o ]
\end{code}

\chapter{Descriptive Types and Related Functions}

\section{The Constant Type}
A value of type \AgdaFunction{IsConstant} \AgdaBound{e} exists if and only if \AgdaBound{e} is a constant, i.e., refers to no variables.

\begin{code}
  data IsConstant : ε → Set where
    InfinityIsConstant : IsConstant Infinity
    RationalIsConstant : {q : ℚ} → IsConstant (NumberRat q)
    ConstantApplicationIsConstant :
      (f : F) →
      (x : Vec ε (arity f)) →
      AllVec.All IsConstant x →
      IsConstant (Ap f x)
\end{code}

\subsection{The Decidable Constantness Function}
\AgdaFunction{IsConstant?} is the decidable contstantness function for \AgdaDatatype{ε}.  A bit more formally, one \emph{could} say that exactly one of the following statements applies:

\begin{enumerate}
  \item \AgdaFunction{IsConstant?} \AgdaBound{x} contains a value of type \AgdaFunction{IsConstant} \AgdaBound{x}.
  \item \AgdaFunction{IsConstant?} \AgdaBound{x} contains a proof which indicates that \emph{no such value exists}.
\end{enumerate}

\begin{code}
  {-# TERMINATING #-}
  IsConstant? : (e : ε) → Dec (IsConstant e)
  IsConstant? (Variable x) = no λ ()
  IsConstant? Infinity = yes InfinityIsConstant
  IsConstant? (NumberRat x) = yes RationalIsConstant
  IsConstant? (Ap f x) with AllVec.all? IsConstant? x
  ... | yes xConstant = yes (ConstantApplicationIsConstant f x xConstant)
  ... | no xVariable = no (xVariable ∘ constantOnlyIfXConstant)
    where
    constantOnlyIfXConstant :
      {f : F} →
      {x : Vec ε (arity f)} →
      IsConstant (Ap f x) →
      AllVec.All IsConstant x
    constantOnlyIfXConstant (ConstantApplicationIsConstant f x xC) = xC
\end{code}

\chapter{Decidable Structural Equality Functions}

\section{Decidable Structural Equality on \AgdaDatatype{F}}
This function is used to determine whether or not the input arguments are structurally equivalent.

\begin{code}
  structuralEqualityOnF : DecidableEquality F
  structuralEqualityOnF = s
    where
    s : DecidableEquality F
    s Abs Abs = yes refl
    s Abs Negate = no λ ()
    s Abs Sum = no λ ()
    s Abs Product = no λ ()
    s Abs Exponent = no λ ()
    s Abs (Lambda name) = no λ ()
    s Abs Sin = no λ ()
    s Abs Cos = no λ ()
    s Abs Tan = no λ ()
    s Abs Csc = no λ ()
    s Abs Sec = no λ ()
    s Abs Cot = no λ ()
    s Abs (Limit name) = no λ ()
    s Abs (Derivative name) = no λ ()
    s Abs (Antiderivative name) = no λ ()
    s Abs (BoundedIntegral name) = no λ ()
    s Abs (Compose g f eq) = no λ ()
    s Negate Abs = no λ ()
    s Negate Negate = yes refl
    s Negate Sum = no λ ()
    s Negate Product = no λ ()
    s Negate Exponent = no λ ()
    s Negate (Lambda name) = no λ ()
    s Negate Sin = no λ ()
    s Negate Cos = no λ ()
    s Negate Tan = no λ ()
    s Negate Csc = no λ ()
    s Negate Sec = no λ ()
    s Negate Cot = no λ ()
    s Negate (Limit name) = no λ ()
    s Negate (Derivative name) = no λ ()
    s Negate (Antiderivative name) = no λ ()
    s Negate (BoundedIntegral name) = no λ ()
    s Negate (Compose g f eq) = no λ ()
    s Sum Abs = no λ ()
    s Sum Negate = no λ ()
    s Sum Sum = yes refl
    s Sum Product = no λ ()
    s Sum Exponent = no λ ()
    s Sum (Lambda name) = no λ ()
    s Sum Sin = no λ ()
    s Sum Cos = no λ ()
    s Sum Tan = no λ ()
    s Sum Csc = no λ ()
    s Sum Sec = no λ ()
    s Sum Cot = no λ ()
    s Sum (Limit name) = no λ ()
    s Sum (Derivative name) = no λ ()
    s Sum (Antiderivative name) = no λ ()
    s Sum (BoundedIntegral name) = no λ ()
    s Sum (Compose g f eq) = no λ ()
    s Product Abs = no λ ()
    s Product Negate = no λ ()
    s Product Sum = no λ ()
    s Product Product = yes refl
    s Product Exponent = no λ ()
    s Product (Lambda name) = no λ ()
    s Product Sin = no λ ()
    s Product Cos = no λ ()
    s Product Tan = no λ ()
    s Product Csc = no λ ()
    s Product Sec = no λ ()
    s Product Cot = no λ ()
    s Product (Limit name) = no λ ()
    s Product (Derivative name) = no λ ()
    s Product (Antiderivative name) = no λ ()
    s Product (BoundedIntegral name) = no λ ()
    s Product (Compose g f eq) = no λ ()
    s Exponent Abs = no λ ()
    s Exponent Negate = no λ ()
    s Exponent Sum = no λ ()
    s Exponent Product = no λ ()
    s Exponent Exponent = yes refl
    s Exponent (Lambda name) = no λ ()
    s Exponent Sin = no λ ()
    s Exponent Cos = no λ ()
    s Exponent Tan = no λ ()
    s Exponent Csc = no λ ()
    s Exponent Sec = no λ ()
    s Exponent Cot = no λ ()
    s Exponent (Limit name) = no λ ()
    s Exponent (Derivative name) = no λ ()
    s Exponent (Antiderivative name) = no λ ()
    s Exponent (BoundedIntegral name) = no λ ()
    s Exponent (Compose g f eq) = no λ ()
    s (Lambda n1) Abs = no λ ()
    s (Lambda n1) Negate = no λ ()
    s (Lambda n1) Sum = no λ ()
    s (Lambda n1) Product = no λ ()
    s (Lambda n1) Exponent = no λ ()
    s (Lambda n1) (Lambda n2) with ListProp.≡-dec Data.String._≟_ n1 n2
    ... | yes nEq = yes (cong Lambda nEq)
    ... | no nNeq = no (nNeq ∘ equality-implies-name-equality)
      where
      equality-implies-name-equality :
        {n1 n2 : List.List String} →
        Lambda n1 ≡ Lambda n2 →
        n1 ≡ n2
      equality-implies-name-equality refl = refl
    s (Lambda n1) Sin = no λ ()
    s (Lambda n1) Cos = no λ ()
    s (Lambda n1) Tan = no λ ()
    s (Lambda n1) Csc = no λ ()
    s (Lambda n1) Sec = no λ ()
    s (Lambda n1) Cot = no λ ()
    s (Lambda n1) (Limit name) = no λ ()
    s (Lambda n1) (Derivative name) = no λ ()
    s (Lambda n1) (Antiderivative name) = no λ ()
    s (Lambda n1) (BoundedIntegral name) = no λ ()
    s (Lambda n1) (Compose g f eq) = no λ ()
    -- Help!  I'm trapped in a boring nonsense factory!
    s Sin Abs = no λ ()
    s Sin Negate = no λ ()
    s Sin Sum = no λ ()
    s Sin Product = no λ ()
    s Sin Exponent = no λ ()
    s Sin (Lambda name) = no λ ()
    s Sin Sin = yes refl
    s Sin Cos = no λ ()
    s Sin Tan = no λ ()
    s Sin Csc = no λ ()
    s Sin Sec = no λ ()
    s Sin Cot = no λ ()
    s Sin (Limit name) = no λ ()
    s Sin (Derivative name) = no λ ()
    s Sin (Antiderivative name) = no λ ()
    s Sin (BoundedIntegral name) = no λ ()
    s Sin (Compose g f eq) = no λ ()
    s Cos Abs = no λ ()
    s Cos Negate = no λ ()
    s Cos Sum = no λ ()
    s Cos Product = no λ ()
    s Cos Exponent = no λ ()
    s Cos (Lambda name) = no λ ()
    s Cos Sin = no λ ()
    s Cos Cos = yes refl
    s Cos Tan = no λ ()
    s Cos Csc = no λ ()
    s Cos Sec = no λ ()
    s Cos Cot = no λ ()
    s Cos (Limit name) = no λ ()
    s Cos (Derivative name) = no λ ()
    s Cos (Antiderivative name) = no λ ()
    s Cos (BoundedIntegral name) = no λ ()
    s Cos (Compose g f eq) = no λ ()
    s Tan Abs = no λ ()
    s Tan Negate = no λ ()
    s Tan Sum = no λ ()
    s Tan Product = no λ ()
    s Tan Exponent = no λ ()
    s Tan (Lambda name) = no λ ()
    s Tan Sin = no λ ()
    s Tan Cos = no λ ()
    s Tan Tan = yes refl
    s Tan Csc = no λ ()
    s Tan Sec = no λ ()
    s Tan Cot = no λ ()
    s Tan (Limit name) = no λ ()
    s Tan (Derivative name) = no λ ()
    s Tan (Antiderivative name) = no λ ()
    s Tan (BoundedIntegral name) = no λ ()
    s Tan (Compose g f eq) = no λ ()
    s Csc Abs = no λ ()
    s Csc Negate = no λ ()
    s Csc Sum = no λ ()
    s Csc Product = no λ ()
    s Csc Exponent = no λ ()
    s Csc (Lambda name) = no λ ()
    s Csc Sin = no λ ()
    s Csc Cos = no λ ()
    s Csc Tan = no λ ()
    s Csc Csc = yes refl
    s Csc Sec = no λ ()
    s Csc Cot = no λ ()
    s Csc (Limit name) = no λ ()
    s Csc (Derivative name) = no λ ()
    s Csc (Antiderivative name) = no λ ()
    s Csc (BoundedIntegral name) = no λ ()
    s Csc (Compose g f eq) = no λ ()
    s Sec Abs = no λ ()
    s Sec Negate = no λ ()
    s Sec Sum = no λ ()
    s Sec Product = no λ ()
    s Sec Exponent = no λ ()
    s Sec (Lambda name) = no λ ()
    s Sec Sin = no λ ()
    s Sec Cos = no λ ()
    s Sec Tan = no λ ()
    s Sec Csc = no λ ()
    s Sec Sec = yes refl
    s Sec Cot = no λ ()
    s Sec (Limit name) = no λ ()
    s Sec (Derivative name) = no λ ()
    s Sec (Antiderivative name) = no λ ()
    s Sec (BoundedIntegral name) = no λ ()
    s Sec (Compose g f eq) = no λ ()
    s Cot Abs = no λ ()
    s Cot Negate = no λ ()
    s Cot Sum = no λ ()
    s Cot Product = no λ ()
    s Cot Exponent = no λ ()
    s Cot (Lambda name) = no λ ()
    s Cot Sin = no λ ()
    s Cot Cos = no λ ()
    s Cot Tan = no λ ()
    s Cot Csc = no λ ()
    s Cot Sec = no λ ()
    s Cot Cot = yes refl
    s Cot (Limit name) = no λ ()
    s Cot (Derivative name) = no λ ()
    s Cot (Antiderivative name) = no λ ()
    s Cot (BoundedIntegral name) = no λ ()
    s Cot (Compose g f eq) = no λ ()
    s (Limit n1) Abs = no λ ()
    s (Limit n1) Negate = no λ ()
    s (Limit n1) Sum = no λ ()
    s (Limit n1) Product = no λ ()
    s (Limit n1) Exponent = no λ ()
    s (Limit n1) (Lambda name) = no λ ()
    s (Limit n1) Sin = no λ ()
    s (Limit n1) Cos = no λ ()
    s (Limit n1) Tan = no λ ()
    s (Limit n1) Csc = no λ ()
    s (Limit n1) Sec = no λ ()
    s (Limit n1) Cot = no λ ()
    s (Limit n1) (Limit n2) with n1 Data.String.≟ n2
    ... | yes eq = yes (cong Limit eq)
    ... | no neq = no (neq ∘ equality-implies-variable-equality n1 n2)
      where
      equality-implies-variable-equality : (n1 n2 : String) →
             Limit n1 ≡ Limit n2 →
             n1 ≡ n2
      equality-implies-variable-equality n1 n2 refl = refl
    s (Limit n1) (Derivative name) = no λ ()
    s (Limit n1) (Antiderivative name) = no λ ()
    s (Limit n1) (BoundedIntegral name) = no λ ()
    s (Limit n1) (Compose g f eq) = no λ ()
    s (Derivative n1) Abs = no λ ()
    s (Derivative n1) Negate = no λ ()
    s (Derivative n1) Sum = no λ ()
    s (Derivative n1) Product = no λ ()
    s (Derivative n1) Exponent = no λ ()
    s (Derivative n1) (Lambda name) = no λ ()
    s (Derivative n1) Sin = no λ ()
    s (Derivative n1) Cos = no λ ()
    s (Derivative n1) Tan = no λ ()
    s (Derivative n1) Csc = no λ ()
    s (Derivative n1) Sec = no λ ()
    s (Derivative n1) Cot = no λ ()
    s (Derivative n1) (Limit name) = no λ ()
    s (Derivative n1) (Derivative n2) with n1 Data.String.≟ n2
    ... | yes eq = yes (cong Derivative eq)
    ... | no neq = no (neq ∘ equality-implies-variable-equality n1 n2)
      where
      equality-implies-variable-equality : (n1 n2 : String) →
             Derivative n1 ≡ Derivative n2 →
             n1 ≡ n2
      equality-implies-variable-equality n1 n2 refl = refl
    s (Derivative n1) (Antiderivative name) = no λ ()
    s (Derivative n1) (BoundedIntegral name) = no λ ()
    s (Derivative n1) (Compose g f eq) = no λ ()
    s (Antiderivative n1) Abs = no λ ()
    s (Antiderivative n1) Negate = no λ ()
    s (Antiderivative n1) Sum = no λ ()
    s (Antiderivative n1) Product = no λ ()
    s (Antiderivative n1) Exponent = no λ ()
    s (Antiderivative n1) (Lambda name) = no λ ()
    s (Antiderivative n1) Sin = no λ ()
    s (Antiderivative n1) Cos = no λ ()
    s (Antiderivative n1) Tan = no λ ()
    s (Antiderivative n1) Csc = no λ ()
    s (Antiderivative n1) Sec = no λ ()
    s (Antiderivative n1) Cot = no λ ()
    s (Antiderivative n1) (Limit name) = no λ ()
    s (Antiderivative n1) (Derivative name) = no λ ()
    s (Antiderivative n1) (Antiderivative n2) with n1 Data.String.≟ n2
    ... | yes eq = yes (cong Antiderivative eq)
    ... | no neq = no (neq ∘ equality-implies-variable-equality n1 n2)
      where
      equality-implies-variable-equality : (n1 n2 : String) →
             Antiderivative n1 ≡ Antiderivative n2 →
             n1 ≡ n2
      equality-implies-variable-equality n1 n2 refl = refl
    s (Antiderivative n1) (BoundedIntegral name) = no λ ()
    s (Antiderivative n1) (Compose g f eq) = no λ ()
    s (BoundedIntegral n1) Abs = no λ ()
    s (BoundedIntegral n1) Negate = no λ ()
    s (BoundedIntegral n1) Sum = no λ ()
    s (BoundedIntegral n1) Product = no λ ()
    s (BoundedIntegral n1) Exponent = no λ ()
    s (BoundedIntegral n1) (Lambda name) = no λ ()
    s (BoundedIntegral n1) Sin = no λ ()
    s (BoundedIntegral n1) Cos = no λ ()
    s (BoundedIntegral n1) Tan = no λ ()
    s (BoundedIntegral n1) Csc = no λ ()
    s (BoundedIntegral n1) Sec = no λ ()
    s (BoundedIntegral n1) Cot = no λ ()
    s (BoundedIntegral n1) (Limit name) = no λ ()
    s (BoundedIntegral n1) (Derivative name) = no λ ()
    s (BoundedIntegral n1) (Antiderivative name) = no λ ()
    s (BoundedIntegral n1) (BoundedIntegral n2) with n1 Data.String.≟ n2
    ... | yes eq = yes (cong BoundedIntegral eq)
    ... | no neq = no (neq ∘ equality-implies-variable-equality n1 n2)
      where
      equality-implies-variable-equality : (n1 n2 : String) →
             BoundedIntegral n1 ≡ BoundedIntegral n2 →
             n1 ≡ n2
      equality-implies-variable-equality n1 n2 refl = refl
    s (BoundedIntegral n1) (Compose g f eq) = no λ ()
    s (Compose g f eq1) Abs = no λ ()
    s (Compose g f eq1) Negate = no λ ()
    s (Compose g f eq1) Sum = no λ ()
    s (Compose g f eq1) Product = no λ ()
    s (Compose g f eq1) Exponent = no λ ()
    s (Compose g f eq1) (Lambda name) = no λ ()
    s (Compose g f eq1) Sin = no λ ()
    s (Compose g f eq1) Cos = no λ ()
    s (Compose g f eq1) Tan = no λ ()
    s (Compose g f eq1) Csc = no λ ()
    s (Compose g f eq1) Sec = no λ ()
    s (Compose g f eq1) Cot = no λ ()
    s (Compose g f eq1) (Limit name) = no λ ()
    s (Compose g f eq1) (Derivative name) = no λ ()
    s (Compose g f eq1) (Antiderivative name) = no λ ()
    s (Compose g f eq1) (BoundedIntegral name) = no λ ()
    s (Compose g f eq1) (Compose y x eq2) with s g y | s f x
    ... | yes gIsy | yes fIsx = yes (compeq gIsy fIsx)
      where
      compeq : {g f y x : F} →
               {eq1 : _} →
               {eq2 : _} →
               g ≡ y →
               f ≡ x →
               Compose g f eq1 ≡ Compose y x eq2
      compeq refl refl = {!!}
    ... | no gIsNoty | _ = no (gIsNoty ∘ eq-implies-first-eq)
      where
      eq-implies-first-eq :
        {f g x y : F} →
        {eq1 : _} →
        {eq2 : _} →
        Compose g f eq1 ≡ Compose y x eq2 → g ≡ y
      eq-implies-first-eq refl = refl
    ... | _ | no fIsNotx = no (fIsNotx ∘ eq-implies-second-eq)
      where
      eq-implies-second-eq :
        {f g x y : F} →
        {eq1 : _} →
        {eq2 : _} →
        Compose g f eq1 ≡ Compose y x eq2 →
        f ≡ x
      eq-implies-second-eq refl = refl
\end{code}

\section{Decidable Structural Equality on \AgdaDatatype{ε}}
This function is used to determine whether or not the input arguments are structurally equivalent.

\begin{code}
  {-# TERMINATING #-}
  structuralEqualityOnε : DecidableEquality ε
  structuralEqualityOnε = s
    where
    s : DecidableEquality ε
    s Infinity Infinity = yes refl
    s Infinity (Variable v) = no λ ()
    s Infinity (NumberRat r) = no λ ()
    s Infinity (Ap f x) = no λ ()
    s (Variable v) Infinity = no λ ()
    s (Variable v1) (Variable v2) with v1 Data.String.≟ v2
    ... | yes namesAreEqual = yes (cong Variable namesAreEqual)
    ... | no differentNames = no (differentNames ∘ same-variable-implies-same-name)
      where
      same-variable-implies-same-name :
        {n1 n2 : String} →
        Variable n1 ≡ Variable n2 →
        n1 ≡ n2
      same-variable-implies-same-name refl = refl
    s (Variable v) (NumberRat r) = no λ ()
    s (Variable v) (Ap f x) = no λ ()
    s (NumberRat r) Infinity = no λ ()
    s (NumberRat r) (Variable v) = no λ ()
    s (NumberRat r1) (NumberRat r2) with r1 ℚ.≟ r2
    ... | yes ratsAreEqual = yes (cong NumberRat ratsAreEqual)
    ... | no ratsAreDifferent = no (ratsAreDifferent ∘ same-numberRat-implies-same-rat)
      where
      same-numberRat-implies-same-rat :
        {q1 q2 : ℚ} →
        NumberRat q1 ≡ NumberRat q2 →
        q1 ≡ q2
      same-numberRat-implies-same-rat refl = refl
    s (NumberRat r) (Ap f x) = no λ ()
    s (Ap f x) Infinity = no λ ()
    s (Ap f x) (Variable v) = no λ ()
    s (Ap f x) (NumberRat r) = no λ ()
    s (Ap f1 x1) (Ap f2 x2) with structuralEqualityOnF f2 f1
    ... | no differentF = no (differentF ∘ sym ∘ same-only-with-same-function)
      where
      same-only-with-same-function :
        {f1 f2 : F} →
        {x1 : Vec ε (arity f1)} →
        {x2 : Vec ε (arity f2)} →
        Ap f1 x1 ≡ Ap f2 x2 →
        f1 ≡ f2
      same-only-with-same-function refl = refl
    ... | yes sameF with VecProp.≡-dec structuralEqualityOnε
                                       x1 (Data.Vec.cast (cong arity sameF) x2)
    ... | yes sameX = yes (combine sameF sameX)
      where
      combine :
        {f1 f2 : F} →
        {x1 : Vec ε (arity f1)} →
        {x2 : Vec ε (arity f2)} →
        (sameF : f2 ≡ f1) →
        x1 ≡ Data.Vec.cast (cong arity sameF) x2 →
        Ap f1 x1 ≡ Ap f2 x2
      combine = {!!}
    ... | no differentX = no (differentX ∘ same-only-with-same-x sameF)
      where
      same-only-with-same-x :
        {f1 f2 : F} →
        {x1 : Vec ε (arity f1)} →
        {x2 : Vec ε (arity f2)} →
        (sameF : f2 ≡ f1) →
        Ap f1 x1 ≡ Ap f2 x2 →
        x1 ≡ Data.Vec.cast (cong arity sameF) x2
      same-only-with-same-x = {!!}
\end{code}

\chapter{Functions for Evaluation and Algebraic Equality}

\section{The Types of the Algebraic Equality Type and the Single-Step Evaluation Function}

\subsection{The Algebraic Equality Function}
A value of type \AgdaFunction{AlgebraicEquality} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is \emph{algebraically} equal to \AgdaBound{y}, i.e., \AgdaBound{x} and \AgdaBound{y} represent the same numerical value.  This algebraic equality type should not be confused with the \emph{propositional} equality type, which, as intended, fails to recognize that \(x + y\) is in some way equal to \(y + x\).

\begin{code}
  AlgebraicEquality : ε → ε → Set
\end{code}

\subsection{The Algebraic Equality Determination Function}
Informally, one can say that \AgdaFunction{checkAlgebraicEquality} \AgdaBound{n} is the \AgdaBound{n}-iteration equality check function. Formally, one can say that the following statements apply:

\begin{enumerate}
  \item If \AgdaBound{x} and \AgdaBound{y} are shown to be \gls{algInj2equal} within \AgdaBound{n} iterations, then \AgdaFunction{checkAlgebraicEquality} \AgdaBound{n} \AgdaBound{x} \AgdaBound{y} is \AgdaInductiveConstructor{inj₂} \AgdaSymbol(\AgdaInductiveConstructor{just} \AgdaBound{p}\AgdaSymbol), where \AgdaBound{p} is a proof of the aforementined algebraic equality.\label{enum:eqCheck-just-if-equal}
  \item If \AgdaBound{x} and \AgdaBound{y} are non-bogus for all iteration counts which are less than or equal to \AgdaBound{n}, but no appropriate equality proof exists, then \AgdaFunction{checkAlgebraicEquality} \AgdaBound{n} \AgdaBound{x} \AgdaBound{y} is \AgdaInductiveConstructor{inj₂} \AgdaInductiveConstructor{nothing}.\label{enum:eqCheck-nothing-if-not-equal}
  \item If \AgdaBound{x} or \AgdaBound{y} is bogusly evaluated at some iteration count which is less than or equal to \AgdaBound{n}, then \AgdaFunction{checkAlgebraicEquality} \AgdaBound{n} \AgdaBound{x} \AgdaBound{y} is \AgdaInductiveConstructor{inj₁} \AgdaBound{s}, where \AgdaBound{s} is some description of the aforementioned bogosity.\label{enum:eqCheck-inj1-if-bogus}
\end{enumerate}

\begin{code}
  checkAlgebraicEquality :
    ℕ → (x y : ε) → Exceptional (Maybe (AlgebraicEquality x y))
\end{code}

\subsection{The Single-Step Evaluation Function}
\AgdaFunction{exceptionallyEvaluate} \AgdaBound{x} contains the result of performing a single evaluation step on \AgdaBound{x} \emph{or} a value which indicates that \AgdaBound{x} is in some way nonsensical.

\begin{code}
  exceptionallyEvaluate : ε → Exceptional ε
\end{code}

\section{The Single-Step Evaluation Function which \emph{also} Supports Commutativity}
\AgdaFunction{commutativeEvaluate} \AgdaBound{e} performs a single evaluation step on the input expression but can also do some fancy stuff when applicable, e.g., switching the arguments of commutative functions.

\begin{code}
  commutativeEvaluate : ε → Exceptional ε
  commutativeEvaluate e@(Ap f x) =
    if (e evaluates) then evaluate e else tryFlip (arity f Data.Nat.≟ 2)
    where
    -- evaluate is just an abbreviation.  "exceptionallyEvaluate" is a bit long.
    evaluate = exceptionallyEvaluate
    structuralEquality =
      Data.Sum.Properties.≡-dec Data.String._≟_ structuralEqualityOnε
    _evaluates : ε → Bool
    _evaluates e = isNo (structuralEquality (inj₂ e) (evaluate e))
    tryFlip : Dec (arity f ≡ 2) → Exceptional ε
    tryFlip (no arityDiffers) = evaluate e
    tryFlip (yes arityMatches) =
      if isCommutative f arityMatches ∧ (e2 evaluates) then inj₂ e2 else evaluate e
      where e2 = Ap f (reverse x)
  commutativeEvaluate e = exceptionallyEvaluate e
\end{code}

\section{The Point-Free Rewrite Function}
If the result is not \AgdaInductiveConstructor{nothing}, then \AgdaFunction{pfRewrite} \AgdaBound{e} contains some expression of the form \AgdaInductiveConstructor{Ap} \AgdaSymbol(\AgdaInductiveConstructor{Compose} \AgdaBound{g} \AgdaBound{f} \AgdaBound{arityProof}\AgdaSymbol) \AgdaBound{x} such that the following statements hold:

\begin{enumerate}
  \item \AgdaInductiveConstructor{Ap} \AgdaSymbol(\AgdaInductiveConstructor{Compose} \AgdaBound{g} \AgdaBound{f} \AgdaBound{arityProof}\AgdaSymbol) \AgdaBound{x} is algebraically equal to \AgdaBound{ε}.\label{enum:pfRewriteEquality}
\end{enumerate}

\begin{code}
  module pfRewrite where

    helper : (f : F) → ε → arity f ≡ 1 → Maybe ε
    helper g (Ap f x) eq = just (Ap (Compose g f eq) x)
    helper g x eq = nothing

    onlyElement : {n : ℕ} →
                  {a : Level} →
                  {A : Set a} →
                  Vec A n →
                  n ≡ 1 →
                  A
    onlyElement x eq = Data.Vec.lookup (Data.Vec.cast eq x) Fin.zero

    main : ε → Maybe ε
    main (Ap g x) = _>>=_ (decToMaybe (arity g Data.Nat.≟ 1))
                          (λ eq → helper g (onlyElement x eq) eq)
    main _ = nothing

  pfRewrite = pfRewrite.main
\end{code}

\section{Completing the Algebraic Equality Function}
Regardless of the indentation in the compiled PDF document, this entire section, save for the final definition, constitutes a single module\ldots{} and facilitates defining \AgdaFunction{AlgebraicEquality}.

\begin{code}
  module AlgebraicEquality where
\end{code}

\subsection{The Type of the Main Equality Type}
A value of type \AgdaDatatype{main} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is algebraically equal to \AgdaBound{y}.  The reader may be right to think that this explanation is uncannily similar to another explanation\ldots{}

\begin{code}
    data main : ε → ε → Set
\end{code}

\subsection{The Exceptional Equality Type}
A value of type \AgdaFunction{main2} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} and \AgdaBound{y} \glspl{inj2contain} equal values.

\begin{code}
    main2 : Exceptional ε → Exceptional ε → Set
    main2 (inj₂ x) (inj₂ y) = main x y
    main2 _ _ = ⊥
\end{code}

\subsection{Completing the Main Equality Type}

\subsubsection{Structural Equality's Implication of Algebraic Equality}
According to \AgdaInductiveConstructor{EqualityImpliesAE}, two \AgdaDatatype{ε} values \AgdaBound{x} and \AgdaBound{y} are structurally equal only if \AgdaBound{x} is algebraically equal to \AgdaBound{y}.

\subsubsection{Sum Commutativity}
Basically, according to \AgdaInductiveConstructor{SumCommutes}, \(a + b = b + a\) or, equivalently, if \(a = a\prime\) and \(b = b\prime\), then \(a + b = b\prime + a\prime\).

\subsubsection{Product Commutativity}
Basically, according to \AgdaInductiveConstructor{ProductCommutes}, \(a \cdot b = b \cdot a\) or, equivalently, if \(a = a\prime\) and \(b = b\prime\), then \(a \cdot b = b\prime \cdot a\prime\).

\subsubsection{Sum Associativity}
Basically, according to \AgdaInductiveConstructor{SumIsAssociative}, \(a + \left(b + c\right) = \left(a + b\right) + c\).

\subsubsection{Product Associativity}
Basically, according to \AgdaInductiveConstructor{ProductIsAssociative}, \(a \cdot \left(b \cdot c\right) = \left(a \cdot b\right) \cdot c\).

\subsubsection{Composition}
Thanks to \AgdaInductiveConstructor{Composition}, proving that \(g \left(f\ x\right)\) is \AgdaBound{c}-\gls{algEq} to \(\left(g \circ f\right)\ x\) is downright simple.

\subsubsection{Symmetry}
Basically, according to \AgdaInductiveConstructor{Symmetry}, if \(a = b\), then \(b = a\).

\subsubsection{Transitivity}
Basically, according to \AgdaInductiveConstructor{Transitivity}, if \(a = b\) and \(b = c\), then \(a = c\).

\subsubsection{Eventuality}
For all \AgdaDatatype{ε} values \AgdaBound{x} and \AgdaBound{y}, if some evaluation of \AgdaBound{x} \gls{inj2contain} a value which is algebraically equal to a value which is contained by some evaluation of \AgdaBound{y}, then \AgdaBound{x} is algebraically equal to \AgdaBound{y}.  The preceding fact is encoded through \AgdaInductiveConstructor{Eventuality}.

\subsubsection{The Formal Definition}

\begin{code}
    data main where
      EqualityImpliesAE : {e1 e2 : ε} → e1 ≡ e2 → main e1 e2
      SumCommutes :
        {x y : ε} → main (Ap Sum (x ∷ y ∷ [])) (Ap Sum (y ∷ x ∷ []))
      ProductCommutes :
        {x y : ε} → main (Ap Product (x ∷ y ∷ [])) (Ap Product (y ∷ x ∷ []))
      SumIsAssociative :
        {x1 x2 x3 : ε} →
        main (Ap Sum (x1 ∷ [ Ap Sum (x2 ∷ [ x3 ]) ]))
             (Ap Sum (Ap Sum (x1 ∷ [ x2 ]) ∷ [ x3 ]))
      ProductIsAssociative :
        {x1 x2 x3 : ε} →
        main (Ap Product (x1 ∷ [ Ap Product (x2 ∷ [ x3 ]) ]))
             (Ap Product (Ap Product (x1 ∷ [ x2 ]) ∷ [ x3 ]))
      Composition : {g f : F} →
                    {x : Vec ε (arity f)} →
                    (eq : arity g ≡ 1) →
                    main (Ap (Compose g f eq) x)
                         (Ap g (Data.Vec.cast (sym eq) [ Ap f x ]))
      Symmetry : {x y : ε} → main x y → main y x
      Transitivity : {x y z : ε} → main x y → main y z → main x z
      Eventuality :
        {x y : ε} →
        (itx ity : ℕ) →
        main2 (repeatExceptional itx exceptionallyEvaluate x)
              (repeatExceptional ity exceptionallyEvaluate y) →
        main x y
\end{code}

\subsection{The Equivalence Proof}
\AgdaFunction{equivalence} proves that \AgdaDatatype{main} is an equivalence relation.

\begin{code}
    equivalence : IsEquivalence main
    equivalence = record
      { refl = EqualityImpliesAE refl
      ; sym = Symmetry
      ; trans = Transitivity
      }
\end{code}

\subsection{Various Properties of the Algebraic Equality Type Function}

\begin{code}
    module Properties where
\end{code}

\subsubsection{Basic Composition Equality}
A bit informally, one can say that \AgdaFunction{composition-equality} proves that relevant composition is algebraically equivalent to relevant repeated application.

\begin{code}
      composition-equality :
        (g f : F) →
        (x : Vec ε (arity f)) →
        (eq : arity g ≡ 1) →
        main (Ap (Compose g f eq) x)
             (Ap g (Data.Vec.cast (sym eq) [ Ap f x ]))
      composition-equality g f x eq = Composition eq
\end{code}

\subsection{Exporting and Defining the Global Algebraic Equality Function}
\AgdaFunction{AlgebraicEquality} is really just \AgdaDatatype{AlgebraicEquality.main}.

\begin{code}
  AlgebraicEquality = AlgebraicEquality.main
\end{code}

\section{Completing the Single-Step Evaluation Function}

\begin{code}
  module exceptionallyEvaluate where
    main : ε → Exceptional ε

    functions =
      ( (λ { (Ap Negate (Ap Negate (x ∷ []) ∷ [])) → valid x
           ; _ → nothing})
      ∷ (λ { (Ap Negate (NumberRat x ∷ [])) → valid (NumberRat (ℚ.0ℚ ℚ.- x))
           ; _ → nothing})
      ∷ (λ { (Ap Sum (NumberNatP 0 c ∷ x ∷ [])) → valid x
           ; _ → nothing})
      ∷ (λ { (Ap Sum (NumberRat x ∷ NumberRat y ∷ [])) →
             valid (NumberRat (x ℚ.+ y))
           ; _ → nothing})
      ∷ (λ { (Ap Product (NumberRat x ∷ NumberRat y ∷ [])) →
             valid (NumberRat (x ℚ.* y))
           ; _ → nothing})
      ∷ (λ { (Ap Exponent (NumberNatP x c1 ∷ NumberNatP y c2 ∷ [])) →
             if (x Data.Nat.≡ᵇ 0) ∧ (y Data.Nat.≡ᵇ 0)
               then bust "0^0 is undefined!"
               else valid (NumberNat (x Data.Nat.^ y))
           ; _ → nothing})
      ∷ (λ { (Ap Exponent (NumberNatP 0 coprime ∷ NumberRat y ∷ [])) →
             if y ℚ.≤ᵇ ℚ.0ℚ
                then bust "\\(0^x\\) is undefined for non-positive \\(x\\)!"
                else nothing
           ; _ → nothing})
      -- The following "x^0" evaluation rule is a bit dubious; this rule
      -- indicates that Variable x ^ fromℕ 0 is algebraically equal to
      -- fromℕ 1.  However, Variable x *could* feasibly be defined as
      -- being equal to fromℕ 0.
      -- The current behavior parallels Maxima, though.
      ∷ (λ { (Ap Exponent (x ∷ NumberNatP 0 c ∷ [])) → valid (NumberNat 1)
           ; _ → nothing})
      -- The following "0^x" evaluation rule, like the "x^0" rule, is
      -- kind of dubious.  This rule, too, mirrors the behavior of
      -- Maxima, though.
      ∷ (λ { (Ap Exponent ((NumberNatP 0 c) ∷ e ∷ [])) →
             let eq2 = Data.Sum.Properties.≡-dec Data.String._≟_
                                                 structuralEqualityOnε in
             -- The following check ensures that expressions like
             -- Ap Exponent (NumberRat ℚ.0ℚ ∷ [ NumberNat 0 ])
             -- are not wrongly evaluated to inj₂ (NumberNat 0).
             if isYes (eq2 (inj₂ e) (main e))
                then valid (NumberNat 0)
                else [_,_] bust
                           (λ x → valid (Ap Exponent ((NumberNat 0) ∷ [ x ])))
                           (main e)
           ; _ → nothing})
      ∷ (λ { (Ap Exponent (x ∷ NumberNatP 1 c ∷ [])) → valid x
           ; _ → nothing})
      -- The following evaluation rule prevents becoming stuck in a
      -- derivative evaluation loop.
      ∷ (λ { (Ap (Lambda (n1 List.∷ List.[])) (Ap (Derivative n2) e1 ∷ e2 ∷ [])) →
             [_,_]′ bust
                    (λ derivative → valid (Ap (Lambda List.[ n1 ])
                                              (derivative ∷ [ e2 ])))
                    (main (Ap (Derivative n2) e1))
           ; _ → nothing})
      -- The following evaluation rule is *also* kind of dubious, but,
      -- again, the behavior is like the behavior of Maxima.
      ∷ (λ { (Ap (Derivative v1) (Variable v2 ∷ [])) →
             if v1 Data.String.== v2
               then valid (NumberNat 1)
               else valid (NumberNat 0)
           ; _ → nothing})
      ∷ (λ { (Ap (Derivative v1) (NumberRat x ∷ [])) →
             valid (NumberNat 0)
           ; _ → nothing})
      ∷ (λ { (Ap (Derivative v1) (Ap Negate x ∷ [])) →
             valid (Ap Negate [ Ap (Derivative v1) x ])
           ; _ → nothing})
      ∷ (λ { (Ap (Derivative v1) (Ap Sum (x ∷ y ∷ []) ∷ [])) →
             valid (Ap Sum ( Ap (Derivative v1) [ x ]
                           ∷ [ Ap (Derivative v1) [ y ] ]))
           ; _ → nothing})
      ∷ (λ { (Ap (Derivative v1) (Ap Product (x ∷ y ∷ []) ∷ [])) →
             valid (Ap Sum
                       ( Ap Product (Ap (Derivative v1) [ x ] ∷ [ y ])
                       ∷ [ Ap Product (Ap (Derivative v1) [ y ] ∷ [ x ])]))
           ; _ → nothing})
      ∷ (λ { (Ap (Derivative v1) (Ap Sin (Variable v2 ∷ []) ∷ [])) →
             if v1 Data.String.== v2
               then valid (Ap Cos [ Variable v1 ])
               else nothing
           ; _ → nothing})
      ∷ (λ { (Ap (Derivative v1) (Ap Cos (Variable v2 ∷ []) ∷ [])) →
             if v1 Data.String.== v2
               then valid (Ap Negate [ Ap Sin [ Variable v1 ] ])
               else nothing
           ; _ → nothing})
      ∷ (λ { (Ap (Derivative v1) (Ap Tan (Variable v2 ∷ []) ∷ [])) →
             if v1 Data.String.== v2
               then valid (Ap Exponent ( Ap Sec [ Variable v1 ] ∷ [ NumberNat 2 ]))
               else nothing
           ; _ → nothing})
      ∷ (λ { (Ap (Derivative v1) (Ap Csc (Variable v2 ∷ []) ∷ [])) →
             if v1 Data.String.== v2
               then valid (Ap Product
                              ( Ap Csc [ Variable v1 ]
                              ∷ [ Ap Negate [ Ap Cot [ Variable v1 ] ] ]))
               else nothing
           ; _ → nothing})
      ∷ (λ { (Ap (Derivative v1) (Ap Sec (Variable v2 ∷ []) ∷ [])) →
             if v1 Data.String.== v2
               then valid (Ap Product
                              ( Ap Sec [ Variable v1 ]
                              ∷ [ Ap Tan [ Variable v1 ] ]))
               else nothing
           ; _ → nothing})
      ∷ (λ { (Ap (Derivative v1) (Ap Cot (Variable v2 ∷ []) ∷ [])) →
             if v1 Data.String.== v2
               then valid (Ap Negate
                              [ Ap Exponent
                                   ( Ap Csc [ Variable v1 ]
                                   ∷ [ NumberNat 2 ]) ])
               else nothing
           ; _ → nothing})
      ∷ (λ { (Ap (Lambda names) (body ∷ expressions)) →
             valid (varSubstM (List.zip names (Data.Vec.toList expressions)) body)
           ; _ → nothing})
      ∷ freeDerivativesFromPoints
      ∷ basicDerivativeChainRuleFunction
      ∷ (λ { (Ap f x) → [_,_] bust
                              (valid ∘ Ap f)
                              (condenseExceptionList (Data.Vec.map main x))
           ; _ → nothing})
      ∷ []
      )
      where
      bust = just ∘ inj₁
      valid = just ∘ inj₂
      freeDerivativesFromPoints : ε → Maybe (Exceptional ε)
      freeDerivativesFromPoints =
        λ { (Ap (Derivative n) (x ∷ [])) →
            Data.Maybe.map (inj₂ ∘ Ap (Derivative n) ∘ [_])
                           (pfRewrite x)
          ; _ → nothing}
      basicDerivativeChainRuleFunction : ε → Maybe (Exceptional ε)
      basicDerivativeChainRuleFunction = b
        where
        b : ε → Maybe (Exceptional ε)
        b (Ap (Derivative n1) (Ap (Compose g f eq) x ∷ [])) with arity f Data.Nat.≟ 1
        ... | no not-applicable = nothing
        ... | yes fArity1 =
          valid (Ap Product
                    ( Ap (Derivative n1) [ Ap g x2 ]
                    ∷ [ fDiff [ Ap g x2 ] ]))
            where
            fDiff = Ap (Lambda List.[ n1 ]) ∘ (Ap (Derivative n1) [ Ap f x ] ∷_)
            x2 = Data.Vec.cast (trans fArity1 (sym eq)) x
        b _ = nothing

    {-# TERMINATING #-}
    main e = fromMaybe (inj₂ e)
           $ List.head ∘ List.mapMaybe (_$ e)
           $ Data.Vec.toList functions

  {-# TERMINATING #-}
  exceptionallyEvaluate = exceptionallyEvaluate.main
\end{code}

\section{Completing The Algebraic Equality Determination Function}

\begin{code}
  module checkAlgebraicEquality where
    with-dec : {x y : ε} →
               ℕ →
               Dec (x ≡ y) →
               Exceptional (Maybe (AlgebraicEquality x y))
    with-dec iters = maybe (inj₂ ∘ just ∘ AlgebraicEquality.EqualityImpliesAE)
                           {!!}
                   ∘ decToMaybe

    main : ℕ → (x y : ε) → Exceptional (Maybe (AlgebraicEquality x y))
    main iterations = with-dec iterations ∘₂ structuralEqualityOnε

  checkAlgebraicEquality = checkAlgebraicEquality.main
\end{code}

\chapter{The Less-Than Type}
A value of type \AgdaFunction{LessThan} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is less than \AgdaBound{y}.

\begin{code}
  module LessThan where
\end{code}

\section{The Type of the Less-Than Thingamajig}
Basically, some value of type \AgdaDatatype{LT} \AgdaBound{x} \AgdaBound{y} exists if and only if \AgdaBound{x} is less than \AgdaBound{y}.

\begin{code}
    data LT : ε → ε → Set
\end{code}

\section{The \emph{Exceptional} Less-Than Function}
Some thing is a value of type \AgdaFunction{LT2} \AgdaBound{x} \AgdaBound{y} if and only if \AgdaBound{x} and \AgdaBound{y} \glspl{inj2contain} values \AgdaBound{x'} and \AgdaBound{y'}, respectively, and \AgdaBound{x'} can be shown to be less than \AgdaBound{y'}.

\begin{code}
    LT2 : Exceptional ε → Exceptional ε → Set
    LT2 (inj₂ x) (inj₂ y) = LT x y
    LT2 _ _ = ⊥
\end{code}

\section{Completing the Less-Than Thingamajig}

\begin{code}
    data LT where
      LT-Rational :
        {x y : ℚ} → x ℚ.< y → LT (NumberRat x) (NumberRat y)
      Eventuality :
        {x y : ε} →
        (itx ity : ℕ) →
        let rEvaluate = flip repeatExceptional commutativeEvaluate in
        LT2 (rEvaluate itx x) (rEvaluate ity y) →
        LT x y
\end{code}

\section{The Properties of the Less-Than Relation}
This section --- and module --- contains various proofs which pertain to \AgdaDatatype{LT}.

\begin{code}
    module Properties where
\end{code}

\subsection{Strict Partial Order}
\AgdaFunction{strict-partial-order} proves that \AgdaDatatype{LT} is a strict partial order relation.

\begin{code}
      strict-partial-order : IsStrictPartialOrder AlgebraicEquality LT
      strict-partial-order = record
        { isEquivalence = AlgebraicEquality.equivalence
        ; irrefl = {!!}
        ; trans = {!!}
        ; <-resp-≈ = {!!}
        }
\end{code}

\section{Exporting Stuff}
\AgdaDatatype{LessThan.LT} has all necessary properties for the \AgdaFunction{LessThan} function; accordion, \AgdaFunction{LessThan} is really just \AgdaDatatype{LessThan.LT}.

\begin{code}
  LessThan = LessThan.LT
\end{code}

\chapter{The Variable Usedness Type}
\AgdaBound{name} is the name of a variable which is referenced in \AgdaBound{e} if and only if there exists a value of type \AgdaFunction{IsReferencedIn} \AgdaBound{name} \AgdaBound{e}.

\begin{code}
  data IsReferencedIn : String → ε → Set where
    ArgumentIsLiterallyTheVariable :
      {name : String} →
      {e : ε} →
      e ≡ Variable name →
      IsReferencedIn name e
    VariableIsAnArgument :
      {name : String} →
      {f : F} →
      {list : Vec ε (arity f)} →
      AnyVec.Any (IsReferencedIn name) list →
      IsReferencedIn name (Ap f list)
\end{code}

\chapter{The Associated Proofs}

\begin{code}
  module Properties where
\end{code}

\section{Purpose}
This chapter contains various proofs regarding the stuff which was defined in \fref{sec:casanovaFlyCore}.

\section{\AgdaFunction{pfRewrite} Equality}
\AgdaFunction{pfRewrite-basicEquality} proves that the statement in \fref{enum:pfRewriteEquality} is actually \emph{correct}, i.e., \AgdaFunction{pfRewrite-basicEquality} proves that any value which is contained by \AgdaFunction{pfRewrite} \AgdaBound{e} is \AgdaBound{c}-\gls{algEq} to \AgdaBound{e}.

\begin{code}
    pfRewrite-basicEquality :
      (e : ε) →
      (isJust : Is-just (pfRewrite e)) →
      AlgebraicEquality e (to-witness isJust)

    module pfRewrite-basicEquality where
      open pfRewrite hiding (main)
      open AlgebraicEquality hiding (main)

      lookup-cast :
        {n : ℕ}
        {a : Level} →
        {A : Set a} →
        (x : A) →
        (eq : n ≡ 1) →
        lookup (cast eq (cast (sym eq) [ x ])) Fin.zero ≡ x
      lookup-cast x eq = cong (λ x → lookup x Fin.zero)
                              (VecProp.cast-sym (sym eq) refl)

      specific-equality :
        (g f : F) →
        (x : Vec ε (arity f))
        (eq : arity g ≡ 1) →
        _≡_ (pfRewrite (Ap g (Data.Vec.cast (sym eq) [ Ap f x ])))
            (just (Ap (Compose g f eq) x))
      specific-equality g f x eq = begin
        pfRewrite (Ap g (Data.Vec.cast (sym eq) [ Ap f x ]))
          ≡⟨⟩
        (decToMaybe (arity g Data.Nat.≟ 1) >>= helperFun)
          ≡⟨ cong (_>>= helperFun) decToMaybe-is-just ⟩
        (just eq >>= helperFun)
          ≡⟨⟩
        helper g (onlyElement (Data.Vec.cast (sym eq) [ Ap f x ]) eq) eq
          ≡⟨ cong (λ x → helper g x eq) (lookup-cast (Ap f x) eq) ⟩
        helper g (Ap f x) eq
          ≡⟨⟩
        just (Ap (Compose g f eq) x) ∎
        where
        helperFun =
          λ eq → helper g
                        (onlyElement (Data.Vec.cast (sym eq)
                                                    [ Ap f x ])
                                     eq)
                        eq
        decToMaybe-is-just : decToMaybe (arity g Data.Nat.≟ 1) ≡ just eq
        decToMaybe-is-just = let question = arity g Data.Nat.≟ 1 in begin
          decToMaybe (arity g Data.Nat.≟ 1)
            ≡⟨ cong decToMaybe (proj₂ (dec-yes question eq)) ⟩
          just (proj₁ (dec-yes question eq))
            ≡⟨ cong just (≡-irrelevant (proj₁ (dec-yes question eq)) eq) ⟩
          just eq ∎

      main : (e : ε) →
             (isJust : Is-just (pfRewrite e)) →
             AlgebraicEquality e (to-witness isJust)
      main (Ap g x) isJust with arity g Data.Nat.≟ 1
      ... | no differentArity = {!!} -- impossible
      ... | yes rightArity with Data.Vec.cast rightArity x
                              | inspect (Data.Vec.cast rightArity) x
      ... | Ap f y ∷ [] | ⟦ eq ⟧ =
            Transymmetry (subst (λ e → AlgebraicEquality (Ap (Compose g f rightArity) y)
                                                         (Ap g e))
                                (VecProp.cast-sym rightArity eq)
                                (composition-equality g f y rightArity))
                         (EqualityImpliesAE (sym to-witness-is-ap))
            where
            open AlgebraicEquality.Properties
            Transymmetry : {x y z : ε} →
                           AlgebraicEquality y x →
                           AlgebraicEquality y z →
                           AlgebraicEquality x z
            Transymmetry = Transitivity ∘ Symmetry
            to-witness-is-ap = to-witness-is-input isJust
              where
              to-witness-is-input :
                {a : Level} →
                {A : Set a} →
                {x : A} →
                (isJust : Is-just (just x)) →
                to-witness isJust ≡ x
              to-witness-is-input (AnyMaybe.just x) = refl
      ... | x | ⟦ unimportantProof ⟧ = {!!} -- impossible
      main x isJust = {!!} -- also impossible

    pfRewrite-basicEquality = pfRewrite-basicEquality.main
\end{code}

\subsection{The Justness Condition for \AgdaFunction{pfRewrite}}
\AgdaFunction{pfRewrite-just-condition} proves that \AgdaFunction{pfRewrite} \AgdaBound{e} is a \AgdaInductiveConstructor{just} value only if \AgdaBound{e} is of the form ``\AgdaInductiveConstructor{Ap} \AgdaBound{g} \AgdaInductiveConstructor{[} \AgdaInductiveConstructor{Ap} \AgdaBound{f} \AgdaBound{x} \AgdaInductiveConstructor{]}''.

\begin{code}
    pfRewrite-just-condition :
      (e : ε) →
      Is-just (pfRewrite e) →
      Σ (Σ F (λ f → arity f ≡ 1))
        (λ (g , arity1) →
           Σ (Σ F (Vec ε ∘ arity))
             (λ (f , x) →
                e ≡ Ap g (cast (sym arity1) [ Ap f x ])))
    pfRewrite-just-condition = {!!}
\end{code}

\subsection{\AgdaFunction{pfRewrite} Nothingness}
\AgdaFunction{pfRewrite-nothing} proves that if \AgdaBound{e} is \emph{not} of the form ``\AgdaInductiveConstructor{Ap} \AgdaBound{g} \AgdaInductiveConstructor{[} \AgdaInductiveConstructor{Ap} \AgdaBound{f} \AgdaBound{x} \AgdaInductiveConstructor{]}'', then \AgdaFunction{pfRewrite} \AgdaBound{e} is \AgdaInductiveConstructor{nothing}.

\begin{code}
    pfRewrite-nothing :
      (e : ε) →
      ¬ Σ (Σ F (λ f → arity f ≡ 1))
          (λ (g , arityIs1) →
             Σ (Σ F (Vec ε ∘ arity))
               (λ (f , x) →
                  e ≡ Ap g (Data.Vec.cast (sym arityIs1) [ Ap f x ]))) →
      Is-nothing (pfRewrite e)

    module pfRewrite-nothing where
      not-just-only-if-nothing :
        {a : Level} →
        {A : Set a} →
        {x : Maybe A} →
        ¬ Is-just x →
        Is-nothing x
      not-just-only-if-nothing {x = nothing} tt = AllMaybe.nothing
      not-just-only-if-nothing {x = just x} tt = {!!}

      main :
        (e : ε) →
        ¬ Σ (Σ F (λ f → arity f ≡ 1))
            (λ (g , arityIs1) →
               Σ (Σ F (Vec ε ∘ arity))
                 (λ (f , x) →
                    e ≡ Ap g (Data.Vec.cast (sym arityIs1) [ Ap f x ]))) →
        Is-nothing (pfRewrite e)
      main e N = not-just-only-if-nothing $ N ∘ pfRewrite-just-condition e

    pfRewrite-nothing = pfRewrite-nothing.main
\end{code}
n
\part{The Rest is F-L-Y}

\chapter{Overview and Intent}
This part contains \AgdaRecord{CAS} and \AgdaRecord{VCAS} values which indicate that Casanova Fly really \emph{is} a formally-verified computer algebra system, after all.

\section{Opening the Main Casanova Fly Module}
To reduce unnecessary repetition and other unreadable nonsense, the author has elected to \AgdaKeyword{open} \AgdaModule{CasanovaFlyCore}.

\begin{code}
open CasanovaFlyCore
\end{code}

\chapter{Proving that Casanova Fly is Really a Computer Algebra System}

\begin{code}
CasanovaFly-Base : CAS ε
CasanovaFly-Base = record
  { _≈_ = AlgebraicEquality
  ; _<_ = LessThan
  ; definitelyEquals = checkAlgebraicEquality
  ; isDefinitelyLessThan = {!!}
  ; exceptionallyEvaluate = commutativeEvaluate
  ; structuralEquality = structuralEqualityOnε
  ; fromℕ = NumberNat
  ; variableNamed = Variable
  ; _+_ = λ a b → Ap Sum (a ∷ b ∷ [])
  ; _-_ = λ x y → Ap Sum (x ∷ [ Ap Negate [ y ] ])
  ; _*_ = λ x y → Ap Product (x ∷ [ y ])
  ; _/_ = λ x y → Quotient x y (Coprimality.sym (Coprimality.1-coprimeTo 1))
  ; _^_ = λ x y → Ap Exponent (x ∷ [ y ])
  ; sin = Ap Sin ∘ [_]
  ; cos = Ap Cos ∘ [_]
  ; tan = Ap Tan ∘ [_]
  ; csc = Ap Csc ∘ [_]
  ; sec = Ap Sec ∘ [_]
  ; cot = Ap Cot ∘ [_]
  ; derivative = λ name e → Ap (Derivative name) [ e ]
  ; antiderivative = λ name e → Ap (Antiderivative name) [ e ]
  ; limit = λ n b e → Ap (Limit n) (b ∷ [ e ])
  ; boundedIntegral = λ name b1 b2 e → Ap (BoundedIntegral name) (b1 ∷ b2 ∷ [ e ])
  ; substituteVariables = varSubstM
  ; IsNameOfVariableIn = IsReferencedIn
  ; IsReal = {!!}
  ; IsInfinite = {!!}
  ; τ = {!!}
  ; lambda = λ name e1 e2 → Ap (Lambda List.[ name ]) (e1 ∷ [ e2 ])
  ; negation = Ap Negate ∘ [_]
  ; different-if-nats-are-different = {!!}
  ; differently-named-variables-are-different = {!!}
  }
\end{code}

\chapter{Proving that Casanova Fly has the Attributes of a Good Computer Algebra System}

\begin{code}
CasanovaFly-Verified : VCAS CasanovaFly-Base
CasanovaFly-Verified = record
  { equality-is-equivalence = AlgebraicEquality.equivalence
  ; sum-of-nats-is-nat-sum = sum-of-nats-is-nat-sum
  ; product-of-e-and-1-is-e = {!!}
  ; structural-equality-implies-definite-equality =
    structural-equality-implies-definite-equality
  ; differently-named-variables-are-not-definitely-equal = {!!}
  ; difference-is-negated-sum = {!!}
  ; inverse-of-inverse-is-original = invert-inverse
  ; division-by-zero-is-bogus = division-by-zero-is-bogus
  ; sum-is-not-bogus = {!!}
  ; sum-is-commutative = {!!}
  ; product-is-commutative = {!!}
  ; sum-is-associative = {!!}
  ; product-of-quotient-is-same = {!!}
  ; 0^0-is-bogus = 1 , _ , refl
  ; 0^-n-is-bogus = {!!}
  ; repeated-negation-cancelation =
    let open AlgebraicEquality in
    λ e → 1
        , Eventuality 0 1 (EqualityImpliesAE refl)
        , {!!}
  ; limit-of-constant-is-constant = {!!}
  ; limit-of-unrelated-value-is-unrelated-value = {!!}
  ; limit-of-same-variable-is-value = {!!}
  ; limit-of-sums-is-sum = {!!}
  ; limit-negation = {!!}
  ; limit-of-products-is-product = {!!}
  ; limit-of-non-bogus-expression = {!!}
  ; simple-lambda-substitution-works = {!!}
  ; nonapplicable-lambda-returns-lambda-body = {!!}
  ; unrelated-derivative = {!!}
  ; sin-n*pi-is-zero = {!!}
  ; garbage-variable-substitution-fails = {!!}
  ; substitution-order-is-irrelevant = {!!}
  ; derivative-of-constant = {!!}
  ; derivative-of-sine = {!!}
  ; derivative-of-cosine = {!!}
  ; derivative-of-tangent = {!!}
  ; derivative-of-cosecant = {!!}
  ; derivative-of-secant = {!!}
  ; derivative-of-cotangent = {!!}
  ; derivative-of-sum-is-sum-of-derivatives = {!!}
  ; derivative-of-product = {!!}
  ; tangent-is-bogus-at-quarter-tau = {!!}
  ; natural-less-than = {!!}
  }
  where
  open CAS CasanovaFly-Base
  open InternalEqualityFunctions

  sum-of-nats-is-nat-sum :
    (n1 n2 : ℕ) →
    equal-at-some-iteration (fromℕ n1 + fromℕ n2) (fromℕ (n1 Data.Nat.+ n2))
  sum-of-nats-is-nat-sum n1 n2 = 1 , {!!}

  invert-inverse : (e : ε) → equal-at-some-iteration e (Ap Negate [ Ap Negate [ e ] ])
  invert-inverse e = 1 , inv-inv-propEq e , {!!}
    where
    inv = Ap Negate ∘ [_]
    inv-inv-propEq :
      (e : ε) →
      e ≈ inv (inv e)
    -- Regardless of *eventual* bogosity, the first step *should* be fine.
    inv-inv-propEq e =
      AlgebraicEquality.Eventuality 0 1 (AlgebraicEquality.EqualityImpliesAE refl)

  division-by-zero-is-bogus :
    (e1 e2 : ε) →
    equal-at-some-iteration (fromℕ 0) e2 →
    bogus-at-some-iteration (e1 / e2)
  division-by-zero-is-bogus x y (iters , eq) with bogusBeforeIteration? (ℕ.suc iters) (x / y)
  ... | just (f , bogus) = Fin.toℕ f , bogus
  ... | nothing = ℕ.suc iters , _ , sym inj1Equality
    where
    inj1Equality = begin
      rEvaluate (ℕ.suc iters) (x / y)
        ≡⟨ {!!} ⟩
      inj₁ {!!} ∎

  structural-equality-implies-definite-equality :
    (e1 e2 : ε) →
    e1 ≡ e2 →
    (iterations : ℕ) →
    equal-at-iteration iterations e1 e2
  structural-equality-implies-definite-equality e1 e2 eq it =
    AlgebraicEquality.EqualityImpliesAE eq , sym caeEquality
    where
    open checkAlgebraicEquality
    caeEquality = begin
      main it e1 e2
        ≡⟨⟩
      with-dec it (structuralEqualityOnε e1 e2)
        ≡⟨ cong (with-dec it) (proj₂ decyes) ⟩
      with-dec it (yes (proj₁ decyes))
        ≡⟨⟩
      inj₂ (just (AlgebraicEquality.EqualityImpliesAE (proj₁ decyes)))
        ≡⟨ cong (inj₂ ∘ just ∘ AlgebraicEquality.EqualityImpliesAE)
                (≡-irrelevant (proj₁ decyes) eq) ⟩
      inj₂ (just (AlgebraicEquality.EqualityImpliesAE eq)) ∎
      where
      decyes = dec-yes (structuralEqualityOnε e1 e2) eq
\end{code}

\part{Miscellany}

\printbibliography{}

\newglossaryentry{algInj2equal}
  { name = algebraically \AgdaInductiveConstructor{inj₂}-equal
  , description = {Within this paper, values \AgdaBound{x} and \AgdaBound{y} of type \AgdaBound{A} \AgdaFunction{\AgdaDatatype{⊎}} \AgdaBound{B} are said to be \gls{algInj2equal} if and only if some values \AgdaBound{x'} and \AgdaBound{y'} exist such that \AgdaBound{x'} and \AgdaBound{y'} are algebraically equal, and \AgdaBound{x} and \AgdaBound{y} are \AgdaInductiveConstructor{inj₂} \AgdaBound{x'} and \AgdaInductiveConstructor{inj₂} \AgdaBound{y'}, respectively.  Equivalently, one can say that \AgdaBound{x} is \gls{algInj2equal} to \AgdaBound{y}}
  }

\newglossaryentry{inj2contain}
  { name = \AgdaInductiveConstructor{inj₂}-contains
  , plural = \AgdaInductiveConstructor{inj₂}-contain
  , description = {For the scope of this paper, a value \AgdaBound{x} of type \AgdaBound{A} \AgdaOperator{\AgdaDatatype{⊎}} \AgdaBound{B} is said to \glspl{inj2contain} a value \AgdaBound{y} of type \AgdaBound{B} if and only if \AgdaBound{x} is equal to \AgdaInductiveConstructor{inj₂} \AgdaBound{y}}
  }

\newglossaryentry{algEq1}
  { name = algebraically-equal\({}_1\)
  , description = A term \AgdaBound{x} is \AgdaBound{c}-\gls{algEq1} to some term \AgdaBound{y} if and only if there exists some value of type \AgdaField{CAS.\AgdaUnderscore{}≈\AgdaUnderscore{}} \AgdaBound{c} \AgdaBound{x} \AgdaBound{y}
  }

\newglossaryentry{algEq2}
  { name = algebraically-equal\({}_2\)
  , description = A mathematical expression \(x\) is \AgdaBound{c}-\gls{algEq2} to some mathematical expression \(y\) if and only if the \AgdaBound{c} CAS's representation of \(x\) is \AgdaBound{c}-\gls{algEq1} to the \AgdaBound{c} CAS's representation of \(y\)
  }

\newglossaryentry{algEq}
  { name = algebraically-equal
  , description = Any appropriate thing \(a\) is \AgdaBound{c}-\gls{algEq} to any appropriate thing \(b\) if and only if \(x\) is \AgdaBound{c}-\gls{algEq1} or \AgdaBound{c}-\gls{algEq2} to \(y\).  This term is vaguer than ``\AgdaBound{c}-\gls{algEq2}'' and ``\AgdaBound{c}-\gls{algEq1}'' and facilitates more concise communication
  }

\newglossaryentry{bogusWrt}
  { name = bogus with regard to
  , description = {For a given \AgdaRecord{CAS} record \AgdaBound{c}, some mathematical expression \(x\) is \gls{bogusWrt} \AgdaBound{c} if and only if there exists some value of type \AgdaField{CAS.IsBogus} \AgdaBound{c} \AgdaBound{x'}, where \AgdaBound{x'} represents \(x\)}
  }

\clearpage{}

\printglossary{}
\end{document}
